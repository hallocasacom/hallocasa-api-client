/* tslint:disable */
/* eslint-disable */
/**
 * Hallocasa API
 * Hallocasa API Documentation
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'formatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'line1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'line2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * 
     * @type {Country}
     * @memberof Address
     */
    'country'?: Country;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zipCode'?: string;
}
/**
 * 
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'userAlertType'?: AlertUserAlertTypeEnum;
    /**
     * 
     * @type {NotificationBody}
     * @memberof Alert
     */
    'alertCriteria'?: NotificationBody;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    'allowBrokerContact'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'lastNotification'?: string;
    /**
     * 
     * @type {NotificationBody}
     * @memberof Alert
     */
    'result'?: NotificationBody;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'newsletterOwnerId'?: number;
}

export const AlertUserAlertTypeEnum = {
    Property: 'PROPERTY'
} as const;

export type AlertUserAlertTypeEnum = typeof AlertUserAlertTypeEnum[keyof typeof AlertUserAlertTypeEnum];

/**
 * 
 * @export
 * @interface Attachment
 */
export interface Attachment {
    /**
     * 
     * @type {User}
     * @memberof Attachment
     */
    'userFrom'?: User;
    /**
     * 
     * @type {User}
     * @memberof Attachment
     */
    'userTo'?: User;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'fileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'uploadUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'downloadUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Attachment
     */
    'originalName'?: string;
}
/**
 * 
 * @export
 * @interface AuthInfoDto
 */
export interface AuthInfoDto {
    /**
     * 
     * @type {UserDto}
     * @memberof AuthInfoDto
     */
    'user'?: UserDto;
    /**
     * 
     * @type {SecurityToken}
     * @memberof AuthInfoDto
     */
    'securityToken'?: SecurityToken;
}
/**
 * 
 * @export
 * @interface AutopilotUser
 */
export interface AutopilotUser {
    /**
     * 
     * @type {string}
     * @memberof AutopilotUser
     */
    'contactId': string;
    /**
     * 
     * @type {string}
     * @memberof AutopilotUser
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface BaseFilterResult
 */
export interface BaseFilterResult {
    /**
     * 
     * @type {number}
     * @memberof BaseFilterResult
     */
    'count'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof BaseFilterResult
     */
    'list'?: Array<object>;
}
/**
 * 
 * @export
 * @interface Brokerage
 */
export interface Brokerage {
    /**
     * 
     * @type {number}
     * @memberof Brokerage
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface ChatAllowance
 */
export interface ChatAllowance {
    /**
     * 
     * @type {User}
     * @memberof ChatAllowance
     */
    'userFrom'?: User;
    /**
     * 
     * @type {User}
     * @memberof ChatAllowance
     */
    'userTo'?: User;
    /**
     * 
     * @type {string}
     * @memberof ChatAllowance
     */
    'currentDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatAllowance
     */
    'chatAllowanceType'?: ChatAllowanceChatAllowanceTypeEnum;
}

export const ChatAllowanceChatAllowanceTypeEnum = {
    Rejected: 'REJECTED',
    Accepted: 'ACCEPTED',
    Pending: 'PENDING',
    Blocked: 'BLOCKED',
    Silenced: 'SILENCED'
} as const;

export type ChatAllowanceChatAllowanceTypeEnum = typeof ChatAllowanceChatAllowanceTypeEnum[keyof typeof ChatAllowanceChatAllowanceTypeEnum];

/**
 * 
 * @export
 * @interface ChatTicket
 */
export interface ChatTicket {
    /**
     * 
     * @type {string}
     * @memberof ChatTicket
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ChatTicket
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ChatTicket
     */
    'ip'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatTicket
     */
    'creationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatTicket
     */
    'expirationTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChatTicket
     */
    'browser'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChatTicket
     */
    'expired'?: boolean;
}
/**
 * 
 * @export
 * @interface CheckoutSessionDto
 */
export interface CheckoutSessionDto {
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionDto
     */
    'id'?: string;
    /**
     * 
     * @type {SubscriptionPlanDto}
     * @memberof CheckoutSessionDto
     */
    'subscriptionPlan': SubscriptionPlanDto;
    /**
     * 
     * @type {SubscriptionPriceDto}
     * @memberof CheckoutSessionDto
     */
    'price': SubscriptionPriceDto;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionDto
     */
    'status'?: CheckoutSessionDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionDto
     */
    'affiliateRefNumber'?: string;
    /**
     * 
     * @type {SubscribedUserDto}
     * @memberof CheckoutSessionDto
     */
    'user': SubscribedUserDto;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionDto
     */
    'successUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionDto
     */
    'cancelUrl'?: string;
}

export const CheckoutSessionDtoStatusEnum = {
    InProcess: 'IN_PROCESS',
    Success: 'SUCCESS',
    Canceled: 'CANCELED',
    Failed: 'FAILED'
} as const;

export type CheckoutSessionDtoStatusEnum = typeof CheckoutSessionDtoStatusEnum[keyof typeof CheckoutSessionDtoStatusEnum];

/**
 * 
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * 
     * @type {User}
     * @memberof Contract
     */
    'legalOwner'?: User;
    /**
     * 
     * @type {User}
     * @memberof Contract
     */
    'counterParty'?: User;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'creationDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'contractUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'ndaUrl'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Contract
     */
    'legalOwnerSigned'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Contract
     */
    'counterPartySigned'?: boolean;
}
/**
 * 
 * @export
 * @interface ConversationSummary
 */
export interface ConversationSummary {
    /**
     * 
     * @type {User}
     * @memberof ConversationSummary
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof ConversationSummary
     */
    'lastMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof ConversationSummary
     */
    'lastMessageDateTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConversationSummary
     */
    'newMessagesCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ConversationSummary
     */
    'chatAllowanceType'?: ConversationSummaryChatAllowanceTypeEnum;
}

export const ConversationSummaryChatAllowanceTypeEnum = {
    Rejected: 'REJECTED',
    Accepted: 'ACCEPTED',
    Pending: 'PENDING',
    Blocked: 'BLOCKED',
    Silenced: 'SILENCED'
} as const;

export type ConversationSummaryChatAllowanceTypeEnum = typeof ConversationSummaryChatAllowanceTypeEnum[keyof typeof ConversationSummaryChatAllowanceTypeEnum];

/**
 * Country information
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * Country identifier
     * @type {number}
     * @memberof Country
     */
    'id': number;
    /**
     * Country code (ISO 3166 alpha-2)
     * @type {string}
     * @memberof Country
     */
    'code'?: string;
    /**
     * Country name
     * @type {string}
     * @memberof Country
     */
    'name'?: string;
    /**
     * Language code
     * @type {string}
     * @memberof Country
     */
    'lang'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof Country
     */
    'currency'?: Currency;
    /**
     * Locale code
     * @type {string}
     * @memberof Country
     */
    'locale'?: string;
}
/**
 * 
 * @export
 * @interface CountryPhonePrefix
 */
export interface CountryPhonePrefix {
    /**
     * 
     * @type {number}
     * @memberof CountryPhonePrefix
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CountryPhonePrefix
     */
    'prefix'?: number;
    /**
     * 
     * @type {string}
     * @memberof CountryPhonePrefix
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CountryPhonePrefix
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface CountryTelephonePrefix
 */
export interface CountryTelephonePrefix {
    /**
     * 
     * @type {number}
     * @memberof CountryTelephonePrefix
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CountryTelephonePrefix
     */
    'prefix'?: number;
    /**
     * 
     * @type {string}
     * @memberof CountryTelephonePrefix
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CountryTelephonePrefix
     */
    'lang'?: string;
}
/**
 * Currency information
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * Currency identifier
     * @type {number}
     * @memberof Currency
     */
    'id'?: number;
    /**
     * Currency code (ISO 4217)
     * @type {string}
     * @memberof Currency
     */
    'abbreviation'?: string;
    /**
     * Currency name
     * @type {string}
     * @memberof Currency
     */
    'name'?: string;
    /**
     * Language code
     * @type {string}
     * @memberof Currency
     */
    'lang'?: string;
    /**
     * Currency symbol
     * @type {string}
     * @memberof Currency
     */
    'prefix'?: string;
}
/**
 * 
 * @export
 * @interface CurrencyAmmount
 */
export interface CurrencyAmmount {
    /**
     * 
     * @type {Currency}
     * @memberof CurrencyAmmount
     */
    'currency'?: Currency;
    /**
     * 
     * @type {number}
     * @memberof CurrencyAmmount
     */
    'ammount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyAmmount
     */
    'valid'?: boolean;
}
/**
 * 
 * @export
 * @interface CustomerSessionDto
 */
export interface CustomerSessionDto {
    /**
     * 
     * @type {string}
     * @memberof CustomerSessionDto
     */
    'id'?: string;
    /**
     * 
     * @type {SubscribedUserDto}
     * @memberof CustomerSessionDto
     */
    'user'?: SubscribedUserDto;
    /**
     * 
     * @type {string}
     * @memberof CustomerSessionDto
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerSessionDto
     */
    'returnUrl'?: string;
}
/**
 * 
 * @export
 * @interface DropdownOption
 */
export interface DropdownOption {
    /**
     * 
     * @type {number}
     * @memberof DropdownOption
     */
    'optionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data1'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data2'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data3'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data4'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data5'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data6'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data7'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data8'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DropdownOption
     */
    'dependsOnLang'?: boolean;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof DropdownOption
     */
    'parentInfo'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface DropdownOptionGroup
 */
export interface DropdownOptionGroup {
    /**
     * 
     * @type {number}
     * @memberof DropdownOptionGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DropdownOptionGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOptionGroup
     */
    'translationManagement'?: DropdownOptionGroupTranslationManagementEnum;
    /**
     * 
     * @type {Array<DropdownOption>}
     * @memberof DropdownOptionGroup
     */
    'dropdownOptionList'?: Array<DropdownOption>;
}

export const DropdownOptionGroupTranslationManagementEnum = {
    Total: 'TOTAL',
    Partial: 'PARTIAL',
    None: 'NONE'
} as const;

export type DropdownOptionGroupTranslationManagementEnum = typeof DropdownOptionGroupTranslationManagementEnum[keyof typeof DropdownOptionGroupTranslationManagementEnum];

/**
 * 
 * @export
 * @interface ExchangeRateMap
 */
export interface ExchangeRateMap {
    [key: string]: { [key: string]: number; } | any;

    /**
     * 
     * @type {boolean}
     * @memberof ExchangeRateMap
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface FBPropertyDto
 */
export interface FBPropertyDto {
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'availability'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'home_listing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'home_listing_group_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'address.addr1'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'address.city'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'address.region'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'address.country'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'address.postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'image[0].url'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'num_beds'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'num_baths'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'num_rooms'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'property_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof FBPropertyDto
     */
    'area_size'?: number;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'area_unit'?: string;
}
/**
 * 
 * @export
 * @interface Favorite
 */
export interface Favorite {
    /**
     * 
     * @type {number}
     * @memberof Favorite
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Favorite
     */
    'resourceType': FavoriteResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Favorite
     */
    'resourceId': string;
    /**
     * 
     * @type {NotificationBody}
     * @memberof Favorite
     */
    'resource'?: NotificationBody;
}

export const FavoriteResourceTypeEnum = {
    Property: 'PROPERTY'
} as const;

export type FavoriteResourceTypeEnum = typeof FavoriteResourceTypeEnum[keyof typeof FavoriteResourceTypeEnum];

/**
 * 
 * @export
 * @interface FeatureDto
 */
export interface FeatureDto {
    /**
     * 
     * @type {number}
     * @memberof FeatureDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeatureDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureDto
     */
    'lang'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureDto
     */
    'descriptionLang'?: string;
}
/**
 * 
 * @export
 * @interface FilterShowingStep
 */
export interface FilterShowingStep {
    /**
     * 
     * @type {string}
     * @memberof FilterShowingStep
     */
    'sequenceBefore'?: FilterShowingStepSequenceBeforeEnum;
    /**
     * 
     * @type {HcFilterCondition}
     * @memberof FilterShowingStep
     */
    'filterCondition'?: HcFilterCondition;
    /**
     * 
     * @type {string}
     * @memberof FilterShowingStep
     */
    'sequenceAfter'?: FilterShowingStepSequenceAfterEnum;
}

export const FilterShowingStepSequenceBeforeEnum = {
    InitGroup: 'INIT_GROUP',
    EndGroup: 'END_GROUP',
    And: 'AND',
    Or: 'OR'
} as const;

export type FilterShowingStepSequenceBeforeEnum = typeof FilterShowingStepSequenceBeforeEnum[keyof typeof FilterShowingStepSequenceBeforeEnum];
export const FilterShowingStepSequenceAfterEnum = {
    InitGroup: 'INIT_GROUP',
    EndGroup: 'END_GROUP',
    And: 'AND',
    Or: 'OR'
} as const;

export type FilterShowingStepSequenceAfterEnum = typeof FilterShowingStepSequenceAfterEnum[keyof typeof FilterShowingStepSequenceAfterEnum];

/**
 * 
 * @export
 * @interface GeoLocation
 */
export interface GeoLocation {
    /**
     * 
     * @type {number}
     * @memberof GeoLocation
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof GeoLocation
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface GeoPlace
 */
export interface GeoPlace {
    /**
     * 
     * @type {GeoLocation}
     * @memberof GeoPlace
     */
    'geoLocation'?: GeoLocation;
    /**
     * 
     * @type {Address}
     * @memberof GeoPlace
     */
    'address'?: Address;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof Group
     */
    'owner'?: User;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'locationLatitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'locationLongitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'locationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'locationDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'backgroundImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'creationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'groupStatus'?: GroupGroupStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'backgroundImageBase64'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'logoImageBase64'?: string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'noOfMembers'?: number;
}

export const GroupGroupStatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED',
    Deleted: 'DELETED'
} as const;

export type GroupGroupStatusEnum = typeof GroupGroupStatusEnum[keyof typeof GroupGroupStatusEnum];

/**
 * 
 * @export
 * @interface GroupMember
 */
export interface GroupMember {
    /**
     * 
     * @type {number}
     * @memberof GroupMember
     */
    'id'?: number;
    /**
     * 
     * @type {User}
     * @memberof GroupMember
     */
    'user'?: User;
    /**
     * 
     * @type {Group}
     * @memberof GroupMember
     */
    'group'?: Group;
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'creationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'groupMemberStatus'?: GroupMemberGroupMemberStatusEnum;
}

export const GroupMemberGroupMemberStatusEnum = {
    Invited: 'INVITED',
    Requested: 'REQUESTED',
    Accepted: 'ACCEPTED',
    Rejected: 'REJECTED',
    Removed: 'REMOVED',
    Left: 'LEFT'
} as const;

export type GroupMemberGroupMemberStatusEnum = typeof GroupMemberGroupMemberStatusEnum[keyof typeof GroupMemberGroupMemberStatusEnum];

/**
 * 
 * @export
 * @interface HcFilter
 */
export interface HcFilter {
    /**
     * 
     * @type {number}
     * @memberof HcFilter
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilter
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HcFilter
     */
    'lang'?: string;
    /**
     * 
     * @type {HcFilterType}
     * @memberof HcFilter
     */
    'filterType'?: HcFilterType;
    /**
     * 
     * @type {HcFilterNature}
     * @memberof HcFilter
     */
    'filterNature'?: HcFilterNature;
    /**
     * 
     * @type {Array<FilterShowingStep>}
     * @memberof HcFilter
     */
    'showingStepList'?: Array<FilterShowingStep>;
    /**
     * 
     * @type {HcFilter}
     * @memberof HcFilter
     */
    'parentFilter'?: HcFilter;
    /**
     * 
     * @type {string}
     * @memberof HcFilter
     */
    'choice'?: HcFilterChoiceEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilter
     */
    'usePropertyField'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HcFilter
     */
    'filterWorkerOption'?: HcFilterFilterWorkerOptionEnum;
    /**
     * 
     * @type {string}
     * @memberof HcFilter
     */
    'hcListerOption'?: HcFilterHcListerOptionEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilter
     */
    'useStaticFilterOptions'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilter
     */
    'forceAllFilterOptions'?: boolean;
}

export const HcFilterChoiceEnum = {
    Show: 'SHOW',
    Hide: 'HIDE'
} as const;

export type HcFilterChoiceEnum = typeof HcFilterChoiceEnum[keyof typeof HcFilterChoiceEnum];
export const HcFilterFilterWorkerOptionEnum = {
    PropertyLocationKey: 'PROPERTY_LOCATION_KEY',
    CountryKey: 'COUNTRY_KEY',
    PropertyProposalKey: 'PROPERTY_PROPOSAL_KEY',
    Range: 'RANGE',
    Dropdown: 'DROPDOWN',
    Boolean: 'BOOLEAN',
    CurrencyRange: 'CURRENCY_RANGE',
    Roi: 'ROI',
    FreeText: 'FREE_TEXT',
    Id: 'ID',
    PublicationState: 'PUBLICATION_STATE',
    PublicationDate: 'PUBLICATION_DATE',
    GeolocationArea: 'GEOLOCATION_AREA',
    Groups: 'GROUPS',
    UserId: 'USER_ID',
    XmlId: 'XML_ID'
} as const;

export type HcFilterFilterWorkerOptionEnum = typeof HcFilterFilterWorkerOptionEnum[keyof typeof HcFilterFilterWorkerOptionEnum];
export const HcFilterHcListerOptionEnum = {
    PropertyType: 'PROPERTY_TYPE'
} as const;

export type HcFilterHcListerOptionEnum = typeof HcFilterHcListerOptionEnum[keyof typeof HcFilterHcListerOptionEnum];

/**
 * 
 * @export
 * @interface HcFilterCondition
 */
export interface HcFilterCondition {
    /**
     * 
     * @type {number}
     * @memberof HcFilterCondition
     */
    'filterId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'searchSpecific'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'containsAtLeastOne'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'containsAll'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'containsNumber'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof HcFilterCondition
     */
    'number'?: number;
    /**
     * 
     * @type {number}
     * @memberof HcFilterCondition
     */
    'selectedNumberAny'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilterCondition
     */
    'minOperand'?: HcFilterConditionMinOperandEnum;
    /**
     * 
     * @type {string}
     * @memberof HcFilterCondition
     */
    'maxOperand'?: HcFilterConditionMaxOperandEnum;
    /**
     * 
     * @type {number}
     * @memberof HcFilterCondition
     */
    'minValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof HcFilterCondition
     */
    'maxValue'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'applyMinConstraint'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'applyMaxConstraint'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'apply'?: boolean;
}

export const HcFilterConditionMinOperandEnum = {
    Gt: 'GT',
    Get: 'GET',
    Eq: 'EQ',
    Lt: 'LT',
    Let: 'LET'
} as const;

export type HcFilterConditionMinOperandEnum = typeof HcFilterConditionMinOperandEnum[keyof typeof HcFilterConditionMinOperandEnum];
export const HcFilterConditionMaxOperandEnum = {
    Gt: 'GT',
    Get: 'GET',
    Eq: 'EQ',
    Lt: 'LT',
    Let: 'LET'
} as const;

export type HcFilterConditionMaxOperandEnum = typeof HcFilterConditionMaxOperandEnum[keyof typeof HcFilterConditionMaxOperandEnum];

/**
 * 
 * @export
 * @interface HcFilterEntry
 */
export interface HcFilterEntry {
    /**
     * 
     * @type {number}
     * @memberof HcFilterEntry
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'lang'?: string;
    /**
     * 
     * @type {HcFilterTypeEntry}
     * @memberof HcFilterEntry
     */
    'filterType'?: HcFilterTypeEntry;
    /**
     * 
     * @type {HcFilterNature}
     * @memberof HcFilterEntry
     */
    'filterNature'?: HcFilterNature;
    /**
     * 
     * @type {Array<FilterShowingStep>}
     * @memberof HcFilterEntry
     */
    'showingStepList'?: Array<FilterShowingStep>;
    /**
     * 
     * @type {HcFilter}
     * @memberof HcFilterEntry
     */
    'parentFilter'?: HcFilter;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'choice'?: HcFilterEntryChoiceEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'usePropertyField'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'filterWorkerOption'?: HcFilterEntryFilterWorkerOptionEnum;
    /**
     * 
     * @type {number}
     * @memberof HcFilterEntry
     */
    'minValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof HcFilterEntry
     */
    'maxValue'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'minValueDateInPast'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'minValueDateInFuture'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'maxValueDateInPast'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'maxValueDateInFuture'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'useStaticFilterOptions'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'forceAllFilterOptions'?: boolean;
    /**
     * 
     * @type {DropdownOptionGroup}
     * @memberof HcFilterEntry
     */
    'dropdownOptionGroup'?: DropdownOptionGroup;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'yesText'?: string;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'noText'?: string;
}

export const HcFilterEntryChoiceEnum = {
    Show: 'SHOW',
    Hide: 'HIDE'
} as const;

export type HcFilterEntryChoiceEnum = typeof HcFilterEntryChoiceEnum[keyof typeof HcFilterEntryChoiceEnum];
export const HcFilterEntryFilterWorkerOptionEnum = {
    PropertyLocationKey: 'PROPERTY_LOCATION_KEY',
    CountryKey: 'COUNTRY_KEY',
    PropertyProposalKey: 'PROPERTY_PROPOSAL_KEY',
    Range: 'RANGE',
    Dropdown: 'DROPDOWN',
    Boolean: 'BOOLEAN',
    CurrencyRange: 'CURRENCY_RANGE',
    Roi: 'ROI',
    FreeText: 'FREE_TEXT',
    Id: 'ID',
    PublicationState: 'PUBLICATION_STATE',
    PublicationDate: 'PUBLICATION_DATE',
    GeolocationArea: 'GEOLOCATION_AREA',
    Groups: 'GROUPS',
    UserId: 'USER_ID',
    XmlId: 'XML_ID'
} as const;

export type HcFilterEntryFilterWorkerOptionEnum = typeof HcFilterEntryFilterWorkerOptionEnum[keyof typeof HcFilterEntryFilterWorkerOptionEnum];

/**
 * 
 * @export
 * @interface HcFilterNature
 */
export interface HcFilterNature {
    /**
     * 
     * @type {number}
     * @memberof HcFilterNature
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilterNature
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface HcFilterType
 */
export interface HcFilterType {
    /**
     * 
     * @type {number}
     * @memberof HcFilterType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilterType
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HcFilterType
     */
    'filterTypeNature'?: HcFilterTypeFilterTypeNatureEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useSlider'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'validateMin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'validateMax'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'allowMultiple'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useSearch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useSort'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useSelectAll'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useRemoteList'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useLinks'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useYesNoDropdown'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useCheckbox'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useRadio'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useText'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'toggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'sortSign'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'rangeOnlyFrom'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'rangeOnlyTo'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HcFilterType
     */
    'rangeFieldPresentation'?: HcFilterTypeRangeFieldPresentationEnum;
}

export const HcFilterTypeFilterTypeNatureEnum = {
    Dropdown: 'DROPDOWN',
    Yesno: 'YESNO',
    Range: 'RANGE',
    Text: 'TEXT',
    AreaRange: 'AREA_RANGE'
} as const;

export type HcFilterTypeFilterTypeNatureEnum = typeof HcFilterTypeFilterTypeNatureEnum[keyof typeof HcFilterTypeFilterTypeNatureEnum];
export const HcFilterTypeRangeFieldPresentationEnum = {
    Integer: 'INTEGER',
    Double: 'DOUBLE',
    Currency: 'CURRENCY',
    Date: 'DATE'
} as const;

export type HcFilterTypeRangeFieldPresentationEnum = typeof HcFilterTypeRangeFieldPresentationEnum[keyof typeof HcFilterTypeRangeFieldPresentationEnum];

/**
 * 
 * @export
 * @interface HcFilterTypeEntry
 */
export interface HcFilterTypeEntry {
    /**
     * 
     * @type {number}
     * @memberof HcFilterTypeEntry
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilterTypeEntry
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HcFilterTypeEntry
     */
    'filterTypeNature'?: HcFilterTypeEntryFilterTypeNatureEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useSlider'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'onlyFrom'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'onlyTo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'validateMin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'validateMax'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HcFilterTypeEntry
     */
    'rangeFieldPresentation'?: HcFilterTypeEntryRangeFieldPresentationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'allowMultiple'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useSearch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useSort'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useSelectAll'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useRemoteList'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useLinks'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useYesNoDropdown'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useCheckbox'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useRadio'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useText'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'toggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'sortSign'?: boolean;
}

export const HcFilterTypeEntryFilterTypeNatureEnum = {
    Dropdown: 'DROPDOWN',
    Yesno: 'YESNO',
    Range: 'RANGE',
    Text: 'TEXT',
    AreaRange: 'AREA_RANGE'
} as const;

export type HcFilterTypeEntryFilterTypeNatureEnum = typeof HcFilterTypeEntryFilterTypeNatureEnum[keyof typeof HcFilterTypeEntryFilterTypeNatureEnum];
export const HcFilterTypeEntryRangeFieldPresentationEnum = {
    Integer: 'INTEGER',
    Double: 'DOUBLE',
    Currency: 'CURRENCY',
    Date: 'DATE'
} as const;

export type HcFilterTypeEntryRangeFieldPresentationEnum = typeof HcFilterTypeEntryRangeFieldPresentationEnum[keyof typeof HcFilterTypeEntryRangeFieldPresentationEnum];

/**
 * 
 * @export
 * @interface JsonObject
 */
export interface JsonObject {
    [key: string]: JsonValue | any;

    /**
     * 
     * @type {string}
     * @memberof JsonObject
     */
    'valueType'?: JsonObjectValueTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof JsonObject
     */
    'empty'?: boolean;
}

export const JsonObjectValueTypeEnum = {
    Array: 'ARRAY',
    Object: 'OBJECT',
    String: 'STRING',
    Number: 'NUMBER',
    True: 'TRUE',
    False: 'FALSE',
    Null: 'NULL'
} as const;

export type JsonObjectValueTypeEnum = typeof JsonObjectValueTypeEnum[keyof typeof JsonObjectValueTypeEnum];

/**
 * 
 * @export
 * @interface JsonValue
 */
export interface JsonValue {
    /**
     * 
     * @type {string}
     * @memberof JsonValue
     */
    'valueType'?: JsonValueValueTypeEnum;
}

export const JsonValueValueTypeEnum = {
    Array: 'ARRAY',
    Object: 'OBJECT',
    String: 'STRING',
    Number: 'NUMBER',
    True: 'TRUE',
    False: 'FALSE',
    Null: 'NULL'
} as const;

export type JsonValueValueTypeEnum = typeof JsonValueValueTypeEnum[keyof typeof JsonValueValueTypeEnum];

/**
 * 
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {number}
     * @memberof Language
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'locale'?: string;
}
/**
 * 
 * @export
 * @interface LocalDateTimeQueryString
 */
export interface LocalDateTimeQueryString {
    /**
     * 
     * @type {string}
     * @memberof LocalDateTimeQueryString
     */
    'utcValue'?: string;
    /**
     * 
     * @type {number}
     * @memberof LocalDateTimeQueryString
     */
    'millsFromEpoch'?: number;
}
/**
 * 
 * @export
 * @interface LocaleSet
 */
export interface LocaleSet {
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'pnemonic'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'enUS'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'esES'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'deDE'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'zhCN'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'ruRU'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'frFR'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'ptPT'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'itIT'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'jaJP'?: string;
}
/**
 * 
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'module'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {User}
     * @memberof Message
     */
    'userFrom'?: User;
    /**
     * 
     * @type {User}
     * @memberof Message
     */
    'userTo'?: User;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'fileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'fileId'?: string;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'dateTime'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Message
     */
    'notifiedByChat'?: boolean;
}
/**
 * Newsletter subscriber information
 * @export
 * @interface NewsletterSubscriberDto
 */
export interface NewsletterSubscriberDto {
    /**
     * 
     * @type {Alert}
     * @memberof NewsletterSubscriberDto
     */
    'alert'?: Alert;
    /**
     * 
     * @type {SkilledUser}
     * @memberof NewsletterSubscriberDto
     */
    'user'?: SkilledUser;
}
/**
 * 
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     * 
     * @type {number}
     * @memberof Notification
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'type': NotificationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Notification
     */
    'currentDateTime'?: string;
    /**
     * 
     * @type {NotificationBody}
     * @memberof Notification
     */
    'body'?: NotificationBody;
}

export const NotificationTypeEnum = {
    ToBrokerAlertCreated: 'TO_BROKER__ALERT_CREATED',
    ToUserWeeklyProperties: 'TO_USER__WEEKLY_PROPERTIES',
    ToUserWeeklyPayedSubscribers: 'TO_USER__WEEKLY_PAYED_SUBSCRIBERS',
    ToUserCustomizedAlert: 'TO_USER__CUSTOMIZED_ALERT',
    ToUserWeeklyGroupProperties: 'TO_USER__WEEKLY_GROUP_PROPERTIES',
    ToUserNewsletterNewSubscriber: 'TO_USER__NEWSLETTER_NEW_SUBSCRIBER',
    ToUserNewsletterConfirmation: 'TO_USER__NEWSLETTER_CONFIRMATION',
    ToUserNewsletterListing: 'TO_USER__NEWSLETTER_LISTING'
} as const;

export type NotificationTypeEnum = typeof NotificationTypeEnum[keyof typeof NotificationTypeEnum];

/**
 * 
 * @export
 * @interface NotificationBody
 */
export interface NotificationBody {
    [key: string]: JsonValue | any;

    /**
     * 
     * @type {string}
     * @memberof NotificationBody
     */
    'valueType'?: NotificationBodyValueTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof NotificationBody
     */
    'empty'?: boolean;
}

export const NotificationBodyValueTypeEnum = {
    Array: 'ARRAY',
    Object: 'OBJECT',
    String: 'STRING',
    Number: 'NUMBER',
    True: 'TRUE',
    False: 'FALSE',
    Null: 'NULL'
} as const;

export type NotificationBodyValueTypeEnum = typeof NotificationBodyValueTypeEnum[keyof typeof NotificationBodyValueTypeEnum];

/**
 * 
 * @export
 * @interface NotifyUploadRequest
 */
export interface NotifyUploadRequest {
    /**
     * 
     * @type {string}
     * @memberof NotifyUploadRequest
     */
    'fileName'?: string;
}
/**
 * Request object for password recovery operations
 * @export
 * @interface PasswordRecoveryRequest
 */
export interface PasswordRecoveryRequest {
    /**
     * New password to set for the user
     * @type {string}
     * @memberof PasswordRecoveryRequest
     */
    'newPassword': string;
    /**
     * 
     * @type {PasswordRecoveryToken}
     * @memberof PasswordRecoveryRequest
     */
    'passwordRecoveryToken': PasswordRecoveryToken;
}
/**
 * Token used for password recovery process
 * @export
 * @interface PasswordRecoveryToken
 */
export interface PasswordRecoveryToken {
    /**
     * Unique identifier for the token
     * @type {number}
     * @memberof PasswordRecoveryToken
     */
    'id'?: number;
    /**
     * ID of the associated user
     * @type {number}
     * @memberof PasswordRecoveryToken
     */
    'idAssociated'?: number;
    /**
     * Token content that is sent in the recovery email
     * @type {string}
     * @memberof PasswordRecoveryToken
     */
    'tokenContent': string;
    /**
     * Expiration date of the token
     * @type {string}
     * @memberof PasswordRecoveryToken
     */
    'dueDate'?: string;
    /**
     * Whether the token is active or already used
     * @type {boolean}
     * @memberof PasswordRecoveryToken
     */
    'active'?: boolean;
    /**
     * Date when the token was created
     * @type {string}
     * @memberof PasswordRecoveryToken
     */
    'expeditionDate'?: string;
}
/**
 * 
 * @export
 * @interface PhoneCodeCheckResource
 */
export interface PhoneCodeCheckResource {
    /**
     * 
     * @type {string}
     * @memberof PhoneCodeCheckResource
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface PhoneCodeRequestResource
 */
export interface PhoneCodeRequestResource {
    /**
     * 
     * @type {string}
     * @memberof PhoneCodeRequestResource
     */
    'verificationType': string;
}
/**
 * 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof Property
     */
    'user': User;
    /**
     * 
     * @type {PropertyType}
     * @memberof Property
     */
    'propertyType'?: PropertyType;
    /**
     * 
     * @type {PropertyLocation}
     * @memberof Property
     */
    'propertyLocation'?: PropertyLocation;
    /**
     * 
     * @type {PropertyProposal}
     * @memberof Property
     */
    'propertyProposal'?: PropertyProposal;
    /**
     * 
     * @type {Country}
     * @memberof Property
     */
    'country'?: Country;
    /**
     * 
     * @type {PropertyKey}
     * @memberof Property
     */
    'propertyKey'?: PropertyKey;
    /**
     * 
     * @type {Array<PropertyField>}
     * @memberof Property
     */
    'fieldList'?: Array<PropertyField>;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'publishDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'modifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'publicationState'?: PropertyPublicationStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'isPrivate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'isDraft'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Property
     */
    'groupIds'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'shouldPublishEmailsToGroups'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'isPasswordProtected'?: boolean;
}

export const PropertyPublicationStateEnum = {
    Available: 'AVAILABLE',
    Rented: 'RENTED',
    Sold: 'SOLD',
    Draft: 'DRAFT'
} as const;

export type PropertyPublicationStateEnum = typeof PropertyPublicationStateEnum[keyof typeof PropertyPublicationStateEnum];

/**
 * 
 * @export
 * @interface PropertyField
 */
export interface PropertyField {
    /**
     * 
     * @type {number}
     * @memberof PropertyField
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'lang'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyField
     */
    'basic'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyField
     */
    'primaryKey'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyField
     */
    'multilanguageValue'?: boolean;
    /**
     * 
     * @type {PropertyFieldType}
     * @memberof PropertyField
     */
    'propertyFieldType'?: PropertyFieldType;
    /**
     * 
     * @type {PropertyFieldValueType}
     * @memberof PropertyField
     */
    'propertyFieldValueType'?: PropertyFieldValueType;
    /**
     * 
     * @type {Array<PropertyFieldValue>}
     * @memberof PropertyField
     */
    'fieldValueList'?: Array<PropertyFieldValue>;
    /**
     * 
     * @type {DropdownOptionGroup}
     * @memberof PropertyField
     */
    'dropdownOptionGroup'?: DropdownOptionGroup;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'tooltipLang'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'textType'?: PropertyFieldTextTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'data1Type'?: PropertyFieldData1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'data2Type'?: PropertyFieldData2TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'data3Type'?: PropertyFieldData3TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'hcListerOption'?: PropertyFieldHcListerOptionEnum;
}

export const PropertyFieldTextTypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
} as const;

export type PropertyFieldTextTypeEnum = typeof PropertyFieldTextTypeEnum[keyof typeof PropertyFieldTextTypeEnum];
export const PropertyFieldData1TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
} as const;

export type PropertyFieldData1TypeEnum = typeof PropertyFieldData1TypeEnum[keyof typeof PropertyFieldData1TypeEnum];
export const PropertyFieldData2TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
} as const;

export type PropertyFieldData2TypeEnum = typeof PropertyFieldData2TypeEnum[keyof typeof PropertyFieldData2TypeEnum];
export const PropertyFieldData3TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
} as const;

export type PropertyFieldData3TypeEnum = typeof PropertyFieldData3TypeEnum[keyof typeof PropertyFieldData3TypeEnum];
export const PropertyFieldHcListerOptionEnum = {
    PropertyType: 'PROPERTY_TYPE'
} as const;

export type PropertyFieldHcListerOptionEnum = typeof PropertyFieldHcListerOptionEnum[keyof typeof PropertyFieldHcListerOptionEnum];

/**
 * 
 * @export
 * @interface PropertyFieldType
 */
export interface PropertyFieldType {
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyFieldType
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PropertyFieldValue
 */
export interface PropertyFieldValue {
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValue
     */
    'bdid'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValue
     */
    'identifier'?: number;
    /**
     * 
     * @type {PropertyFieldValueSpec}
     * @memberof PropertyFieldValue
     */
    'text'?: PropertyFieldValueSpec;
    /**
     * 
     * @type {PropertyFieldValueSpec}
     * @memberof PropertyFieldValue
     */
    'data1'?: PropertyFieldValueSpec;
    /**
     * 
     * @type {PropertyFieldValueSpec}
     * @memberof PropertyFieldValue
     */
    'data2'?: PropertyFieldValueSpec;
    /**
     * 
     * @type {PropertyFieldValueSpec}
     * @memberof PropertyFieldValue
     */
    'data3'?: PropertyFieldValueSpec;
}
/**
 * 
 * @export
 * @interface PropertyFieldValueSpec
 */
export interface PropertyFieldValueSpec {
    /**
     * 
     * @type {string}
     * @memberof PropertyFieldValueSpec
     */
    'strVal'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyFieldValueSpec
     */
    'boolVal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PropertyFieldValueSpec
     */
    'dateVal'?: string;
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValueSpec
     */
    'doubleVal'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValueSpec
     */
    'intVal'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValueSpec
     */
    'bigIntVal'?: number;
}
/**
 * 
 * @export
 * @interface PropertyFieldValueType
 */
export interface PropertyFieldValueType {
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValueType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyFieldValueType
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PropertyFilter
 */
export interface PropertyFilter {
    /**
     * 
     * @type {HcFilter}
     * @memberof PropertyFilter
     */
    'filter'?: HcFilter;
    /**
     * 
     * @type {PropertyField}
     * @memberof PropertyFilter
     */
    'propertyField'?: PropertyField;
}
/**
 * 
 * @export
 * @interface PropertyFilterCriteria
 */
export interface PropertyFilterCriteria {
    /**
     * 
     * @type {Array<PropertyFilterSubmission>}
     * @memberof PropertyFilterCriteria
     */
    'filterList'?: Array<PropertyFilterSubmission>;
    /**
     * 
     * @type {ResultRequest}
     * @memberof PropertyFilterCriteria
     */
    'resultRequest'?: ResultRequest;
}
/**
 * 
 * @export
 * @interface PropertyFilterEntry
 */
export interface PropertyFilterEntry {
    /**
     * 
     * @type {HcFilterEntry}
     * @memberof PropertyFilterEntry
     */
    'filter': HcFilterEntry;
    /**
     * 
     * @type {PropertyField}
     * @memberof PropertyFilterEntry
     */
    'propertyField'?: PropertyField;
}
/**
 * 
 * @export
 * @interface PropertyFilterResult
 */
export interface PropertyFilterResult {
    /**
     * 
     * @type {number}
     * @memberof PropertyFilterResult
     */
    'count'?: number;
    /**
     * 
     * @type {Array<Property>}
     * @memberof PropertyFilterResult
     */
    'propertyList'?: Array<Property>;
}
/**
 * 
 * @export
 * @interface PropertyFilterSubmission
 */
export interface PropertyFilterSubmission {
    /**
     * 
     * @type {boolean}
     * @memberof PropertyFilterSubmission
     */
    'apply'?: boolean;
    /**
     * 
     * @type {PropertyFilterEntry}
     * @memberof PropertyFilterSubmission
     */
    'propertyFilter': PropertyFilterEntry;
    /**
     * 
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'minValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'maxValue'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'minDateValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'maxDateValue'?: string;
    /**
     * 
     * @type {CurrencyAmmount}
     * @memberof PropertyFilterSubmission
     */
    'minCrcyValue'?: CurrencyAmmount;
    /**
     * 
     * @type {CurrencyAmmount}
     * @memberof PropertyFilterSubmission
     */
    'maxCrcyValue'?: CurrencyAmmount;
    /**
     * 
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'minLocalDateTimeValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'maxLocalDateTimeValue'?: string;
    /**
     * 
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'latitudeValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'longitudeValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'radiusValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'xmlId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'freeText'?: string;
    /**
     * 
     * @type {Array<DropdownOption>}
     * @memberof PropertyFilterSubmission
     */
    'selectedFilterOptions'?: Array<DropdownOption>;
}
/**
 * 
 * @export
 * @interface PropertyKey
 */
export interface PropertyKey {
    /**
     * 
     * @type {PropertyType}
     * @memberof PropertyKey
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {PropertyLocation}
     * @memberof PropertyKey
     */
    'propertyLocation': PropertyLocation;
    /**
     * 
     * @type {PropertyProposal}
     * @memberof PropertyKey
     */
    'propertyProposal': PropertyProposal;
    /**
     * 
     * @type {Country}
     * @memberof PropertyKey
     */
    'country': Country;
    /**
     * 
     * @type {string}
     * @memberof PropertyKey
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PropertyLocation
 */
export interface PropertyLocation {
    /**
     * 
     * @type {number}
     * @memberof PropertyLocation
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PropertyLocation
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyLocation
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface PropertyProposal
 */
export interface PropertyProposal {
    /**
     * 
     * @type {number}
     * @memberof PropertyProposal
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyProposal
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyProposal
     */
    'lang'?: string;
}
/**
 * Property type information
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
    /**
     * Unique identifier for the property type
     * @type {number}
     * @memberof PropertyType
     */
    'id': number;
    /**
     * Name of the property type
     * @type {string}
     * @memberof PropertyType
     */
    'name'?: string;
    /**
     * Language key for internationalization
     * @type {string}
     * @memberof PropertyType
     */
    'lang'?: string;
    /**
     * Whether the property type is active
     * @type {boolean}
     * @memberof PropertyType
     */
    'active'?: boolean;
    /**
     * 
     * @type {PropertyTypeGroup}
     * @memberof PropertyType
     */
    'group'?: PropertyTypeGroup;
}
/**
 * Group for categorizing property types
 * @export
 * @interface PropertyTypeGroup
 */
export interface PropertyTypeGroup {
    /**
     * Unique identifier for the property type group
     * @type {number}
     * @memberof PropertyTypeGroup
     */
    'id'?: number;
    /**
     * Name of the property type group
     * @type {string}
     * @memberof PropertyTypeGroup
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface ResultRequest
 */
export interface ResultRequest {
    /**
     * 
     * @type {number}
     * @memberof ResultRequest
     */
    'pageFrom'?: number;
    /**
     * 
     * @type {number}
     * @memberof ResultRequest
     */
    'pageTo'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ResultRequest
     */
    'orderByMostRecent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResultRequest
     */
    'orderByLessRecent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResultRequest
     */
    'asc'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResultRequest
     */
    'loadCount'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResultRequest
     */
    'orderBy'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SecurityToken
 */
export interface SecurityToken {
    /**
     * 
     * @type {string}
     * @memberof SecurityToken
     */
    'tokenValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityToken
     */
    'registered'?: string;
    /**
     * 
     * @type {number}
     * @memberof SecurityToken
     */
    'expiresIn'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SecurityToken
     */
    'expired'?: boolean;
}
/**
 * 
 * @export
 * @interface Skill
 */
export interface Skill {
    /**
     * 
     * @type {number}
     * @memberof Skill
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'locale'?: string;
}
/**
 * 
 * @export
 * @interface SkillEndorsement
 */
export interface SkillEndorsement {
    /**
     * 
     * @type {number}
     * @memberof SkillEndorsement
     */
    'id'?: number;
    /**
     * 
     * @type {SkilledUser}
     * @memberof SkillEndorsement
     */
    'user': SkilledUser;
    /**
     * 
     * @type {SkilledUser}
     * @memberof SkillEndorsement
     */
    'endorser': SkilledUser;
    /**
     * 
     * @type {Skill}
     * @memberof SkillEndorsement
     */
    'skill': Skill;
    /**
     * 
     * @type {string}
     * @memberof SkillEndorsement
     */
    'dateTime'?: string;
}
/**
 * 
 * @export
 * @interface SkilledUser
 */
export interface SkilledUser {
    /**
     * 
     * @type {Language}
     * @memberof SkilledUser
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'confirmedFlag'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'registerDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'webSite'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'linkedIn'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'skype'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'base64Image'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imageLink'?: string;
    /**
     * 
     * @type {Language}
     * @memberof SkilledUser
     */
    'mainSpokenLanguage'?: Language;
    /**
     * 
     * @type {CountryTelephonePrefix}
     * @memberof SkilledUser
     */
    'telephonePrefix'?: CountryTelephonePrefix;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'telephoneNumber'?: string;
    /**
     * 
     * @type {Array<UserType>}
     * @memberof SkilledUser
     */
    'userTypes'?: Array<UserType>;
    /**
     * 
     * @type {Array<UserLanguage>}
     * @memberof SkilledUser
     */
    'userLanguages'?: Array<UserLanguage>;
    /**
     * 
     * @type {Array<UserDescription>}
     * @memberof SkilledUser
     */
    'userDescriptions'?: Array<UserDescription>;
    /**
     * 
     * @type {Country}
     * @memberof SkilledUser
     */
    'country'?: Country;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'backgroundImageBase64'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'backgroundImageLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'profileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'lastActivity'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'chatStatus'?: string;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'chatsCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'phoneVerified'?: boolean;
    /**
     * 
     * @type {GeoPlace}
     * @memberof SkilledUser
     */
    'geoPlace'?: GeoPlace;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'chamberOfCommerceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'facebookUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'instagramUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'twitterUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'wechatUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'vkUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'videoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'bookAnAppointmentUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'googlePlaceId'?: string;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'achievementsYearsOfExperience'?: number;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'achievementsDealsClosed'?: number;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'achievementsPercentageOfAllAgents'?: number;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'achievementsGooglePlaceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'focusOnCommercial'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'focusOnResidential'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'focusOnRental'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'focusOnSelling'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imprintTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imprintDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imprintBase64Image'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imprintLogoLink'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'showEmailInProfile'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'showEmailInProperty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'showPhoneInProperty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'isAllowSaveContact'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'referral'?: string;
    /**
     * 
     * @type {Array<UserSkill>}
     * @memberof SkilledUser
     */
    'skills'?: Array<UserSkill>;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'subscriptionPlanName'?: string;
    /**
     * 
     * @type {Brokerage}
     * @memberof SkilledUser
     */
    'brokerage'?: Brokerage;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imprintImageLink'?: string;
}
/**
 * 
 * @export
 * @interface StripeEvent
 */
export interface StripeEvent {
    /**
     * 
     * @type {string}
     * @memberof StripeEvent
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripeEvent
     */
    'type'?: string;
    /**
     * 
     * @type {StripeEventData}
     * @memberof StripeEvent
     */
    'data'?: StripeEventData;
}
/**
 * 
 * @export
 * @interface StripeEventData
 */
export interface StripeEventData {
    /**
     * 
     * @type {NotificationBody}
     * @memberof StripeEventData
     */
    'object'?: NotificationBody;
    /**
     * 
     * @type {JsonObject}
     * @memberof StripeEventData
     */
    'previous_attributes'?: JsonObject;
}
/**
 * 
 * @export
 * @interface SubscribedUser
 */
export interface SubscribedUser {
    /**
     * 
     * @type {number}
     * @memberof SubscribedUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUser
     */
    'paymentAppId'?: string;
    /**
     * 
     * @type {Address}
     * @memberof SubscribedUser
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUser
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface SubscribedUserDto
 */
export interface SubscribedUserDto {
    /**
     * 
     * @type {number}
     * @memberof SubscribedUserDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUserDto
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionPlanDto
 */
export interface SubscriptionPlanDto {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionPlanDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPlanDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPlanDto
     */
    'lang'?: string;
    /**
     * 
     * @type {Array<SubscriptionPlanFeatureDto>}
     * @memberof SubscriptionPlanDto
     */
    'features'?: Array<SubscriptionPlanFeatureDto>;
    /**
     * 
     * @type {Array<SubscriptionPriceDto>}
     * @memberof SubscriptionPlanDto
     */
    'prices'?: Array<SubscriptionPriceDto>;
}
/**
 * 
 * @export
 * @interface SubscriptionPlanFeatureDto
 */
export interface SubscriptionPlanFeatureDto {
    /**
     * 
     * @type {FeatureDto}
     * @memberof SubscriptionPlanFeatureDto
     */
    'feature'?: FeatureDto;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SubscriptionPlanFeatureDto
     */
    'metadata'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface SubscriptionPriceDto
 */
export interface SubscriptionPriceDto {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPriceDto
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionPriceDto
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPriceDto
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPriceDto
     */
    'renewalType'?: SubscriptionPriceDtoRenewalTypeEnum;
}

export const SubscriptionPriceDtoRenewalTypeEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Every3Months: 'EVERY_3_MONTHS',
    Every6Months: 'EVERY_6_MONTHS',
    Yearly: 'YEARLY'
} as const;

export type SubscriptionPriceDtoRenewalTypeEnum = typeof SubscriptionPriceDtoRenewalTypeEnum[keyof typeof SubscriptionPriceDtoRenewalTypeEnum];

/**
 * 
 * @export
 * @interface Testimonial
 */
export interface Testimonial {
    /**
     * 
     * @type {number}
     * @memberof Testimonial
     */
    'id'?: number;
    /**
     * 
     * @type {Property}
     * @memberof Testimonial
     */
    'property'?: Property;
    /**
     * 
     * @type {string}
     * @memberof Testimonial
     */
    'publishDate'?: string;
    /**
     * 
     * @type {User}
     * @memberof Testimonial
     */
    'publisher'?: User;
    /**
     * 
     * @type {User}
     * @memberof Testimonial
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Testimonial
     */
    'testimonial'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Testimonial
     */
    'published'?: boolean;
}
/**
 * 
 * @export
 * @interface TestimonialFilterResult
 */
export interface TestimonialFilterResult {
    /**
     * 
     * @type {number}
     * @memberof TestimonialFilterResult
     */
    'count'?: number;
    /**
     * 
     * @type {Array<Testimonial>}
     * @memberof TestimonialFilterResult
     */
    'testimonialList'?: Array<Testimonial>;
}
/**
 * 
 * @export
 * @interface TestimonialRequest
 */
export interface TestimonialRequest {
    /**
     * 
     * @type {number}
     * @memberof TestimonialRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TestimonialRequest
     */
    'creationDate'?: string;
    /**
     * 
     * @type {User}
     * @memberof TestimonialRequest
     */
    'requester'?: User;
    /**
     * 
     * @type {User}
     * @memberof TestimonialRequest
     */
    'user'?: User;
    /**
     * 
     * @type {boolean}
     * @memberof TestimonialRequest
     */
    'requestCompleted'?: boolean;
}
/**
 * 
 * @export
 * @interface TextTranslation
 */
export interface TextTranslation {
    /**
     * 
     * @type {string}
     * @memberof TextTranslation
     */
    'translatedText'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextTranslation
     */
    'translatedLanguage'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextTranslation
     */
    'originalText'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {Language}
     * @memberof User
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'confirmedFlag'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'registerDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'webSite'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'linkedIn'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'skype'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'base64Image'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imageLink'?: string;
    /**
     * 
     * @type {Language}
     * @memberof User
     */
    'mainSpokenLanguage'?: Language;
    /**
     * 
     * @type {CountryTelephonePrefix}
     * @memberof User
     */
    'telephonePrefix'?: CountryTelephonePrefix;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'telephoneNumber'?: string;
    /**
     * 
     * @type {Array<UserType>}
     * @memberof User
     */
    'userTypes'?: Array<UserType>;
    /**
     * 
     * @type {Array<UserLanguage>}
     * @memberof User
     */
    'userLanguages'?: Array<UserLanguage>;
    /**
     * 
     * @type {Array<UserDescription>}
     * @memberof User
     */
    'userDescriptions'?: Array<UserDescription>;
    /**
     * 
     * @type {Country}
     * @memberof User
     */
    'country'?: Country;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'backgroundImageBase64'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'backgroundImageLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastActivity'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'chatStatus'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'chatsCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'phoneVerified'?: boolean;
    /**
     * 
     * @type {GeoPlace}
     * @memberof User
     */
    'geoPlace'?: GeoPlace;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'chamberOfCommerceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'facebookUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'instagramUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'twitterUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'wechatUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'vkUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'videoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bookAnAppointmentUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'googlePlaceId'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'achievementsYearsOfExperience'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'achievementsDealsClosed'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'achievementsPercentageOfAllAgents'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'achievementsGooglePlaceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'focusOnCommercial'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'focusOnResidential'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'focusOnRental'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'focusOnSelling'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imprintTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imprintDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imprintBase64Image'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imprintLogoLink'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'showEmailInProfile'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'showEmailInProperty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'showPhoneInProperty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isAllowSaveContact'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'referral'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imprintImageLink'?: string;
}
/**
 * 
 * @export
 * @interface UserChatsSummary
 */
export interface UserChatsSummary {
    /**
     * 
     * @type {User}
     * @memberof UserChatsSummary
     */
    'user'?: User;
    /**
     * 
     * @type {Array<ConversationSummary>}
     * @memberof UserChatsSummary
     */
    'conversationSummaries'?: Array<ConversationSummary>;
}
/**
 * 
 * @export
 * @interface UserDescription
 */
export interface UserDescription {
    /**
     * 
     * @type {Language}
     * @memberof UserDescription
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof UserDescription
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDto
     */
    'confirmedFlag'?: boolean;
    /**
     * 
     * @type {Array<JsonObject>}
     * @memberof UserDto
     */
    'subscriptions'?: Array<JsonObject>;
    /**
     * 
     * @type {Array<UserPermission>}
     * @memberof UserDto
     */
    'userPermissions'?: Array<UserPermission>;
}
/**
 * 
 * @export
 * @interface UserFilterRequest
 */
export interface UserFilterRequest {
    /**
     * 
     * @type {UserFilterResultSpec}
     * @memberof UserFilterRequest
     */
    'resultRequest'?: UserFilterResultSpec;
    /**
     * 
     * @type {string}
     * @memberof UserFilterRequest
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Country>}
     * @memberof UserFilterRequest
     */
    'countries'?: Array<Country>;
    /**
     * 
     * @type {number}
     * @memberof UserFilterRequest
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserFilterRequest
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserFilterRequest
     */
    'radius'?: number;
    /**
     * 
     * @type {Array<UserType>}
     * @memberof UserFilterRequest
     */
    'userTypes'?: Array<UserType>;
    /**
     * 
     * @type {Array<Language>}
     * @memberof UserFilterRequest
     */
    'languages'?: Array<Language>;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterWhatsApp'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterTelephoneNumber'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterGooglePlaceId'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterFocusOnCommercial'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterFocusOnResidential'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterFocusOnRental'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterFocusOnSelling'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterSocial'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof UserFilterRequest
     */
    'brokerages'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UserFilterResult
 */
export interface UserFilterResult {
    /**
     * 
     * @type {number}
     * @memberof UserFilterResult
     */
    'count'?: number;
    /**
     * 
     * @type {Array<SkilledUser>}
     * @memberof UserFilterResult
     */
    'userList'?: Array<SkilledUser>;
}
/**
 * 
 * @export
 * @interface UserFilterResultSpec
 */
export interface UserFilterResultSpec {
    /**
     * 
     * @type {number}
     * @memberof UserFilterResultSpec
     */
    'pageFrom'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserFilterResultSpec
     */
    'pageTo'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'orderByMostRecent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'orderByLessRecent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'asc'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'loadCount'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserFilterResultSpec
     */
    'orderBy'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'orderByMostRecentLogin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'orderByLessRecentLogin'?: boolean;
}
/**
 * 
 * @export
 * @interface UserLanguage
 */
export interface UserLanguage {
    /**
     * 
     * @type {Language}
     * @memberof UserLanguage
     */
    'language'?: Language;
    /**
     * 
     * @type {boolean}
     * @memberof UserLanguage
     */
    'isMainLanguage'?: boolean;
}
/**
 * 
 * @export
 * @interface UserListRequest
 */
export interface UserListRequest {
    /**
     * 
     * @type {number}
     * @memberof UserListRequest
     */
    'userNumber'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof UserListRequest
     */
    'excludeIdList'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UserPermission
 */
export interface UserPermission {
    /**
     * 
     * @type {string}
     * @memberof UserPermission
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof UserPermission
     */
    'metadata'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface UserSkill
 */
export interface UserSkill {
    /**
     * 
     * @type {Skill}
     * @memberof UserSkill
     */
    'skill': Skill;
    /**
     * 
     * @type {number}
     * @memberof UserSkill
     */
    'endorsementsCount'?: number;
}
/**
 * 
 * @export
 * @interface UserSubscriptionDto
 */
export interface UserSubscriptionDto {
    /**
     * 
     * @type {SubscriptionPlanDto}
     * @memberof UserSubscriptionDto
     */
    'subscriptionPlan'?: SubscriptionPlanDto;
    /**
     * 
     * @type {string}
     * @memberof UserSubscriptionDto
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscriptionDto
     */
    'endDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscriptionDto
     */
    'renewalType'?: UserSubscriptionDtoRenewalTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserSubscriptionDto
     */
    'status'?: UserSubscriptionDtoStatusEnum;
}

export const UserSubscriptionDtoRenewalTypeEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Every3Months: 'EVERY_3_MONTHS',
    Every6Months: 'EVERY_6_MONTHS',
    Yearly: 'YEARLY'
} as const;

export type UserSubscriptionDtoRenewalTypeEnum = typeof UserSubscriptionDtoRenewalTypeEnum[keyof typeof UserSubscriptionDtoRenewalTypeEnum];
export const UserSubscriptionDtoStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type UserSubscriptionDtoStatusEnum = typeof UserSubscriptionDtoStatusEnum[keyof typeof UserSubscriptionDtoStatusEnum];

/**
 * 
 * @export
 * @interface UserType
 */
export interface UserType {
    /**
     * 
     * @type {number}
     * @memberof UserType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserType
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserType
     */
    'lang'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserType
     */
    'tooltipLang'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserType
     */
    'manageTooltip'?: boolean;
}
/**
 * 
 * @export
 * @interface WeeklyAlertRange
 */
export interface WeeklyAlertRange {
    /**
     * 
     * @type {string}
     * @memberof WeeklyAlertRange
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof WeeklyAlertRange
     */
    'to'?: string;
}
/**
 * 
 * @export
 * @interface XmlUrl
 */
export interface XmlUrl {
    /**
     * 
     * @type {string}
     * @memberof XmlUrl
     */
    'url': string;
}

/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert: async (userId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteAlert', 'userId', userId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('deleteAlert', 'alertId', alertId)
            const localVarPath = `/users/{userId}/alerts/{alertId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to retrieve results for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertResult: async (userId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAlertResult', 'userId', userId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('getAlertResult', 'alertId', alertId)
            const localVarPath = `/users/{userId}/alerts/{alertId}/result`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {number} userId ID of the user to retrieve alerts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getByUser', 'userId', userId)
            const localVarPath = `/users/{userId}/alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {number} userId ID of the user who subscribed to newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterAlerts: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('newsletterAlerts', 'userId', userId)
            const localVarPath = `/users/{userId}/alerts/newsletter-alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {number} userId ID of the user who owns the newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterSubscribers: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('newsletterSubscribers', 'userId', userId)
            const localVarPath = `/users/{userId}/alerts/newsletter-subscribers`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {number} userId ID of the user to create the alert for
         * @param {Alert} alert Alert to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlert: async (userId: number, alert: Alert, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('saveAlert', 'userId', userId)
            // verify required parameter 'alert' is not null or undefined
            assertParamExists('saveAlert', 'alert', alert)
            const localVarPath = `/users/{userId}/alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/{userId}/alerts/send-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert(userId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert(userId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.deleteAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to retrieve results for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertResult(userId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertResult(userId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.getAlertResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {number} userId ID of the user to retrieve alerts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUser(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Alert>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.getByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {number} userId ID of the user who subscribed to newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsletterAlerts(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NewsletterSubscriberDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsletterAlerts(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.newsletterAlerts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {number} userId ID of the user who owns the newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsletterSubscribers(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NewsletterSubscriberDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsletterSubscribers(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.newsletterSubscribers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {number} userId ID of the user to create the alert for
         * @param {Alert} alert Alert to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAlert(userId: number, alert: Alert, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveAlert(userId, alert, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.saveAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendAlert1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendAlert1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.sendAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(userId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteAlert(userId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to retrieve results for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertResult(userId: number, alertId: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAlertResult(userId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {number} userId ID of the user to retrieve alerts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Alert>> {
            return localVarFp.getByUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {number} userId ID of the user who subscribed to newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterAlerts(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<NewsletterSubscriberDto>> {
            return localVarFp.newsletterAlerts(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {number} userId ID of the user who owns the newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterSubscribers(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<NewsletterSubscriberDto>> {
            return localVarFp.newsletterSubscribers(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {number} userId ID of the user to create the alert for
         * @param {Alert} alert Alert to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlert(userId: number, alert: Alert, options?: RawAxiosRequestConfig): AxiosPromise<Alert> {
            return localVarFp.saveAlert(userId, alert, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert1(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.sendAlert1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * Deletes a specific alert owned by the user
     * @summary Delete an alert
     * @param {number} userId ID of the user who owns the alert
     * @param {number} alertId ID of the alert to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public deleteAlert(userId: number, alertId: number, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).deleteAlert(userId, alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the results for a specific alert
     * @summary Get alert results
     * @param {number} userId ID of the user who owns the alert
     * @param {number} alertId ID of the alert to retrieve results for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getAlertResult(userId: number, alertId: number, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).getAlertResult(userId, alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all alerts associated with the specified user ID
     * @summary Get all alerts for a user
     * @param {number} userId ID of the user to retrieve alerts for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getByUser(userId: number, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).getByUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all newsletters that the specified user has subscribed to
     * @summary Get newsletters subscribed to
     * @param {number} userId ID of the user who subscribed to newsletters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public newsletterAlerts(userId: number, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).newsletterAlerts(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all subscribers to newsletters owned by the specified user
     * @summary Get newsletter subscribers
     * @param {number} userId ID of the user who owns the newsletters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public newsletterSubscribers(userId: number, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).newsletterSubscribers(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new alert for the specified user
     * @summary Create a new alert
     * @param {number} userId ID of the user to create the alert for
     * @param {Alert} alert Alert to be created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public saveAlert(userId: number, alert: Alert, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).saveAlert(userId, alert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers the sending of customized property alerts to users
     * @summary Send customized property alerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public sendAlert1(options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).sendAlert1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AllowancesApi - axios parameter creator
 * @export
 */
export const AllowancesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
         * @summary Get chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatAllowance: async (userPair: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPair' is not null or undefined
            assertParamExists('getChatAllowance', 'userPair', userPair)
            const localVarPath = `/chat/allowance/{userPair}`
                .replace(`{${"userPair"}}`, encodeURIComponent(String(userPair)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the chat allowance settings between two users
         * @summary Update chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {ChatAllowance} chatAllowance Chat allowance information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatAllowance: async (userPair: string, chatAllowance: ChatAllowance, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userPair' is not null or undefined
            assertParamExists('updateChatAllowance', 'userPair', userPair)
            // verify required parameter 'chatAllowance' is not null or undefined
            assertParamExists('updateChatAllowance', 'chatAllowance', chatAllowance)
            const localVarPath = `/chat/allowance/{userPair}`
                .replace(`{${"userPair"}}`, encodeURIComponent(String(userPair)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatAllowance, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllowancesApi - functional programming interface
 * @export
 */
export const AllowancesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllowancesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
         * @summary Get chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatAllowance(userPair: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatAllowance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatAllowance(userPair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllowancesApi.getChatAllowance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the chat allowance settings between two users
         * @summary Update chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {ChatAllowance} chatAllowance Chat allowance information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChatAllowance(userPair: string, chatAllowance: ChatAllowance, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatAllowance>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChatAllowance(userPair, chatAllowance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllowancesApi.updateChatAllowance']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AllowancesApi - factory interface
 * @export
 */
export const AllowancesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllowancesApiFp(configuration)
    return {
        /**
         * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
         * @summary Get chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatAllowance(userPair: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatAllowance> {
            return localVarFp.getChatAllowance(userPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the chat allowance settings between two users
         * @summary Update chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {ChatAllowance} chatAllowance Chat allowance information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatAllowance(userPair: string, chatAllowance: ChatAllowance, options?: RawAxiosRequestConfig): AxiosPromise<ChatAllowance> {
            return localVarFp.updateChatAllowance(userPair, chatAllowance, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllowancesApi - object-oriented interface
 * @export
 * @class AllowancesApi
 * @extends {BaseAPI}
 */
export class AllowancesApi extends BaseAPI {
    /**
     * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
     * @summary Get chat allowance for a user pair
     * @param {string} userPair User pair in the form userFrom-userTo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    public getChatAllowance(userPair: string, options?: RawAxiosRequestConfig) {
        return AllowancesApiFp(this.configuration).getChatAllowance(userPair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the chat allowance settings between two users
     * @summary Update chat allowance for a user pair
     * @param {string} userPair User pair in the form userFrom-userTo
     * @param {ChatAllowance} chatAllowance Chat allowance information to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    public updateChatAllowance(userPair: string, chatAllowance: ChatAllowance, options?: RawAxiosRequestConfig) {
        return AllowancesApiFp(this.configuration).updateChatAllowance(userPair, chatAllowance, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AttachmentsApi - axios parameter creator
 * @export
 */
export const AttachmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Post a attachment request
         * @param {Attachment} [attachment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment: async (attachment?: Attachment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(attachment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get details to download a file
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAttachment: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('retrieveAttachment', 'fileId', fileId)
            const localVarPath = `/chat/attachments/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Notify a new file has been loaded in S3
         * @param {string} fileId 
         * @param {NotifyUploadRequest} [notifyUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment: async (fileId: string, notifyUploadRequest?: NotifyUploadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('updateAttachment', 'fileId', fileId)
            const localVarPath = `/chat/attachments/{fileId}/notify-upload`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notifyUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export const AttachmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AttachmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Post a attachment request
         * @param {Attachment} [attachment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttachment(attachment?: Attachment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttachment(attachment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentsApi.createAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get details to download a file
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAttachment(fileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAttachment(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentsApi.retrieveAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Notify a new file has been loaded in S3
         * @param {string} fileId 
         * @param {NotifyUploadRequest} [notifyUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAttachment(fileId: string, notifyUploadRequest?: NotifyUploadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAttachment(fileId, notifyUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentsApi.updateAttachment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AttachmentsApi - factory interface
 * @export
 */
export const AttachmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AttachmentsApiFp(configuration)
    return {
        /**
         * 
         * @summary Post a attachment request
         * @param {Attachment} [attachment] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment(attachment?: Attachment, options?: RawAxiosRequestConfig): AxiosPromise<Attachment> {
            return localVarFp.createAttachment(attachment, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get details to download a file
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAttachment(fileId: string, options?: RawAxiosRequestConfig): AxiosPromise<Attachment> {
            return localVarFp.retrieveAttachment(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Notify a new file has been loaded in S3
         * @param {string} fileId 
         * @param {NotifyUploadRequest} [notifyUploadRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment(fileId: string, notifyUploadRequest?: NotifyUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateAttachment(fileId, notifyUploadRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export class AttachmentsApi extends BaseAPI {
    /**
     * 
     * @summary Post a attachment request
     * @param {Attachment} [attachment] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public createAttachment(attachment?: Attachment, options?: RawAxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).createAttachment(attachment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get details to download a file
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public retrieveAttachment(fileId: string, options?: RawAxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).retrieveAttachment(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Notify a new file has been loaded in S3
     * @param {string} fileId 
     * @param {NotifyUploadRequest} [notifyUploadRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    public updateAttachment(fileId: string, notifyUploadRequest?: NotifyUploadRequest, options?: RawAxiosRequestConfig) {
        return AttachmentsApiFp(this.configuration).updateAttachment(fileId, notifyUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BrokeragesApi - axios parameter creator
 * @export
 */
export const BrokeragesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/brokerages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrokeragesApi - functional programming interface
 * @export
 */
export const BrokeragesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrokeragesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Brokerage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrokeragesApi.retrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrokeragesApi - factory interface
 * @export
 */
export const BrokeragesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrokeragesApiFp(configuration)
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve(options?: RawAxiosRequestConfig): AxiosPromise<Array<Brokerage>> {
            return localVarFp.retrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrokeragesApi - object-oriented interface
 * @export
 * @class BrokeragesApi
 * @extends {BaseAPI}
 */
export class BrokeragesApi extends BaseAPI {
    /**
     * Returns a list of all available brokerages in the system
     * @summary Retrieve all brokerages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokeragesApi
     */
    public retrieve(options?: RawAxiosRequestConfig) {
        return BrokeragesApiFp(this.configuration).retrieve(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatTicketsApi - axios parameter creator
 * @export
 */
export const ChatTicketsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates and returns a chat ticket that can be used to establish a chat connection
         * @summary Retrieve a chat ticket for the authenticated user
         * @param {string} userAgent User agent string of the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserTicket: async (userAgent: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAgent' is not null or undefined
            assertParamExists('retrieveUserTicket', 'userAgent', userAgent)
            const localVarPath = `/chat/ticket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (userAgent != null) {
                localVarHeaderParameter['user-agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatTicketsApi - functional programming interface
 * @export
 */
export const ChatTicketsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatTicketsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates and returns a chat ticket that can be used to establish a chat connection
         * @summary Retrieve a chat ticket for the authenticated user
         * @param {string} userAgent User agent string of the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserTicket(userAgent: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatTicket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserTicket(userAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatTicketsApi.retrieveUserTicket']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatTicketsApi - factory interface
 * @export
 */
export const ChatTicketsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatTicketsApiFp(configuration)
    return {
        /**
         * Creates and returns a chat ticket that can be used to establish a chat connection
         * @summary Retrieve a chat ticket for the authenticated user
         * @param {string} userAgent User agent string of the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserTicket(userAgent: string, options?: RawAxiosRequestConfig): AxiosPromise<ChatTicket> {
            return localVarFp.retrieveUserTicket(userAgent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatTicketsApi - object-oriented interface
 * @export
 * @class ChatTicketsApi
 * @extends {BaseAPI}
 */
export class ChatTicketsApi extends BaseAPI {
    /**
     * Creates and returns a chat ticket that can be used to establish a chat connection
     * @summary Retrieve a chat ticket for the authenticated user
     * @param {string} userAgent User agent string of the client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatTicketsApi
     */
    public retrieveUserTicket(userAgent: string, options?: RawAxiosRequestConfig) {
        return ChatTicketsApiFp(this.configuration).retrieveUserTicket(userAgent, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CheckoutSessionsApi - axios parameter creator
 * @export
 */
export const CheckoutSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CheckoutSessionDto} checkoutSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession: async (checkoutSessionDto: CheckoutSessionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutSessionDto' is not null or undefined
            assertParamExists('createCheckoutSession', 'checkoutSessionDto', checkoutSessionDto)
            const localVarPath = `/checkout-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutSessionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutSessionsApi - functional programming interface
 * @export
 */
export const CheckoutSessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckoutSessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CheckoutSessionDto} checkoutSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSession(checkoutSessionDto: CheckoutSessionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSession(checkoutSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckoutSessionsApi.createCheckoutSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CheckoutSessionsApi - factory interface
 * @export
 */
export const CheckoutSessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckoutSessionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CheckoutSessionDto} checkoutSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession(checkoutSessionDto: CheckoutSessionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createCheckoutSession(checkoutSessionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CheckoutSessionsApi - object-oriented interface
 * @export
 * @class CheckoutSessionsApi
 * @extends {BaseAPI}
 */
export class CheckoutSessionsApi extends BaseAPI {
    /**
     * 
     * @summary Create checkout-session
     * @param {CheckoutSessionDto} checkoutSessionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutSessionsApi
     */
    public createCheckoutSession(checkoutSessionDto: CheckoutSessionDto, options?: RawAxiosRequestConfig) {
        return CheckoutSessionsApiFp(this.configuration).createCheckoutSession(checkoutSessionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method to find a country by the caller IP
         * @param {string} [xForwardedFor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByIp: async (xForwardedFor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/countries/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xForwardedFor != null) {
                localVarHeaderParameter['X-Forwarded-For'] = String(xForwardedFor);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCountries(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Country>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCountries(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getAllCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Method to find a country by the caller IP
         * @param {string} [xForwardedFor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByIp(xForwardedFor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByIp(xForwardedFor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryByIp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries(options?: RawAxiosRequestConfig): AxiosPromise<Array<Country>> {
            return localVarFp.getAllCountries(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method to find a country by the caller IP
         * @param {string} [xForwardedFor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByIp(xForwardedFor?: string, options?: RawAxiosRequestConfig): AxiosPromise<Country> {
            return localVarFp.getCountryByIp(xForwardedFor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * 
     * @summary Method to find all the countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getAllCountries(options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getAllCountries(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method to find a country by the caller IP
     * @param {string} [xForwardedFor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountryByIp(xForwardedFor?: string, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getCountryByIp(xForwardedFor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CurrencyManagementApi - axios parameter creator
 * @export
 */
export const CurrencyManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyManagementApi - functional programming interface
 * @export
 */
export const CurrencyManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrencyManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencies(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Currency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencies(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyManagementApi.getCurrencies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CurrencyManagementApi - factory interface
 * @export
 */
export const CurrencyManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrencyManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(options?: RawAxiosRequestConfig): AxiosPromise<Array<Currency>> {
            return localVarFp.getCurrencies(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrencyManagementApi - object-oriented interface
 * @export
 * @class CurrencyManagementApi
 * @extends {BaseAPI}
 */
export class CurrencyManagementApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves the list of all exchange available in application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyManagementApi
     */
    public getCurrencies(options?: RawAxiosRequestConfig) {
        return CurrencyManagementApiFp(this.configuration).getCurrencies(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomerSessionsApi - axios parameter creator
 * @export
 */
export const CustomerSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CustomerSessionDto} customerSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession1: async (customerSessionDto: CustomerSessionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerSessionDto' is not null or undefined
            assertParamExists('createCheckoutSession1', 'customerSessionDto', customerSessionDto)
            const localVarPath = `/customer-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerSessionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerSessionsApi - functional programming interface
 * @export
 */
export const CustomerSessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerSessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CustomerSessionDto} customerSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSession1(customerSessionDto: CustomerSessionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSession1(customerSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerSessionsApi.createCheckoutSession1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomerSessionsApi - factory interface
 * @export
 */
export const CustomerSessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerSessionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CustomerSessionDto} customerSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession1(customerSessionDto: CustomerSessionDto, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createCheckoutSession1(customerSessionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerSessionsApi - object-oriented interface
 * @export
 * @class CustomerSessionsApi
 * @extends {BaseAPI}
 */
export class CustomerSessionsApi extends BaseAPI {
    /**
     * 
     * @summary Create checkout-session
     * @param {CustomerSessionDto} customerSessionDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerSessionsApi
     */
    public createCheckoutSession1(customerSessionDto: CustomerSessionDto, options?: RawAxiosRequestConfig) {
        return CustomerSessionsApiFp(this.configuration).createCheckoutSession1(customerSessionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EndorsementsApi - axios parameter creator
 * @export
 */
export const EndorsementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {number} userId ID of the user to get endorsements for
         * @param {number} [endorser] Optional endorser ID to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEndorsementsByUser: async (userId: number, endorser?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveEndorsementsByUser', 'userId', userId)
            const localVarPath = `/users/{userId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (endorser !== undefined) {
                localVarQueryParameter['endorser'] = endorser;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndorsementsApi - functional programming interface
 * @export
 */
export const EndorsementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EndorsementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {number} userId ID of the user to get endorsements for
         * @param {number} [endorser] Optional endorser ID to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveEndorsementsByUser(userId: number, endorser?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkillEndorsement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveEndorsementsByUser(userId, endorser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndorsementsApi.retrieveEndorsementsByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EndorsementsApi - factory interface
 * @export
 */
export const EndorsementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EndorsementsApiFp(configuration)
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {number} userId ID of the user to get endorsements for
         * @param {number} [endorser] Optional endorser ID to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEndorsementsByUser(userId: number, endorser?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SkillEndorsement>> {
            return localVarFp.retrieveEndorsementsByUser(userId, endorser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndorsementsApi - object-oriented interface
 * @export
 * @class EndorsementsApi
 * @extends {BaseAPI}
 */
export class EndorsementsApi extends BaseAPI {
    /**
     * Gets all endorsements for a specified user. Can be filtered by endorser ID.
     * @summary Retrieve endorsements for a user
     * @param {number} userId ID of the user to get endorsements for
     * @param {number} [endorser] Optional endorser ID to filter results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndorsementsApi
     */
    public retrieveEndorsementsByUser(userId: number, endorser?: number, options?: RawAxiosRequestConfig) {
        return EndorsementsApiFp(this.configuration).retrieveEndorsementsByUser(userId, endorser, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExchangeRatesApi - axios parameter creator
 * @export
 */
export const ExchangeRatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExchangeRates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exchange-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangeRatesApi - functional programming interface
 * @export
 */
export const ExchangeRatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExchangeRatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findExchangeRates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeRateMap>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findExchangeRates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeRatesApi.findExchangeRates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExchangeRatesApi - factory interface
 * @export
 */
export const ExchangeRatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExchangeRatesApiFp(configuration)
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExchangeRates(options?: RawAxiosRequestConfig): AxiosPromise<ExchangeRateMap> {
            return localVarFp.findExchangeRates(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExchangeRatesApi - object-oriented interface
 * @export
 * @class ExchangeRatesApi
 * @extends {BaseAPI}
 */
export class ExchangeRatesApi extends BaseAPI {
    /**
     * Returns a map of currency exchange rates between different currencies
     * @summary Method to find all the exchange rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeRatesApi
     */
    public findExchangeRates(options?: RawAxiosRequestConfig) {
        return ExchangeRatesApiFp(this.configuration).findExchangeRates(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FacebookPropertiesApi - axios parameter creator
 * @export
 */
export const FacebookPropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {string} startDate Start date for property export (ISO format)
         * @param {string} endDate End date for property export (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties1: async (startDate: string, endDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('uploadKyeroProperties1', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('uploadKyeroProperties1', 'endDate', endDate)
            const localVarPath = `/facebook-properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['start-date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end-date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FacebookPropertiesApi - functional programming interface
 * @export
 */
export const FacebookPropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FacebookPropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {string} startDate Start date for property export (ISO format)
         * @param {string} endDate End date for property export (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroProperties1(startDate: string, endDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FBPropertyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroProperties1(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacebookPropertiesApi.uploadKyeroProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FacebookPropertiesApi - factory interface
 * @export
 */
export const FacebookPropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FacebookPropertiesApiFp(configuration)
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {string} startDate Start date for property export (ISO format)
         * @param {string} endDate End date for property export (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties1(startDate: string, endDate: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<FBPropertyDto>> {
            return localVarFp.uploadKyeroProperties1(startDate, endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FacebookPropertiesApi - object-oriented interface
 * @export
 * @class FacebookPropertiesApi
 * @extends {BaseAPI}
 */
export class FacebookPropertiesApi extends BaseAPI {
    /**
     * Exports property data to Facebook Marketplace format within the specified date range
     * @summary Export properties to Facebook Marketplace
     * @param {string} startDate Start date for property export (ISO format)
     * @param {string} endDate End date for property export (ISO format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacebookPropertiesApi
     */
    public uploadKyeroProperties1(startDate: string, endDate: string, options?: RawAxiosRequestConfig) {
        return FacebookPropertiesApiFp(this.configuration).uploadKyeroProperties1(startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FavoritesApi - axios parameter creator
 * @export
 */
export const FavoritesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {number} userId ID of the user
         * @param {boolean} [includeResource] Whether to include the associated resource details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser1: async (userId: number, includeResource?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getByUser1', 'userId', userId)
            const localVarPath = `/users/{userId}/favorites`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (includeResource !== undefined) {
                localVarQueryParameter['includeResource'] = includeResource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {number} userId ID of the user
         * @param {Favorite} favorite Favorite to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserFavorite: async (userId: number, favorite: Favorite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('postUserFavorite', 'userId', userId)
            // verify required parameter 'favorite' is not null or undefined
            assertParamExists('postUserFavorite', 'favorite', favorite)
            const localVarPath = `/users/{userId}/favorites`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(favorite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {number} userId ID of the user
         * @param {number} favoriteId ID of the favorite to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFavorite: async (userId: number, favoriteId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFavorite', 'userId', userId)
            // verify required parameter 'favoriteId' is not null or undefined
            assertParamExists('removeUserFavorite', 'favoriteId', favoriteId)
            const localVarPath = `/users/{userId}/favorites/{favoriteId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"favoriteId"}}`, encodeURIComponent(String(favoriteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FavoritesApi - functional programming interface
 * @export
 */
export const FavoritesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FavoritesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {number} userId ID of the user
         * @param {boolean} [includeResource] Whether to include the associated resource details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUser1(userId: number, includeResource?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Favorite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUser1(userId, includeResource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoritesApi.getByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {number} userId ID of the user
         * @param {Favorite} favorite Favorite to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserFavorite(userId: number, favorite: Favorite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Favorite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserFavorite(userId, favorite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoritesApi.postUserFavorite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {number} userId ID of the user
         * @param {number} favoriteId ID of the favorite to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFavorite(userId: number, favoriteId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFavorite(userId, favoriteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoritesApi.removeUserFavorite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FavoritesApi - factory interface
 * @export
 */
export const FavoritesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FavoritesApiFp(configuration)
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {number} userId ID of the user
         * @param {boolean} [includeResource] Whether to include the associated resource details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser1(userId: number, includeResource?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Array<Favorite>> {
            return localVarFp.getByUser1(userId, includeResource, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {number} userId ID of the user
         * @param {Favorite} favorite Favorite to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserFavorite(userId: number, favorite: Favorite, options?: RawAxiosRequestConfig): AxiosPromise<Favorite> {
            return localVarFp.postUserFavorite(userId, favorite, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {number} userId ID of the user
         * @param {number} favoriteId ID of the favorite to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFavorite(userId: number, favoriteId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeUserFavorite(userId, favoriteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
export class FavoritesApi extends BaseAPI {
    /**
     * Retrieves all favorites for a specific user
     * @summary Get user favorites
     * @param {number} userId ID of the user
     * @param {boolean} [includeResource] Whether to include the associated resource details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public getByUser1(userId: number, includeResource?: boolean, options?: RawAxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).getByUser1(userId, includeResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new favorite item for a specific user
     * @summary Add a favorite
     * @param {number} userId ID of the user
     * @param {Favorite} favorite Favorite to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public postUserFavorite(userId: number, favorite: Favorite, options?: RawAxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).postUserFavorite(userId, favorite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a specific favorite from a user\'s favorites list
     * @summary Remove a favorite
     * @param {number} userId ID of the user
     * @param {number} favoriteId ID of the favorite to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public removeUserFavorite(userId: number, favoriteId: number, options?: RawAxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).removeUserFavorite(userId, favoriteId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GeoLocationApi - axios parameter creator
 * @export
 */
export const GeoLocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {string} [latlng] Comma-separated latitude and longitude coordinates
         * @param {string} [address] Text representation of an address to geocode
         * @param {string} [countryCode] ISO country code to restrict the address search
         * @param {string} [autoCompleteText] Text to use for location auto-completion suggestions
         * @param {number} [radius] Search radius in meters for location suggestions (used with latlng and autoCompleteText)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeoLocationsByLatLng: async (latlng?: string, address?: string, countryCode?: string, autoCompleteText?: string, radius?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/geo-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (latlng !== undefined) {
                localVarQueryParameter['latlng'] = latlng;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }

            if (autoCompleteText !== undefined) {
                localVarQueryParameter['autoCompleteText'] = autoCompleteText;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeoLocationApi - functional programming interface
 * @export
 */
export const GeoLocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeoLocationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {string} [latlng] Comma-separated latitude and longitude coordinates
         * @param {string} [address] Text representation of an address to geocode
         * @param {string} [countryCode] ISO country code to restrict the address search
         * @param {string} [autoCompleteText] Text to use for location auto-completion suggestions
         * @param {number} [radius] Search radius in meters for location suggestions (used with latlng and autoCompleteText)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeoLocationsByLatLng(latlng?: string, address?: string, countryCode?: string, autoCompleteText?: string, radius?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoPlace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeoLocationsByLatLng(latlng, address, countryCode, autoCompleteText, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoLocationApi.getGeoLocationsByLatLng']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeoLocationApi - factory interface
 * @export
 */
export const GeoLocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeoLocationApiFp(configuration)
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {string} [latlng] Comma-separated latitude and longitude coordinates
         * @param {string} [address] Text representation of an address to geocode
         * @param {string} [countryCode] ISO country code to restrict the address search
         * @param {string} [autoCompleteText] Text to use for location auto-completion suggestions
         * @param {number} [radius] Search radius in meters for location suggestions (used with latlng and autoCompleteText)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeoLocationsByLatLng(latlng?: string, address?: string, countryCode?: string, autoCompleteText?: string, radius?: number, options?: RawAxiosRequestConfig): AxiosPromise<GeoPlace> {
            return localVarFp.getGeoLocationsByLatLng(latlng, address, countryCode, autoCompleteText, radius, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeoLocationApi - object-oriented interface
 * @export
 * @class GeoLocationApi
 * @extends {BaseAPI}
 */
export class GeoLocationApi extends BaseAPI {
    /**
     * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
     * @summary Retrieves geolocation information
     * @param {string} [latlng] Comma-separated latitude and longitude coordinates
     * @param {string} [address] Text representation of an address to geocode
     * @param {string} [countryCode] ISO country code to restrict the address search
     * @param {string} [autoCompleteText] Text to use for location auto-completion suggestions
     * @param {number} [radius] Search radius in meters for location suggestions (used with latlng and autoCompleteText)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoLocationApi
     */
    public getGeoLocationsByLatLng(latlng?: string, address?: string, countryCode?: string, autoCompleteText?: string, radius?: number, options?: RawAxiosRequestConfig) {
        return GeoLocationApiFp(this.configuration).getGeoLocationsByLatLng(latlng, address, countryCode, autoCompleteText, radius, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveGroup: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('archiveGroup', 'id', id)
            const localVarPath = `/groups/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateGroup: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateGroup', 'id', id)
            const localVarPath = `/groups/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has archived
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findArchivedGroupsByUser: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/archived`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('findGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupProperties: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('findGroupProperties', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/properties`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {PropertyFilterCriteria} [propertyFilterCriteria] filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupPropertiesSearch: async (groupId: string, propertyFilterCriteria?: PropertyFilterCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('findGroupPropertiesSearch', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/properties/search`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyFilterCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return both owned Groups and Groups the user is a member of
         * @summary Return the groups list with specified user id
         * @param {number} [pageFrom] Start page number
         * @param {number} [pageTo] End page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupsByUser: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the groups list with specified user id that are inactive
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInactiveGroupsByUser: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/inactive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has invitations of
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvitedGroupsByUser: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/invited`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has requested
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRequestedGroupsByUser: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/requested`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {string} groupId group id
         * @param {number} [pageFrom] Starting page index (zero-based)
         * @param {number} [pageTo] Ending page index (zero-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers: async (groupId: string, pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupMembers', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/members`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept Group Invitation
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupInvite', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/accept-invite`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Invitation to Group
         * @param {string} groupId group id
         * @param {Array<number>} [userIds] List of user IDs to invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite1: async (groupId: string, userIds?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupInvite1', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/invite`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupLeave: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupLeave', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/leave`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Admission to Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRequest: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupRequest', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/request`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {Group} [group] group to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroup: async (group?: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to update status
         * @param {UpdateGroupMembershipStatusStatusEnum} [status] New status for the members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMembershipStatus: async (groupId: string, userIds?: Array<number>, status?: UpdateGroupMembershipStatusStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupMembershipStatus', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/member-status`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveGroup(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveGroup(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.archiveGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateGroup(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateGroup(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deactivateGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has archived
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findArchivedGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findArchivedGroupsByUser(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findArchivedGroupsByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroup(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroup(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupProperties(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupProperties(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroupProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {PropertyFilterCriteria} [propertyFilterCriteria] filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupPropertiesSearch(groupId: string, propertyFilterCriteria?: PropertyFilterCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupPropertiesSearch(groupId, propertyFilterCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroupPropertiesSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will return both owned Groups and Groups the user is a member of
         * @summary Return the groups list with specified user id
         * @param {number} [pageFrom] Start page number
         * @param {number} [pageTo] End page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupsByUser(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroupsByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the groups list with specified user id that are inactive
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInactiveGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInactiveGroupsByUser(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findInactiveGroupsByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has invitations of
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInvitedGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInvitedGroupsByUser(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findInvitedGroupsByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has requested
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findRequestedGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findRequestedGroupsByUser(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findRequestedGroupsByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {string} groupId group id
         * @param {number} [pageFrom] Starting page index (zero-based)
         * @param {number} [pageTo] Ending page index (zero-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupMembers(groupId: string, pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BaseFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupMembers(groupId, pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Accept Group Invitation
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupInvite(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupInvite(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request Invitation to Group
         * @param {string} groupId group id
         * @param {Array<number>} [userIds] List of user IDs to invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupInvite1(groupId: string, userIds?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupInvite1(groupId, userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupInvite1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Leave Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupLeave(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupLeave(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupLeave']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request Admission to Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRequest(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupRequest(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupRequest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {Group} [group] group to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveGroup(group?: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveGroup(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.saveGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to update status
         * @param {UpdateGroupMembershipStatusStatusEnum} [status] New status for the members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupMembershipStatus(groupId: string, userIds?: Array<number>, status?: UpdateGroupMembershipStatusStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupMembershipStatus(groupId, userIds, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.updateGroupMembershipStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveGroup(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.archiveGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateGroup(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deactivateGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has archived
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findArchivedGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseFilterResult> {
            return localVarFp.findArchivedGroupsByUser(pageFrom, pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.findGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupProperties(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.findGroupProperties(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {PropertyFilterCriteria} [propertyFilterCriteria] filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupPropertiesSearch(groupId: string, propertyFilterCriteria?: PropertyFilterCriteria, options?: RawAxiosRequestConfig): AxiosPromise<BaseFilterResult> {
            return localVarFp.findGroupPropertiesSearch(groupId, propertyFilterCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return both owned Groups and Groups the user is a member of
         * @summary Return the groups list with specified user id
         * @param {number} [pageFrom] Start page number
         * @param {number} [pageTo] End page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseFilterResult> {
            return localVarFp.findGroupsByUser(pageFrom, pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the groups list with specified user id that are inactive
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInactiveGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseFilterResult> {
            return localVarFp.findInactiveGroupsByUser(pageFrom, pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has invitations of
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvitedGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseFilterResult> {
            return localVarFp.findInvitedGroupsByUser(pageFrom, pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has requested
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRequestedGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseFilterResult> {
            return localVarFp.findRequestedGroupsByUser(pageFrom, pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {string} groupId group id
         * @param {number} [pageFrom] Starting page index (zero-based)
         * @param {number} [pageTo] Ending page index (zero-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers(groupId: string, pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<BaseFilterResult> {
            return localVarFp.getGroupMembers(groupId, pageFrom, pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept Group Invitation
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupMember> {
            return localVarFp.groupInvite(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Invitation to Group
         * @param {string} groupId group id
         * @param {Array<number>} [userIds] List of user IDs to invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite1(groupId: string, userIds?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupMember>> {
            return localVarFp.groupInvite1(groupId, userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupLeave(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupMember> {
            return localVarFp.groupLeave(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Admission to Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRequest(groupId: string, options?: RawAxiosRequestConfig): AxiosPromise<GroupMember> {
            return localVarFp.groupRequest(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {Group} [group] group to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroup(group?: Group, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.saveGroup(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to update status
         * @param {UpdateGroupMembershipStatusStatusEnum} [status] New status for the members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMembershipStatus(groupId: string, userIds?: Array<number>, status?: UpdateGroupMembershipStatusStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupMember>> {
            return localVarFp.updateGroupMembershipStatus(groupId, userIds, status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * This process is reversible
     * @summary Archive the group with id supplied
     * @param {string} id groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public archiveGroup(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).archiveGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This process is reversible
     * @summary Deactivate the group with id supplied
     * @param {string} id groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deactivateGroup(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deactivateGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This process is not reversible
     * @summary Delete the group with id supplied
     * @param {string} id groupId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup(id: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the groups list with specified user id that user has archived
     * @param {number} [pageFrom] 
     * @param {number} [pageTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findArchivedGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findArchivedGroupsByUser(pageFrom, pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {string} groupId group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findGroup(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {string} groupId group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findGroupProperties(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findGroupProperties(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {string} groupId group id
     * @param {PropertyFilterCriteria} [propertyFilterCriteria] filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findGroupPropertiesSearch(groupId: string, propertyFilterCriteria?: PropertyFilterCriteria, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findGroupPropertiesSearch(groupId, propertyFilterCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return both owned Groups and Groups the user is a member of
     * @summary Return the groups list with specified user id
     * @param {number} [pageFrom] Start page number
     * @param {number} [pageTo] End page number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findGroupsByUser(pageFrom, pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the groups list with specified user id that are inactive
     * @param {number} [pageFrom] 
     * @param {number} [pageTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findInactiveGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findInactiveGroupsByUser(pageFrom, pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the groups list with specified user id that user has invitations of
     * @param {number} [pageFrom] 
     * @param {number} [pageTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findInvitedGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findInvitedGroupsByUser(pageFrom, pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the groups list with specified user id that user has requested
     * @param {number} [pageFrom] 
     * @param {number} [pageTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findRequestedGroupsByUser(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findRequestedGroupsByUser(pageFrom, pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For Group Owners, this list will return removed, left, invited and requested members as well
     * @summary Show all members of Group
     * @param {string} groupId group id
     * @param {number} [pageFrom] Starting page index (zero-based)
     * @param {number} [pageTo] Ending page index (zero-based)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupMembers(groupId: string, pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupMembers(groupId, pageFrom, pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept Group Invitation
     * @param {string} groupId group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupInvite(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupInvite(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Invitation to Group
     * @param {string} groupId group id
     * @param {Array<number>} [userIds] List of user IDs to invite
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupInvite1(groupId: string, userIds?: Array<number>, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupInvite1(groupId, userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave Group
     * @param {string} groupId group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupLeave(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupLeave(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Admission to Group
     * @param {string} groupId group id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupRequest(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupRequest(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Consider that only user can saveNew its groups
     * @summary Create or update the group supplied
     * @param {Group} [group] group to persist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public saveGroup(group?: Group, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).saveGroup(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
     * @summary Update the group member status from groupId supplied
     * @param {string} groupId groupId
     * @param {Array<number>} [userIds] List of user IDs to update status
     * @param {UpdateGroupMembershipStatusStatusEnum} [status] New status for the members
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupMembershipStatus(groupId: string, userIds?: Array<number>, status?: UpdateGroupMembershipStatusStatusEnum, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupMembershipStatus(groupId, userIds, status, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UpdateGroupMembershipStatusStatusEnum = {
    Accepted: 'ACCEPTED',
    Rejected: 'REJECTED',
    Removed: 'REMOVED'
} as const;
export type UpdateGroupMembershipStatusStatusEnum = typeof UpdateGroupMembershipStatusStatusEnum[keyof typeof UpdateGroupMembershipStatusStatusEnum];


/**
 * LanguagesApi - axios parameter creator
 * @export
 */
export const LanguagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {string} [xForwardedFor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages: async (xForwardedFor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (xForwardedFor != null) {
                localVarHeaderParameter['X-Forwarded-For'] = String(xForwardedFor);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguagesApi - functional programming interface
 * @export
 */
export const LanguagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {string} [xForwardedFor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllLanguages(xForwardedFor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Language>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllLanguages(xForwardedFor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguagesApi.getAllLanguages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LanguagesApi - factory interface
 * @export
 */
export const LanguagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguagesApiFp(configuration)
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {string} [xForwardedFor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages(xForwardedFor?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Language>> {
            return localVarFp.getAllLanguages(xForwardedFor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
export class LanguagesApi extends BaseAPI {
    /**
     * Returns a list of all supported languages in the system
     * @summary Get all available languages
     * @param {string} [xForwardedFor] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public getAllLanguages(xForwardedFor?: string, options?: RawAxiosRequestConfig) {
        return LanguagesApiFp(this.configuration).getAllLanguages(xForwardedFor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocalesApi - axios parameter creator
 * @export
 */
export const LocalesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {string} pnemonic 
         * @param {string} [securityKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (pnemonic: string, securityKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pnemonic' is not null or undefined
            assertParamExists('_delete', 'pnemonic', pnemonic)
            const localVarPath = `/locales/{pnemonic}`
                .replace(`{${"pnemonic"}}`, encodeURIComponent(String(pnemonic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (securityKey != null) {
                localVarHeaderParameter['security-key'] = String(securityKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/locales`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {string} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages: async (lang?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/locales/translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Saves or updates a list of locale entries with their translations
         * @summary Create or update the locale translation list
         * @param {string} body List of locale sets to create or update
         * @param {string} [securityKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLocaleEntries: async (body: string, securityKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('saveLocaleEntries', 'body', body)
            const localVarPath = `/locales`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (securityKey != null) {
                localVarHeaderParameter['security-key'] = String(securityKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocalesApi - functional programming interface
 * @export
 */
export const LocalesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocalesApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {string} pnemonic 
         * @param {string} [securityKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(pnemonic: string, securityKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(pnemonic, securityKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalesApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LocaleSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalesApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {string} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLanguages(lang?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLanguages(lang, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalesApi.getLanguages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Saves or updates a list of locale entries with their translations
         * @summary Create or update the locale translation list
         * @param {string} body List of locale sets to create or update
         * @param {string} [securityKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveLocaleEntries(body: string, securityKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveLocaleEntries(body, securityKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalesApi.saveLocaleEntries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocalesApi - factory interface
 * @export
 */
export const LocalesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocalesApiFp(configuration)
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {string} pnemonic 
         * @param {string} [securityKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(pnemonic: string, securityKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp._delete(pnemonic, securityKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(options?: RawAxiosRequestConfig): AxiosPromise<Array<LocaleSet>> {
            return localVarFp.find(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {string} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages(lang?: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getLanguages(lang, options).then((request) => request(axios, basePath));
        },
        /**
         * Saves or updates a list of locale entries with their translations
         * @summary Create or update the locale translation list
         * @param {string} body List of locale sets to create or update
         * @param {string} [securityKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLocaleEntries(body: string, securityKey?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.saveLocaleEntries(body, securityKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocalesApi - object-oriented interface
 * @export
 * @class LocalesApi
 * @extends {BaseAPI}
 */
export class LocalesApi extends BaseAPI {
    /**
     * Removes a locale entry identified by its pnemonic code along with all its translations
     * @summary Delete a locale entry with all translations related
     * @param {string} pnemonic 
     * @param {string} [securityKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    public _delete(pnemonic: string, securityKey?: string, options?: RawAxiosRequestConfig) {
        return LocalesApiFp(this.configuration)._delete(pnemonic, securityKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the complete list of available locales in the system
     * @summary Returns all language list locale entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    public find(options?: RawAxiosRequestConfig) {
        return LocalesApiFp(this.configuration).find(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the locale translations in the specified language
     * @summary Returns locale language list
     * @param {string} [lang] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    public getLanguages(lang?: string, options?: RawAxiosRequestConfig) {
        return LocalesApiFp(this.configuration).getLanguages(lang, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Saves or updates a list of locale entries with their translations
     * @summary Create or update the locale translation list
     * @param {string} body List of locale sets to create or update
     * @param {string} [securityKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    public saveLocaleEntries(body: string, securityKey?: string, options?: RawAxiosRequestConfig) {
        return LocalesApiFp(this.configuration).saveLocaleEntries(body, securityKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
         * @summary Get user notifications by type
         * @param {string} token Authentication token
         * @param {GetByUserWithResultTypeEnum} type Notification type
         * @param {AutopilotUser} autopilotUser User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserWithResult: async (token: string, type: GetByUserWithResultTypeEnum, autopilotUser: AutopilotUser, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getByUserWithResult', 'token', token)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getByUserWithResult', 'type', type)
            // verify required parameter 'autopilotUser' is not null or undefined
            assertParamExists('getByUserWithResult', 'autopilotUser', autopilotUser)
            const localVarPath = `/notifications/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autopilotUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a message by conversation
         * @param {number} [userAId] User A Id
         * @param {number} [userBId] User B Id
         * @param {number} [limit] limit results
         * @param {LocalDateTimeQueryString} [beforeDatetime] return results before date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation: async (userAId?: number, userBId?: number, limit?: number, beforeDatetime?: LocalDateTimeQueryString, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAId !== undefined) {
                localVarQueryParameter['userAId'] = userAId;
            }

            if (userBId !== undefined) {
                localVarQueryParameter['userBId'] = userBId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (beforeDatetime !== undefined) {
                for (const [key, value] of Object.entries(beforeDatetime)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user chat
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUser: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveChatUser', 'id', id)
            const localVarPath = `/chat/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a user chat status
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUserStatus: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveChatUserStatus', 'id', id)
            const localVarPath = `/chat/user/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Post a message
         * @param {Message} [message] message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (message?: Message, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/chat/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
         * @summary Get user notifications by type
         * @param {string} token Authentication token
         * @param {GetByUserWithResultTypeEnum} type Notification type
         * @param {AutopilotUser} autopilotUser User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUserWithResult(token: string, type: GetByUserWithResultTypeEnum, autopilotUser: AutopilotUser, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notification>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUserWithResult(token, type, autopilotUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.getByUserWithResult']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a message by conversation
         * @param {number} [userAId] User A Id
         * @param {number} [userBId] User B Id
         * @param {number} [limit] limit results
         * @param {LocalDateTimeQueryString} [beforeDatetime] return results before date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversation(userAId?: number, userBId?: number, limit?: number, beforeDatetime?: LocalDateTimeQueryString, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Message>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversation(userAId, userBId, limit, beforeDatetime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.getConversation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a user chat
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveChatUser(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveChatUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.retrieveChatUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a user chat status
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveChatUserStatus(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveChatUserStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.retrieveChatUserStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Post a message
         * @param {Message} [message] message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(message?: Message, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Message>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(message, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.sendMessage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessagesApiFp(configuration)
    return {
        /**
         * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
         * @summary Get user notifications by type
         * @param {string} token Authentication token
         * @param {GetByUserWithResultTypeEnum} type Notification type
         * @param {AutopilotUser} autopilotUser User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserWithResult(token: string, type: GetByUserWithResultTypeEnum, autopilotUser: AutopilotUser, options?: RawAxiosRequestConfig): AxiosPromise<Notification> {
            return localVarFp.getByUserWithResult(token, type, autopilotUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a message by conversation
         * @param {number} [userAId] User A Id
         * @param {number} [userBId] User B Id
         * @param {number} [limit] limit results
         * @param {LocalDateTimeQueryString} [beforeDatetime] return results before date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation(userAId?: number, userBId?: number, limit?: number, beforeDatetime?: LocalDateTimeQueryString, options?: RawAxiosRequestConfig): AxiosPromise<Array<Message>> {
            return localVarFp.getConversation(userAId, userBId, limit, beforeDatetime, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a user chat
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUser(id: number, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.retrieveChatUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a user chat status
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUserStatus(id: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.retrieveChatUserStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Post a message
         * @param {Message} [message] message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(message?: Message, options?: RawAxiosRequestConfig): AxiosPromise<Message> {
            return localVarFp.sendMessage(message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
     * @summary Get user notifications by type
     * @param {string} token Authentication token
     * @param {GetByUserWithResultTypeEnum} type Notification type
     * @param {AutopilotUser} autopilotUser User information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getByUserWithResult(token: string, type: GetByUserWithResultTypeEnum, autopilotUser: AutopilotUser, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).getByUserWithResult(token, type, autopilotUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a message by conversation
     * @param {number} [userAId] User A Id
     * @param {number} [userBId] User B Id
     * @param {number} [limit] limit results
     * @param {LocalDateTimeQueryString} [beforeDatetime] return results before date time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public getConversation(userAId?: number, userBId?: number, limit?: number, beforeDatetime?: LocalDateTimeQueryString, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).getConversation(userAId, userBId, limit, beforeDatetime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a user chat
     * @param {number} id user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public retrieveChatUser(id: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).retrieveChatUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a user chat status
     * @param {number} id user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public retrieveChatUserStatus(id: number, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).retrieveChatUserStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Post a message
     * @param {Message} [message] message
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    public sendMessage(message?: Message, options?: RawAxiosRequestConfig) {
        return MessagesApiFp(this.configuration).sendMessage(message, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetByUserWithResultTypeEnum = {
    ToBrokerAlertCreated: 'TO_BROKER__ALERT_CREATED',
    ToUserWeeklyProperties: 'TO_USER__WEEKLY_PROPERTIES',
    ToUserWeeklyPayedSubscribers: 'TO_USER__WEEKLY_PAYED_SUBSCRIBERS',
    ToUserCustomizedAlert: 'TO_USER__CUSTOMIZED_ALERT',
    ToUserWeeklyGroupProperties: 'TO_USER__WEEKLY_GROUP_PROPERTIES',
    ToUserNewsletterNewSubscriber: 'TO_USER__NEWSLETTER_NEW_SUBSCRIBER',
    ToUserNewsletterConfirmation: 'TO_USER__NEWSLETTER_CONFIRMATION',
    ToUserNewsletterListing: 'TO_USER__NEWSLETTER_LISTING'
} as const;
export type GetByUserWithResultTypeEnum = typeof GetByUserWithResultTypeEnum[keyof typeof GetByUserWithResultTypeEnum];


/**
 * PasswordRecoveryApi - axios parameter creator
 * @export
 */
export const PasswordRecoveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {string} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail: async (origin?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password_recovery/send_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryRequest} [passwordRecoveryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword: async (passwordRecoveryRequest?: PasswordRecoveryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password_recovery/update_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password_recovery/validate_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordRecoveryApi - functional programming interface
 * @export
 */
export const PasswordRecoveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordRecoveryApiAxiosParamCreator(configuration)
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {string} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmail(origin?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmail(origin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordRecoveryApi.sendEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryRequest} [passwordRecoveryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePassword(passwordRecoveryRequest?: PasswordRecoveryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword(passwordRecoveryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordRecoveryApi.updatePassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordRecoveryRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordRecoveryApi.validateToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PasswordRecoveryApi - factory interface
 * @export
 */
export const PasswordRecoveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordRecoveryApiFp(configuration)
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {string} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail(origin?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendEmail(origin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryRequest} [passwordRecoveryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword(passwordRecoveryRequest?: PasswordRecoveryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePassword(passwordRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken(options?: RawAxiosRequestConfig): AxiosPromise<PasswordRecoveryRequest> {
            return localVarFp.validateToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PasswordRecoveryApi - object-oriented interface
 * @export
 * @class PasswordRecoveryApi
 * @extends {BaseAPI}
 */
export class PasswordRecoveryApi extends BaseAPI {
    /**
     * In this email it will be contained all process information to change password and recover access
     * @summary Send an email to user that has forgotted his/her password
     * @param {string} [origin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    public sendEmail(origin?: string, options?: RawAxiosRequestConfig) {
        return PasswordRecoveryApiFp(this.configuration).sendEmail(origin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the password user, finishing the recovery password process
     * @param {PasswordRecoveryRequest} [passwordRecoveryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    public updatePassword(passwordRecoveryRequest?: PasswordRecoveryRequest, options?: RawAxiosRequestConfig) {
        return PasswordRecoveryApiFp(this.configuration).updatePassword(passwordRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate that password recovery token supplied was valid and current
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    public validateToken(options?: RawAxiosRequestConfig) {
        return PasswordRecoveryApiFp(this.configuration).validateToken(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PhonePrefixesApi - axios parameter creator
 * @export
 */
export const PhonePrefixesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/country-phone-prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhonePrefixesApi - functional programming interface
 * @export
 */
export const PhonePrefixesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhonePrefixesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountryPhonePrefix>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhonePrefixesApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PhonePrefixesApi - factory interface
 * @export
 */
export const PhonePrefixesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhonePrefixesApiFp(configuration)
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: RawAxiosRequestConfig): AxiosPromise<Array<CountryPhonePrefix>> {
            return localVarFp.get(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhonePrefixesApi - object-oriented interface
 * @export
 * @class PhonePrefixesApi
 * @extends {BaseAPI}
 */
export class PhonePrefixesApi extends BaseAPI {
    /**
     * Retrieves a list of all available country phone prefixes with their details
     * @summary Returns all country-phone-prefixes list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhonePrefixesApi
     */
    public get(options?: RawAxiosRequestConfig) {
        return PhonePrefixesApiFp(this.configuration).get(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertiesApi - axios parameter creator
 * @export
 */
export const PropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Publication state update
         * @param {string} propertyId Property ID
         * @param {string} body Publication state to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus: async (propertyId: string, body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('changePublicationStatus', 'propertyId', propertyId)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('changePublicationStatus', 'body', body)
            const localVarPath = `/properties/{propertyId}/publication-state`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {string} id Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProperty', 'id', id)
            const localVarPath = `/properties/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/fetch-random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch random list of properties related to a given property
         * @param {string} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties1: async (propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('fetchRandomProperties1', 'propertyId', propertyId)
            const localVarPath = `/properties/{propertyId}/related-properties`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search properties with specified filters
         * @param {PropertyFilterCriteria} propertyFilterCriteria Property filter criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperties: async (propertyFilterCriteria: PropertyFilterCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyFilterCriteria' is not null or undefined
            assertParamExists('findProperties', 'propertyFilterCriteria', propertyFilterCriteria)
            const localVarPath = `/properties/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyFilterCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {string} range location range
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPropertiesByLocationRange: async (range: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'range' is not null or undefined
            assertParamExists('findPropertiesByLocationRange', 'range', range)
            const localVarPath = `/properties/by_location_range/{range}`
                .replace(`{${"range"}}`, encodeURIComponent(String(range)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} propertyId Property ID
         * @param {string} [password] Password for protected properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperty: async (propertyId: string, password?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('findProperty', 'propertyId', propertyId)
            const localVarPath = `/properties/{propertyId}`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} id property id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertyOldUrl: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findPropertyOldUrl', 'id', id)
            const localVarPath = `/properties/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftsProperties: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {string} [email] Email to filter properties by user
         * @param {number} [minutes] Minutes to look back (default 60)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProperties: async (email?: string, minutes?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (minutes !== undefined) {
                localVarQueryParameter['minutes'] = minutes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuredProperties: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/password-protected`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {string} id Property ID to generate preview for
         * @param {string} [lang] Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
         * @param {string} [acceptLanguage] Browser\&#39;s accepted language header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty: async (id: string, lang?: string, acceptLanguage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('previewProperty', 'id', id)
            const localVarPath = `/properties/previews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {Property} property Property to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProperty: async (property: Property, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'property' is not null or undefined
            assertParamExists('saveProperty', 'property', property)
            const localVarPath = `/properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WeeklyAlertRange} [weeklyAlertRange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert: async (weeklyAlertRange?: WeeklyAlertRange, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/weekly-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(weeklyAlertRange, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGroupAlert: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/weekly-group-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertiesApi - functional programming interface
 * @export
 */
export const PropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Publication state update
         * @param {string} propertyId Property ID
         * @param {string} body Publication state to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePublicationStatus(propertyId: string, body: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePublicationStatus(propertyId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.changePublicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {string} id Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProperty(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProperty(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.deleteProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomProperties(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomProperties(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.fetchRandomProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch random list of properties related to a given property
         * @param {string} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomProperties1(propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomProperties1(propertyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.fetchRandomProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search properties with specified filters
         * @param {PropertyFilterCriteria} propertyFilterCriteria Property filter criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProperties(propertyFilterCriteria: PropertyFilterCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProperties(propertyFilterCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {string} range location range
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findPropertiesByLocationRange(range: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertiesByLocationRange(range, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findPropertiesByLocationRange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} propertyId Property ID
         * @param {string} [password] Password for protected properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProperty(propertyId: string, password?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProperty(propertyId, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} id property id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPropertyOldUrl(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertyOldUrl(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findPropertyOldUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDraftsProperties(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDraftsProperties(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getDraftsProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {string} [email] Email to filter properties by user
         * @param {number} [minutes] Minutes to look back (default 60)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentProperties(email?: string, minutes?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentProperties(email, minutes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getRecentProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecuredProperties(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecuredProperties(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getSecuredProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {string} id Property ID to generate preview for
         * @param {string} [lang] Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
         * @param {string} [acceptLanguage] Browser\&#39;s accepted language header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewProperty(id: string, lang?: string, acceptLanguage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewProperty(id, lang, acceptLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.previewProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {Property} property Property to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveProperty(property: Property, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveProperty(property, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.saveProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WeeklyAlertRange} [weeklyAlertRange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendAlert(weeklyAlertRange?: WeeklyAlertRange, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendAlert(weeklyAlertRange, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.sendAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendGroupAlert(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendGroupAlert(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.sendGroupAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertiesApi - factory interface
 * @export
 */
export const PropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Publication state update
         * @param {string} propertyId Property ID
         * @param {string} body Publication state to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus(propertyId: string, body: string, options?: RawAxiosRequestConfig): AxiosPromise<Property> {
            return localVarFp.changePublicationStatus(propertyId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {string} id Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteProperty(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties(options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.fetchRandomProperties(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch random list of properties related to a given property
         * @param {string} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties1(propertyId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.fetchRandomProperties1(propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search properties with specified filters
         * @param {PropertyFilterCriteria} propertyFilterCriteria Property filter criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperties(propertyFilterCriteria: PropertyFilterCriteria, options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.findProperties(propertyFilterCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {string} range location range
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPropertiesByLocationRange(range: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findPropertiesByLocationRange(range, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} propertyId Property ID
         * @param {string} [password] Password for protected properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperty(propertyId: string, password?: string, options?: RawAxiosRequestConfig): AxiosPromise<Property> {
            return localVarFp.findProperty(propertyId, password, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} id property id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertyOldUrl(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findPropertyOldUrl(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftsProperties(options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.getDraftsProperties(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {string} [email] Email to filter properties by user
         * @param {number} [minutes] Minutes to look back (default 60)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProperties(email?: string, minutes?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.getRecentProperties(email, minutes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuredProperties(options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.getSecuredProperties(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {string} id Property ID to generate preview for
         * @param {string} [lang] Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
         * @param {string} [acceptLanguage] Browser\&#39;s accepted language header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty(id: string, lang?: string, acceptLanguage?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.previewProperty(id, lang, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {Property} property Property to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProperty(property: Property, options?: RawAxiosRequestConfig): AxiosPromise<Property> {
            return localVarFp.saveProperty(property, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WeeklyAlertRange} [weeklyAlertRange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert(weeklyAlertRange?: WeeklyAlertRange, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.sendAlert(weeklyAlertRange, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGroupAlert(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.sendGroupAlert(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertiesApi - object-oriented interface
 * @export
 * @class PropertiesApi
 * @extends {BaseAPI}
 */
export class PropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Publication state update
     * @param {string} propertyId Property ID
     * @param {string} body Publication state to set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public changePublicationStatus(propertyId: string, body: string, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).changePublicationStatus(propertyId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This process is not reversible
     * @summary Delete the property with id supplied
     * @param {string} id Property ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public deleteProperty(id: string, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).deleteProperty(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a randomized list of properties with the specified count limit
     * @summary Fetch random list of properties, with basic data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public fetchRandomProperties(options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).fetchRandomProperties(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch random list of properties related to a given property
     * @param {string} propertyId Property ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public fetchRandomProperties1(propertyId: string, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).fetchRandomProperties1(propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search properties with specified filters
     * @param {PropertyFilterCriteria} propertyFilterCriteria Property filter criteria
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public findProperties(propertyFilterCriteria: PropertyFilterCriteria, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).findProperties(propertyFilterCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the property list with specified user id
     * @param {string} range location range
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public findPropertiesByLocationRange(range: string, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).findPropertiesByLocationRange(range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter the properties existing in system with specified id. Returns empty if none property match the id
     * @summary Return the property with specified id
     * @param {string} propertyId Property ID
     * @param {string} [password] Password for protected properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public findProperty(propertyId: string, password?: string, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).findProperty(propertyId, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter the properties existing in system with specified id. Returns empty if none property match the id
     * @summary Return the property with specified id
     * @param {string} id property id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public findPropertyOldUrl(id: string, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).findPropertyOldUrl(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Password Protected Property for Signed in User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public getDraftsProperties(options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).getDraftsProperties(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get recently created properties within specified minutes (default 60)
     * @param {string} [email] Email to filter properties by user
     * @param {number} [minutes] Minutes to look back (default 60)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public getRecentProperties(email?: string, minutes?: number, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).getRecentProperties(email, minutes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Password Protected Property for Signed in User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public getSecuredProperties(options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).getSecuredProperties(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns HTML preview for sharing a property on social media or messaging apps
     * @summary Get HTML preview for a property
     * @param {string} id Property ID to generate preview for
     * @param {string} [lang] Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
     * @param {string} [acceptLanguage] Browser\&#39;s accepted language header
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public previewProperty(id: string, lang?: string, acceptLanguage?: string, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).previewProperty(id, lang, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Consider that only user can saveNew its properties
     * @summary Create or update the property supplied
     * @param {Property} property Property to persist
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public saveProperty(property: Property, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).saveProperty(property, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {WeeklyAlertRange} [weeklyAlertRange] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public sendAlert(weeklyAlertRange?: WeeklyAlertRange, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).sendAlert(weeklyAlertRange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public sendGroupAlert(options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).sendGroupAlert(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyBulkDownloadApi - axios parameter creator
 * @export
 */
export const PropertyBulkDownloadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerKyeroExport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-bulk-download/trigger-kyero-export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type (e.g., kyero, idealista)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xml: async (userId: string, xmlFormat: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('xml', 'userId', userId)
            // verify required parameter 'xmlFormat' is not null or undefined
            assertParamExists('xml', 'xmlFormat', xmlFormat)
            const localVarPath = `/property-bulk-download/{userId}/{xmlFormat}.xml`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"xmlFormat"}}`, encodeURIComponent(String(xmlFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        xmlRedirect: async (userId: string, xmlFormat: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('xmlRedirect', 'userId', userId)
            // verify required parameter 'xmlFormat' is not null or undefined
            assertParamExists('xmlRedirect', 'xmlFormat', xmlFormat)
            const localVarPath = `/property-bulk-download/{userId}/{xmlFormat}.xml.redirect`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"xmlFormat"}}`, encodeURIComponent(String(xmlFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyBulkDownloadApi - functional programming interface
 * @export
 */
export const PropertyBulkDownloadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyBulkDownloadApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerKyeroExport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerKyeroExport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkDownloadApi.triggerKyeroExport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type (e.g., kyero, idealista)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async xml(userId: string, xmlFormat: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.xml(userId, xmlFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkDownloadApi.xml']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async xmlRedirect(userId: string, xmlFormat: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.xmlRedirect(userId, xmlFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkDownloadApi.xmlRedirect']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyBulkDownloadApi - factory interface
 * @export
 */
export const PropertyBulkDownloadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyBulkDownloadApiFp(configuration)
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerKyeroExport(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.triggerKyeroExport(options).then((request) => request(axios, basePath));
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type (e.g., kyero, idealista)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xml(userId: string, xmlFormat: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.xml(userId, xmlFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        xmlRedirect(userId: string, xmlFormat: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.xmlRedirect(userId, xmlFormat, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyBulkDownloadApi - object-oriented interface
 * @export
 * @class PropertyBulkDownloadApi
 * @extends {BaseAPI}
 */
export class PropertyBulkDownloadApi extends BaseAPI {
    /**
     * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
     * @summary Manually trigger Kyero exports to S3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    public triggerKyeroExport(options?: RawAxiosRequestConfig) {
        return PropertyBulkDownloadApiFp(this.configuration).triggerKyeroExport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates and returns property data in XML format for a specific user and format type.
     * @summary Get property XML for specific user
     * @param {string} userId User ID for the property owner
     * @param {string} xmlFormat XML format type (e.g., kyero, idealista)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    public xml(userId: string, xmlFormat: string, options?: RawAxiosRequestConfig) {
        return PropertyBulkDownloadApiFp(this.configuration).xml(userId, xmlFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
     * @summary Redirect to XML file (Deprecated)
     * @param {string} userId User ID for the property owner
     * @param {string} xmlFormat XML format type
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    public xmlRedirect(userId: string, xmlFormat: string, options?: RawAxiosRequestConfig) {
        return PropertyBulkDownloadApiFp(this.configuration).xmlRedirect(userId, xmlFormat, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyBulkUploadsApi - axios parameter creator
 * @export
 */
export const PropertyBulkUploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-bulk-uploads/formats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {string} [body] Properties XML content in Kyero format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties: async (body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-bulk-uploads/in-body`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroPropertiesFromUrl: async (xmlUrl?: XmlUrl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-bulk-uploads/in-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(xmlUrl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {UploadPropertiesFormatEnum} format Format identifier
         * @param {string} [body] Properties XML content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProperties: async (format: UploadPropertiesFormatEnum, body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('uploadProperties', 'format', format)
            const localVarPath = `/property-bulk-uploads/{format}/in-body`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {UploadPropertiesFromUrlFormatEnum} format Format identifier
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPropertiesFromUrl: async (format: UploadPropertiesFromUrlFormatEnum, xmlUrl?: XmlUrl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('uploadPropertiesFromUrl', 'format', format)
            const localVarPath = `/property-bulk-uploads/{format}/in-url`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(xmlUrl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyBulkUploadsApi - functional programming interface
 * @export
 */
export const PropertyBulkUploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyBulkUploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.getFormats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {string} [body] Properties XML content in Kyero format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroProperties(body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroProperties(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadKyeroProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroPropertiesFromUrl(xmlUrl?: XmlUrl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroPropertiesFromUrl(xmlUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadKyeroPropertiesFromUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {UploadPropertiesFormatEnum} format Format identifier
         * @param {string} [body] Properties XML content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProperties(format: UploadPropertiesFormatEnum, body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProperties(format, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {UploadPropertiesFromUrlFormatEnum} format Format identifier
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPropertiesFromUrl(format: UploadPropertiesFromUrlFormatEnum, xmlUrl?: XmlUrl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPropertiesFromUrl(format, xmlUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadPropertiesFromUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyBulkUploadsApi - factory interface
 * @export
 */
export const PropertyBulkUploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyBulkUploadsApiFp(configuration)
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormats(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getFormats(options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {string} [body] Properties XML content in Kyero format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties(body?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadKyeroProperties(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroPropertiesFromUrl(xmlUrl?: XmlUrl, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadKyeroPropertiesFromUrl(xmlUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {UploadPropertiesFormatEnum} format Format identifier
         * @param {string} [body] Properties XML content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProperties(format: UploadPropertiesFormatEnum, body?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadProperties(format, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {UploadPropertiesFromUrlFormatEnum} format Format identifier
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPropertiesFromUrl(format: UploadPropertiesFromUrlFormatEnum, xmlUrl?: XmlUrl, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadPropertiesFromUrl(format, xmlUrl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyBulkUploadsApi - object-oriented interface
 * @export
 * @class PropertyBulkUploadsApi
 * @extends {BaseAPI}
 */
export class PropertyBulkUploadsApi extends BaseAPI {
    /**
     * Get the list of supported file formats for bulk upload
     * @summary Get available formats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    public getFormats(options?: RawAxiosRequestConfig) {
        return PropertyBulkUploadsApiFp(this.configuration).getFormats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload properties using Kyero format with XML content in the request body
     * @summary Upload Kyero properties with XML in request body
     * @param {string} [body] Properties XML content in Kyero format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    public uploadKyeroProperties(body?: string, options?: RawAxiosRequestConfig) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadKyeroProperties(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload properties in Kyero format by providing a URL to an XML file
     * @summary Upload Kyero properties from URL
     * @param {XmlUrl} [xmlUrl] XML URL object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    public uploadKyeroPropertiesFromUrl(xmlUrl?: XmlUrl, options?: RawAxiosRequestConfig) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadKyeroPropertiesFromUrl(xmlUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload properties with XML content in the request body using the specified format
     * @summary Upload properties in specified format with XML in request body
     * @param {UploadPropertiesFormatEnum} format Format identifier
     * @param {string} [body] Properties XML content
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    public uploadProperties(format: UploadPropertiesFormatEnum, body?: string, options?: RawAxiosRequestConfig) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadProperties(format, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload properties in the specified format by providing a URL to an XML file
     * @summary Upload properties in specified format from URL
     * @param {UploadPropertiesFromUrlFormatEnum} format Format identifier
     * @param {XmlUrl} [xmlUrl] XML URL object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    public uploadPropertiesFromUrl(format: UploadPropertiesFromUrlFormatEnum, xmlUrl?: XmlUrl, options?: RawAxiosRequestConfig) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadPropertiesFromUrl(format, xmlUrl, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UploadPropertiesFormatEnum = {
    Kyero: 'kyero',
    Wasico: 'wasico',
    Xml2u: 'xml2u',
    Hallocasa: 'hallocasa'
} as const;
export type UploadPropertiesFormatEnum = typeof UploadPropertiesFormatEnum[keyof typeof UploadPropertiesFormatEnum];
/**
 * @export
 */
export const UploadPropertiesFromUrlFormatEnum = {
    Kyero: 'kyero',
    Wasico: 'wasico',
    Xml2u: 'xml2u',
    Hallocasa: 'hallocasa'
} as const;
export type UploadPropertiesFromUrlFormatEnum = typeof UploadPropertiesFromUrlFormatEnum[keyof typeof UploadPropertiesFromUrlFormatEnum];


/**
 * PropertyFieldApi - axios parameter creator
 * @export
 */
export const PropertyFieldApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
         * @summary Retrieves property fields filtered by key
         * @param {PropertyKey} [propertyKey] key set of the property to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters: async (propertyKey?: PropertyKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-fields/filter-by-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyKey, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyFieldApi - functional programming interface
 * @export
 */
export const PropertyFieldApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyFieldApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
         * @summary Retrieves property fields filtered by key
         * @param {PropertyKey} [propertyKey] key set of the property to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFilters(propertyKey?: PropertyKey, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFilters(propertyKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyFieldApi.getPropertyFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyFieldApi - factory interface
 * @export
 */
export const PropertyFieldApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyFieldApiFp(configuration)
    return {
        /**
         * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
         * @summary Retrieves property fields filtered by key
         * @param {PropertyKey} [propertyKey] key set of the property to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters(propertyKey?: PropertyKey, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getPropertyFilters(propertyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyFieldApi - object-oriented interface
 * @export
 * @class PropertyFieldApi
 * @extends {BaseAPI}
 */
export class PropertyFieldApi extends BaseAPI {
    /**
     * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
     * @summary Retrieves property fields filtered by key
     * @param {PropertyKey} [propertyKey] key set of the property to filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFieldApi
     */
    public getPropertyFilters(propertyKey?: PropertyKey, options?: RawAxiosRequestConfig) {
        return PropertyFieldApiFp(this.configuration).getPropertyFilters(propertyKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyFiltersApi - axios parameter creator
 * @export
 */
export const PropertyFiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {number} filterId ID of the filter to get options for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFieldOptions: async (filterId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('getPropertyFieldOptions', 'filterId', filterId)
            const localVarPath = `/property_filters/options/{filter_id}`
                .replace(`{${"filter_id"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {Array<number>} [filterNatureId] Filter nature IDs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters1: async (filterNatureId?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (filterNatureId) {
                localVarQueryParameter['filter_nature_id'] = filterNatureId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyFiltersApi - functional programming interface
 * @export
 */
export const PropertyFiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyFiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {number} filterId ID of the filter to get options for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFieldOptions(filterId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFieldOptions(filterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyFiltersApi.getPropertyFieldOptions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {Array<number>} [filterNatureId] Filter nature IDs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFilters1(filterNatureId?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyFilter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFilters1(filterNatureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyFiltersApi.getPropertyFilters1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyFiltersApi - factory interface
 * @export
 */
export const PropertyFiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyFiltersApiFp(configuration)
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {number} filterId ID of the filter to get options for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFieldOptions(filterId: number, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPropertyFieldOptions(filterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {Array<number>} [filterNatureId] Filter nature IDs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters1(filterNatureId?: Array<number>, options?: RawAxiosRequestConfig): AxiosPromise<Array<PropertyFilter>> {
            return localVarFp.getPropertyFilters1(filterNatureId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyFiltersApi - object-oriented interface
 * @export
 * @class PropertyFiltersApi
 * @extends {BaseAPI}
 */
export class PropertyFiltersApi extends BaseAPI {
    /**
     * Retrieves options for a specific property filter based on submitted filters
     * @summary Get property field options
     * @param {number} filterId ID of the filter to get options for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFiltersApi
     */
    public getPropertyFieldOptions(filterId: number, options?: RawAxiosRequestConfig) {
        return PropertyFiltersApiFp(this.configuration).getPropertyFieldOptions(filterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of property filters, optionally filtered by filter nature IDs
     * @summary Get property filters
     * @param {Array<number>} [filterNatureId] Filter nature IDs to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFiltersApi
     */
    public getPropertyFilters1(filterNatureId?: Array<number>, options?: RawAxiosRequestConfig) {
        return PropertyFiltersApiFp(this.configuration).getPropertyFilters1(filterNatureId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyLocationsApi - axios parameter creator
 * @export
 */
export const PropertyLocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyLocationsApi - functional programming interface
 * @export
 */
export const PropertyLocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyLocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCountries1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCountries1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyLocationsApi.getAllCountries1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyLocationsApi - factory interface
 * @export
 */
export const PropertyLocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyLocationsApiFp(configuration)
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries1(options?: RawAxiosRequestConfig): AxiosPromise<Array<PropertyLocation>> {
            return localVarFp.getAllCountries1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyLocationsApi - object-oriented interface
 * @export
 * @class PropertyLocationsApi
 * @extends {BaseAPI}
 */
export class PropertyLocationsApi extends BaseAPI {
    /**
     * Retrieves a list of all available property locations
     * @summary Method to find all the property locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyLocationsApi
     */
    public getAllCountries1(options?: RawAxiosRequestConfig) {
        return PropertyLocationsApiFp(this.configuration).getAllCountries1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyProposalsApi - axios parameter creator
 * @export
 */
export const PropertyProposalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyProposals: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyProposalsApi - functional programming interface
 * @export
 */
export const PropertyProposalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyProposalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPropertyProposals(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyProposal>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPropertyProposals(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyProposalsApi.getAllPropertyProposals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyProposalsApi - factory interface
 * @export
 */
export const PropertyProposalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyProposalsApiFp(configuration)
    return {
        /**
         * 
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyProposals(options?: RawAxiosRequestConfig): AxiosPromise<Array<PropertyProposal>> {
            return localVarFp.getAllPropertyProposals(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyProposalsApi - object-oriented interface
 * @export
 * @class PropertyProposalsApi
 * @extends {BaseAPI}
 */
export class PropertyProposalsApi extends BaseAPI {
    /**
     * 
     * @summary Method to find all the property proposals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyProposalsApi
     */
    public getAllPropertyProposals(options?: RawAxiosRequestConfig) {
        return PropertyProposalsApiFp(this.configuration).getAllPropertyProposals(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyTypesApi - axios parameter creator
 * @export
 */
export const PropertyTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyTypesApi - functional programming interface
 * @export
 */
export const PropertyTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPropertyTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPropertyTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyTypesApi.getAllPropertyTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyTypesApi - factory interface
 * @export
 */
export const PropertyTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyTypesApiFp(configuration)
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<PropertyType>> {
            return localVarFp.getAllPropertyTypes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyTypesApi - object-oriented interface
 * @export
 * @class PropertyTypesApi
 * @extends {BaseAPI}
 */
export class PropertyTypesApi extends BaseAPI {
    /**
     * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
     * @summary Get all property types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypesApi
     */
    public getAllPropertyTypes(options?: RawAxiosRequestConfig) {
        return PropertyTypesApiFp(this.configuration).getAllPropertyTypes(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {string} clientId Client application identifier
         * @param {string} code Authorization code received from /auth endpoint
         * @param {string} email User email address
         * @param {string} password User password
         * @param {string} [grantType] OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken: async (clientId: string, code: string, email: string, password: string, grantType?: string, clientSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('requestToken', 'clientId', clientId)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('requestToken', 'code', code)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('requestToken', 'email', email)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('requestToken', 'password', password)
            const localVarPath = `/security/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (clientId !== undefined) { 
                localVarFormParams.set('client-id', clientId as any);
            }
    
            if (code !== undefined) { 
                localVarFormParams.set('code', code as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.set('email', email as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.authorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {string} clientId Client application identifier
         * @param {string} code Authorization code received from /auth endpoint
         * @param {string} email User email address
         * @param {string} password User password
         * @param {string} [grantType] OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestToken(clientId: string, code: string, email: string, password: string, grantType?: string, clientSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestToken(clientId, code, email, password, grantType, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.requestToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityApiFp(configuration)
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authorize(options).then((request) => request(axios, basePath));
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {string} clientId Client application identifier
         * @param {string} code Authorization code received from /auth endpoint
         * @param {string} email User email address
         * @param {string} password User password
         * @param {string} [grantType] OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken(clientId: string, code: string, email: string, password: string, grantType?: string, clientSecret?: string, options?: RawAxiosRequestConfig): AxiosPromise<AuthInfoDto> {
            return localVarFp.requestToken(clientId, code, email, password, grantType, clientSecret, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * Generates an authorization code to be used with the token endpoint
     * @summary Authorize client application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public authorize(options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).authorize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
     * @summary Exchange authorization code for access token
     * @param {string} clientId Client application identifier
     * @param {string} code Authorization code received from /auth endpoint
     * @param {string} email User email address
     * @param {string} password User password
     * @param {string} [grantType] OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
     * @param {string} [clientSecret] Client application secret
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public requestToken(clientId: string, code: string, email: string, password: string, grantType?: string, clientSecret?: string, options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).requestToken(clientId, code, email, password, grantType, clientSecret, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SkillsApi - axios parameter creator
 * @export
 */
export const SkillsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/skills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkillsApi - functional programming interface
 * @export
 */
export const SkillsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkillsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSkills(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Skill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSkills(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.retrieveUserSkills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SkillsApi - factory interface
 * @export
 */
export const SkillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkillsApiFp(configuration)
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills(options?: RawAxiosRequestConfig): AxiosPromise<Array<Skill>> {
            return localVarFp.retrieveUserSkills(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
export class SkillsApi extends BaseAPI {
    /**
     * Returns a list of all available user skills in the system
     * @summary Retrieve all user skills
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public retrieveUserSkills(options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).retrieveUserSkills(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeWebhooksApi - axios parameter creator
 * @export
 */
export const StripeWebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Notify user subscription change
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSubscriptionChange: async (stripeEvent?: StripeEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe-webhooks/user-subscription-update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripeEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeWebhooksApi - functional programming interface
 * @export
 */
export const StripeWebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeWebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Notify user subscription change
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserSubscriptionChange(stripeEvent?: StripeEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserSubscriptionChange(stripeEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeWebhooksApi.postUserSubscriptionChange']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StripeWebhooksApi - factory interface
 * @export
 */
export const StripeWebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeWebhooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Notify user subscription change
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSubscriptionChange(stripeEvent?: StripeEvent, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUserSubscriptionChange(stripeEvent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeWebhooksApi - object-oriented interface
 * @export
 * @class StripeWebhooksApi
 * @extends {BaseAPI}
 */
export class StripeWebhooksApi extends BaseAPI {
    /**
     * 
     * @summary Notify user subscription change
     * @param {StripeEvent} [stripeEvent] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeWebhooksApi
     */
    public postUserSubscriptionChange(stripeEvent?: StripeEvent, options?: RawAxiosRequestConfig) {
        return StripeWebhooksApiFp(this.configuration).postUserSubscriptionChange(stripeEvent, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('get1', 'userId', userId)
            const localVarPath = `/users/{userId}/subscriptions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveFeatures: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getActiveFeatures', 'userId', userId)
            const localVarPath = `/users/{userId}/subscriptions/active/features`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the active and available subscription plans
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (expand?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscription-plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get1(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSubscriptionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.get1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveFeatures(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionPlanFeatureDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveFeatures(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.getActiveFeatures']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the active and available subscription plans
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(expand?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.getAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<UserSubscriptionDto> {
            return localVarFp.get1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveFeatures(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SubscriptionPlanFeatureDto>> {
            return localVarFp.getActiveFeatures(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the active and available subscription plans
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(expand?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getAll(expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public get1(userId: number, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).get1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getActiveFeatures(userId: number, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getActiveFeatures(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the active and available subscription plans
     * @param {Array<string>} [expand] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getAll(expand?: Array<string>, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getAll(expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestimonialApi - axios parameter creator
 * @export
 */
export const TestimonialApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Publication state update
         * @param {string} testimonialId Testimonial Id
         * @param {boolean} publicationState Publication State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus1: async (testimonialId: string, publicationState: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testimonialId' is not null or undefined
            assertParamExists('changePublicationStatus1', 'testimonialId', testimonialId)
            // verify required parameter 'publicationState' is not null or undefined
            assertParamExists('changePublicationStatus1', 'publicationState', publicationState)
            const localVarPath = `/testimonial/{testimonialId}/publication-state/{publicationState}`
                .replace(`{${"testimonialId"}}`, encodeURIComponent(String(testimonialId)))
                .replace(`{${"publicationState"}}`, encodeURIComponent(String(publicationState)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch User Posted list of testimonials
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPublishedTestimonials: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testimonial/published`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch User Received list of testimonials
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchReceivedTestimonials: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testimonial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {string} testimonialId testimonial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonial: async (testimonialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testimonialId' is not null or undefined
            assertParamExists('findTestimonial', 'testimonialId', testimonialId)
            const localVarPath = `/testimonial/{testimonialId}`
                .replace(`{${"testimonialId"}}`, encodeURIComponent(String(testimonialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequests: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testimonial/requested`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequestsReceived: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testimonial/request-received`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTestimonial: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testimonial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestimonialApi - functional programming interface
 * @export
 */
export const TestimonialApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestimonialApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Publication state update
         * @param {string} testimonialId Testimonial Id
         * @param {boolean} publicationState Publication State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePublicationStatus1(testimonialId: string, publicationState: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Testimonial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePublicationStatus1(testimonialId, publicationState, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.changePublicationStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch User Posted list of testimonials
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchPublishedTestimonials(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonialFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchPublishedTestimonials(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.fetchPublishedTestimonials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch User Received list of testimonials
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchReceivedTestimonials(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonialFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchReceivedTestimonials(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.fetchReceivedTestimonials']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {string} testimonialId testimonial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonial(testimonialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Testimonial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonial(testimonialId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.findTestimonial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialRequests(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Testimonial>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialRequests(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.findTestimonialRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialRequestsReceived(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Testimonial>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialRequestsReceived(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.findTestimonialRequestsReceived']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTestimonial(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Testimonial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTestimonial(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.saveTestimonial']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestimonialApi - factory interface
 * @export
 */
export const TestimonialApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestimonialApiFp(configuration)
    return {
        /**
         * 
         * @summary Publication state update
         * @param {string} testimonialId Testimonial Id
         * @param {boolean} publicationState Publication State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus1(testimonialId: string, publicationState: boolean, options?: RawAxiosRequestConfig): AxiosPromise<Testimonial> {
            return localVarFp.changePublicationStatus1(testimonialId, publicationState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch User Posted list of testimonials
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPublishedTestimonials(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<TestimonialFilterResult> {
            return localVarFp.fetchPublishedTestimonials(pageFrom, pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch User Received list of testimonials
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchReceivedTestimonials(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<TestimonialFilterResult> {
            return localVarFp.fetchReceivedTestimonials(pageFrom, pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {string} testimonialId testimonial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonial(testimonialId: string, options?: RawAxiosRequestConfig): AxiosPromise<Testimonial> {
            return localVarFp.findTestimonial(testimonialId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequests(options?: RawAxiosRequestConfig): AxiosPromise<Array<Testimonial>> {
            return localVarFp.findTestimonialRequests(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequestsReceived(options?: RawAxiosRequestConfig): AxiosPromise<Array<Testimonial>> {
            return localVarFp.findTestimonialRequestsReceived(options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTestimonial(options?: RawAxiosRequestConfig): AxiosPromise<Testimonial> {
            return localVarFp.saveTestimonial(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestimonialApi - object-oriented interface
 * @export
 * @class TestimonialApi
 * @extends {BaseAPI}
 */
export class TestimonialApi extends BaseAPI {
    /**
     * 
     * @summary Publication state update
     * @param {string} testimonialId Testimonial Id
     * @param {boolean} publicationState Publication State
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public changePublicationStatus1(testimonialId: string, publicationState: boolean, options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).changePublicationStatus1(testimonialId, publicationState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch User Posted list of testimonials
     * @param {number} [pageFrom] 
     * @param {number} [pageTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public fetchPublishedTestimonials(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).fetchPublishedTestimonials(pageFrom, pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch User Received list of testimonials
     * @param {number} [pageFrom] 
     * @param {number} [pageTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public fetchReceivedTestimonials(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).fetchReceivedTestimonials(pageFrom, pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the testimonial with specified id, it needs to be published
     * @param {string} testimonialId testimonial id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public findTestimonial(testimonialId: string, options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).findTestimonial(testimonialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the testimonial Requests a user Created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public findTestimonialRequests(options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).findTestimonialRequests(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the testimonial Requests a user Received
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public findTestimonialRequestsReceived(options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).findTestimonialRequestsReceived(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Consider that only user can save new testimonials
     * @summary Create or update the Testimonial supplied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public saveTestimonial(options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).saveTestimonial(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextTranslationsApi - axios parameter creator
 * @export
 */
export const TextTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {string} [targetLang] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateText: async (targetLang?: string, text?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/text-translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (targetLang !== undefined) {
                localVarQueryParameter['targetLang'] = targetLang;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTranslationsApi - functional programming interface
 * @export
 */
export const TextTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {string} [targetLang] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translateText(targetLang?: string, text?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextTranslation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translateText(targetLang, text, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextTranslationsApi.translateText']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextTranslationsApi - factory interface
 * @export
 */
export const TextTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextTranslationsApiFp(configuration)
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {string} [targetLang] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateText(targetLang?: string, text?: string, options?: RawAxiosRequestConfig): AxiosPromise<TextTranslation> {
            return localVarFp.translateText(targetLang, text, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TextTranslationsApi - object-oriented interface
 * @export
 * @class TextTranslationsApi
 * @extends {BaseAPI}
 */
export class TextTranslationsApi extends BaseAPI {
    /**
     * Translate the provided text to the specified target language
     * @summary Get text translation to a target language
     * @param {string} [targetLang] 
     * @param {string} [text] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTranslationsApi
     */
    public translateText(targetLang?: string, text?: string, options?: RawAxiosRequestConfig) {
        return TextTranslationsApiFp(this.configuration).translateText(targetLang, text, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserConnectionsApi - axios parameter creator
 * @export
 */
export const UserConnectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a user connections
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findUserConnections', 'userId', userId)
            const localVarPath = `/chat/users/{userId}/connections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserConnectionsApi - functional programming interface
 * @export
 */
export const UserConnectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserConnectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a user connections
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserConnections(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserConnections(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserConnectionsApi.findUserConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserConnectionsApi - factory interface
 * @export
 */
export const UserConnectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserConnectionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a user connections
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<User>> {
            return localVarFp.findUserConnections(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserConnectionsApi - object-oriented interface
 * @export
 * @class UserConnectionsApi
 * @extends {BaseAPI}
 */
export class UserConnectionsApi extends BaseAPI {
    /**
     * 
     * @summary Get a user connections
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionsApi
     */
    public findUserConnections(userId: number, options?: RawAxiosRequestConfig) {
        return UserConnectionsApiFp(this.configuration).findUserConnections(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserContractsApi - axios parameter creator
 * @export
 */
export const UserContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get a user Contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserContracts: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Save a user Contract
         * @param {Contract} contract Contract to save
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save: async (contract: Contract, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contract' is not null or undefined
            assertParamExists('save', 'contract', contract)
            const localVarPath = `/contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contract, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserContractsApi - functional programming interface
 * @export
 */
export const UserContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get a user Contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserContracts(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contract>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserContracts(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserContractsApi.findUserContracts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Save a user Contract
         * @param {Contract} contract Contract to save
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save(contract: Contract, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save(contract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserContractsApi.save']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserContractsApi - factory interface
 * @export
 */
export const UserContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserContractsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get a user Contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserContracts(options?: RawAxiosRequestConfig): AxiosPromise<Array<Contract>> {
            return localVarFp.findUserContracts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Save a user Contract
         * @param {Contract} contract Contract to save
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save(contract: Contract, options?: RawAxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.save(contract, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserContractsApi - object-oriented interface
 * @export
 * @class UserContractsApi
 * @extends {BaseAPI}
 */
export class UserContractsApi extends BaseAPI {
    /**
     * 
     * @summary Get a user Contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserContractsApi
     */
    public findUserContracts(options?: RawAxiosRequestConfig) {
        return UserContractsApiFp(this.configuration).findUserContracts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Save a user Contract
     * @param {Contract} contract Contract to save
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserContractsApi
     */
    public save(contract: Contract, options?: RawAxiosRequestConfig) {
        return UserContractsApiFp(this.configuration).save(contract, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserSummaryApi - axios parameter creator
 * @export
 */
export const UserSummaryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves summaries of all chat conversations for a user
         * @summary Get the user chat summaries
         * @param {number} userId User ID to fetch chat summaries for
         * @param {number} [limit] Limit the number of chat summaries returned
         * @param {LocalDateTimeQueryString} [beforeDatetime] Only return chat summaries before this datetime (UTC timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatSummaryByUser: async (userId: number, limit?: number, beforeDatetime?: LocalDateTimeQueryString, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getChatSummaryByUser', 'userId', userId)
            const localVarPath = `/chat/user_summary/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (beforeDatetime !== undefined) {
                for (const [key, value] of Object.entries(beforeDatetime)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserSummaryApi - functional programming interface
 * @export
 */
export const UserSummaryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserSummaryApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves summaries of all chat conversations for a user
         * @summary Get the user chat summaries
         * @param {number} userId User ID to fetch chat summaries for
         * @param {number} [limit] Limit the number of chat summaries returned
         * @param {LocalDateTimeQueryString} [beforeDatetime] Only return chat summaries before this datetime (UTC timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatSummaryByUser(userId: number, limit?: number, beforeDatetime?: LocalDateTimeQueryString, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserChatsSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatSummaryByUser(userId, limit, beforeDatetime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSummaryApi.getChatSummaryByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserSummaryApi - factory interface
 * @export
 */
export const UserSummaryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserSummaryApiFp(configuration)
    return {
        /**
         * Retrieves summaries of all chat conversations for a user
         * @summary Get the user chat summaries
         * @param {number} userId User ID to fetch chat summaries for
         * @param {number} [limit] Limit the number of chat summaries returned
         * @param {LocalDateTimeQueryString} [beforeDatetime] Only return chat summaries before this datetime (UTC timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatSummaryByUser(userId: number, limit?: number, beforeDatetime?: LocalDateTimeQueryString, options?: RawAxiosRequestConfig): AxiosPromise<UserChatsSummary> {
            return localVarFp.getChatSummaryByUser(userId, limit, beforeDatetime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserSummaryApi - object-oriented interface
 * @export
 * @class UserSummaryApi
 * @extends {BaseAPI}
 */
export class UserSummaryApi extends BaseAPI {
    /**
     * Retrieves summaries of all chat conversations for a user
     * @summary Get the user chat summaries
     * @param {number} userId User ID to fetch chat summaries for
     * @param {number} [limit] Limit the number of chat summaries returned
     * @param {LocalDateTimeQueryString} [beforeDatetime] Only return chat summaries before this datetime (UTC timestamp)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSummaryApi
     */
    public getChatSummaryByUser(userId: number, limit?: number, beforeDatetime?: LocalDateTimeQueryString, options?: RawAxiosRequestConfig) {
        return UserSummaryApiFp(this.configuration).getChatSummaryByUser(userId, limit, beforeDatetime, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserTypesApi - axios parameter creator
 * @export
 */
export const UserTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserTypesApi - functional programming interface
 * @export
 */
export const UserTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTypesApi.getUserTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserTypesApi - factory interface
 * @export
 */
export const UserTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserTypesApiFp(configuration)
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTypes(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserType>> {
            return localVarFp.getUserTypes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserTypesApi - object-oriented interface
 * @export
 * @class UserTypesApi
 * @extends {BaseAPI}
 */
export class UserTypesApi extends BaseAPI {
    /**
     * Returns all available user types in the system
     * @summary Get user types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTypesApi
     */
    public getUserTypes(options?: RawAxiosRequestConfig) {
        return UserTypesApiFp(this.configuration).getUserTypes(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/activate-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {number} userId ID of the user to add skills to
         * @param {Array<UserSkill>} userSkill List of skills to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserSkills: async (userId: number, userSkill: Array<UserSkill>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserSkills', 'userId', userId)
            // verify required parameter 'userSkill' is not null or undefined
            assertParamExists('addUserSkills', 'userSkill', userSkill)
            const localVarPath = `/users/{userId}/skills`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSkill, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPhoneVerificationCodeCommand: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('checkPhoneVerificationCodeCommand', 'userId', userId)
            const localVarPath = `/users/{userId}/phone-code-check`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {number} userId ID of the user whose skill is being endorsed
         * @param {number} skillId ID of the skill being endorsed
         * @param {SkillEndorsement} skillEndorsement Endorsement details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endorseUserSkill: async (userId: number, skillId: number, skillEndorsement: SkillEndorsement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('endorseUserSkill', 'userId', userId)
            // verify required parameter 'skillId' is not null or undefined
            assertParamExists('endorseUserSkill', 'skillId', skillId)
            // verify required parameter 'skillEndorsement' is not null or undefined
            assertParamExists('endorseUserSkill', 'skillEndorsement', skillEndorsement)
            const localVarPath = `/users/{userId}/skills/{skillId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"skillId"}}`, encodeURIComponent(String(skillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(skillEndorsement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/fetch-random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('find1', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {string} [profileName] User\&#39;s profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find2: async (profileName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (profileName !== undefined) {
                localVarQueryParameter['profileName'] = profileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {string} userIds Comma-separated list of user IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findList: async (userIds: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIds' is not null or undefined
            assertParamExists('findList', 'userIds', userIds)
            const localVarPath = `/users/list/{userIds}`
                .replace(`{${"userIds"}}`, encodeURIComponent(String(userIds)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {string} [propertyPublicationState] 
         * @param {string} [xmlId] 
         * @param {string} [aPIVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertiesByUser: async (id: string, pageFrom?: number, pageTo?: number, propertyPublicationState?: string, xmlId?: string, aPIVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findPropertiesByUser', 'id', id)
            const localVarPath = `/users/{id}/properties`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }

            if (propertyPublicationState !== undefined) {
                localVarQueryParameter['propertyPublicationState'] = propertyPublicationState;
            }

            if (xmlId !== undefined) {
                localVarQueryParameter['xmlId'] = xmlId;
            }


    
            if (aPIVersion != null) {
                localVarHeaderParameter['API-Version'] = String(aPIVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the testimonials list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialsByUser: async (id: string, pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findTestimonialsByUser', 'id', id)
            const localVarPath = `/users/{id}/testimonials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections1: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findUserConnections1', 'userId', userId)
            const localVarPath = `/users/{userId}/connections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {string} subscriptionPlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedUsers: async (subscriptionPlanName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionPlanName' is not null or undefined
            assertParamExists('getSubscribedUsers', 'subscriptionPlanName', subscriptionPlanName)
            const localVarPath = `/users/subscribed-users/{subscriptionPlanName}`
                .replace(`{${"subscriptionPlanName"}}`, encodeURIComponent(String(subscriptionPlanName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {number} [id] 
         * @param {string} [lang] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty1: async (id?: number, lang?: string, acceptLanguage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/previews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {string} [origin] 
         * @param {boolean} [skipEmailValidation] Skip email validation step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (origin?: string, skipEmailValidation?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipEmailValidation !== undefined) {
                localVarQueryParameter['skipEmailValidation'] = skipEmailValidation;
            }


    
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {string} [origin] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestActivationLink: async (origin?: string, email?: string, password?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/activation_link_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (email !== undefined) { 
                localVarFormParams.set('email', email as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request testimonial from specified user id
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTestimonialFromUser: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestTestimonialFromUser', 'id', id)
            const localVarPath = `/users/{id}/request-testimonial`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {number} userId ID of the user whose skill endorsements to retrieve
         * @param {number} skillId ID of the skill to retrieve endorsements for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSkillEndorsements: async (userId: number, skillId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveSkillEndorsements', 'userId', userId)
            // verify required parameter 'skillId' is not null or undefined
            assertParamExists('retrieveSkillEndorsements', 'skillId', skillId)
            const localVarPath = `/users/{userId}/skills/{skillId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"skillId"}}`, encodeURIComponent(String(skillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {number} userId ID of the user to retrieve skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills1: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveUserSkills1', 'userId', userId)
            const localVarPath = `/users/{userId}/skills`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {string} [oAuthToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save1: async (oAuthToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (oAuthToken != null) {
                localVarHeaderParameter['O-Auth-Token'] = String(oAuthToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LogEntry} [logEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLog: async (logEntry?: LogEntry, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for users matching the specified filter criteria
         * @summary Search users with specified filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayedSusbscribersAlert: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/weekly-payed-subscribers-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPhoneVerificationCodeCommand: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sendPhoneVerificationCodeCommand', 'userId', userId)
            const localVarPath = `/users/{userId}/phone-code-request`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.activateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {number} userId ID of the user to add skills to
         * @param {Array<UserSkill>} userSkill List of skills to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserSkills(userId: number, userSkill: Array<UserSkill>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserSkills(userId, userSkill, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.addUserSkills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPhoneVerificationCodeCommand(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhoneCodeCheckResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPhoneVerificationCodeCommand(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.checkPhoneVerificationCodeCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {number} userId ID of the user whose skill is being endorsed
         * @param {number} skillId ID of the skill being endorsed
         * @param {SkillEndorsement} skillEndorsement Endorsement details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endorseUserSkill(userId: number, skillId: number, skillEndorsement: SkillEndorsement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkillEndorsement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endorseUserSkill(userId, skillId, skillEndorsement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.endorseUserSkill']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkilledUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.fetchRandomUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find1(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkilledUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.find1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {string} [profileName] User\&#39;s profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find2(profileName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkilledUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find2(profileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.find2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {string} userIds Comma-separated list of user IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findList(userIds: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkilledUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findList(userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {string} [propertyPublicationState] 
         * @param {string} [xmlId] 
         * @param {string} [aPIVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPropertiesByUser(id: string, pageFrom?: number, pageTo?: number, propertyPublicationState?: string, xmlId?: string, aPIVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertiesByUser(id, pageFrom, pageTo, propertyPublicationState, xmlId, aPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findPropertiesByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the testimonials list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialsByUser(id: string, pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonialFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialsByUser(id, pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findTestimonialsByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserConnections1(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkilledUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserConnections1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findUserConnections1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {string} subscriptionPlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscribedUsers(subscriptionPlanName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscribedUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscribedUsers(subscriptionPlanName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getSubscribedUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {number} [id] 
         * @param {string} [lang] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewProperty1(id?: number, lang?: string, acceptLanguage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewProperty1(id, lang, acceptLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.previewProperty1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {string} [origin] 
         * @param {boolean} [skipEmailValidation] Skip email validation step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(origin?: string, skipEmailValidation?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(origin, skipEmailValidation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {string} [origin] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestActivationLink(origin?: string, email?: string, password?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestActivationLink(origin, email, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.requestActivationLink']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request testimonial from specified user id
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTestimonialFromUser(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonialRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTestimonialFromUser(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.requestTestimonialFromUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {number} userId ID of the user whose skill endorsements to retrieve
         * @param {number} skillId ID of the skill to retrieve endorsements for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSkillEndorsements(userId: number, skillId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkillEndorsement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSkillEndorsements(userId, skillId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.retrieveSkillEndorsements']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {number} userId ID of the user to retrieve skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSkills1(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSkills1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.retrieveUserSkills1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {string} [oAuthToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save1(oAuthToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save1(oAuthToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.save1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LogEntry} [logEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveLog(logEntry?: LogEntry, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveLog(logEntry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.saveLog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Searches for users matching the specified filter criteria
         * @summary Search users with specified filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.searchUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPayedSusbscribersAlert(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPayedSusbscribersAlert(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.sendPayedSusbscribersAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPhoneVerificationCodeCommand(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhoneCodeRequestResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPhoneVerificationCodeCommand(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.sendPhoneVerificationCodeCommand']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.activateUser(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {number} userId ID of the user to add skills to
         * @param {Array<UserSkill>} userSkill List of skills to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserSkills(userId: number, userSkill: Array<UserSkill>, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addUserSkills(userId, userSkill, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPhoneVerificationCodeCommand(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<PhoneCodeCheckResource> {
            return localVarFp.checkPhoneVerificationCodeCommand(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {number} userId ID of the user whose skill is being endorsed
         * @param {number} skillId ID of the skill being endorsed
         * @param {SkillEndorsement} skillEndorsement Endorsement details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endorseUserSkill(userId: number, skillId: number, skillEndorsement: SkillEndorsement, options?: RawAxiosRequestConfig): AxiosPromise<SkillEndorsement> {
            return localVarFp.endorseUserSkill(userId, skillId, skillEndorsement, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<SkilledUser>> {
            return localVarFp.fetchRandomUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<SkilledUser> {
            return localVarFp.find1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {string} [profileName] User\&#39;s profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find2(profileName?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SkilledUser>> {
            return localVarFp.find2(profileName, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {string} userIds Comma-separated list of user IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findList(userIds: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SkilledUser>> {
            return localVarFp.findList(userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {string} [propertyPublicationState] 
         * @param {string} [xmlId] 
         * @param {string} [aPIVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertiesByUser(id: string, pageFrom?: number, pageTo?: number, propertyPublicationState?: string, xmlId?: string, aPIVersion?: string, options?: RawAxiosRequestConfig): AxiosPromise<PropertyFilterResult> {
            return localVarFp.findPropertiesByUser(id, pageFrom, pageTo, propertyPublicationState, xmlId, aPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the testimonials list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialsByUser(id: string, pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): AxiosPromise<TestimonialFilterResult> {
            return localVarFp.findTestimonialsByUser(id, pageFrom, pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections1(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SkilledUser>> {
            return localVarFp.findUserConnections1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {string} subscriptionPlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedUsers(subscriptionPlanName: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<SubscribedUser>> {
            return localVarFp.getSubscribedUsers(subscriptionPlanName, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {number} [id] 
         * @param {string} [lang] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty1(id?: number, lang?: string, acceptLanguage?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.previewProperty1(id, lang, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {string} [origin] 
         * @param {boolean} [skipEmailValidation] Skip email validation step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(origin?: string, skipEmailValidation?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.register(origin, skipEmailValidation, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {string} [origin] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestActivationLink(origin?: string, email?: string, password?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.requestActivationLink(origin, email, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request testimonial from specified user id
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTestimonialFromUser(id: string, options?: RawAxiosRequestConfig): AxiosPromise<TestimonialRequest> {
            return localVarFp.requestTestimonialFromUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {number} userId ID of the user whose skill endorsements to retrieve
         * @param {number} skillId ID of the skill to retrieve endorsements for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSkillEndorsements(userId: number, skillId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<SkillEndorsement>> {
            return localVarFp.retrieveSkillEndorsements(userId, skillId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {number} userId ID of the user to retrieve skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills1(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSkill>> {
            return localVarFp.retrieveUserSkills1(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {string} [oAuthToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save1(oAuthToken?: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.save1(oAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LogEntry} [logEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLog(logEntry?: LogEntry, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.saveLog(logEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for users matching the specified filter criteria
         * @summary Search users with specified filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(options?: RawAxiosRequestConfig): AxiosPromise<UserFilterResult> {
            return localVarFp.searchUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayedSusbscribersAlert(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendPayedSusbscribersAlert(options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPhoneVerificationCodeCommand(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<PhoneCodeRequestResource> {
            return localVarFp.sendPhoneVerificationCodeCommand(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Activates a user account using the activation key sent to their email
     * @summary Activate the account of specified user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public activateUser(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).activateUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is not supported. Use save user profile to update skills instead.
     * @summary Add user skills
     * @param {number} userId ID of the user to add skills to
     * @param {Array<UserSkill>} userSkill List of skills to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUserSkills(userId: number, userSkill: Array<UserSkill>, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).addUserSkills(userId, userSkill, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the code that was sent to the user\'s phone
     * @summary Verify the phone code sent to user
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkPhoneVerificationCodeCommand(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkPhoneVerificationCodeCommand(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to endorse another user\'s skill
     * @summary Endorse a user skill
     * @param {number} userId ID of the user whose skill is being endorsed
     * @param {number} skillId ID of the skill being endorsed
     * @param {SkillEndorsement} skillEndorsement Endorsement details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public endorseUserSkill(userId: number, skillId: number, skillEndorsement: SkillEndorsement, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).endorseUserSkill(userId, skillId, skillEndorsement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a random selection of users based on specified criteria
     * @summary Fetch random list of users, with basic data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public fetchRandomUsers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).fetchRandomUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets detailed user information by user ID
     * @summary Fetch user detail according to its id
     * @param {number} userId user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public find1(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).find1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets user information by their unique profile name
     * @summary Fetch user detail according to its profile name
     * @param {string} [profileName] User\&#39;s profile name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public find2(profileName?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).find2(profileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets detailed information for multiple users by their IDs
     * @summary Fetch multiple user detail according to its ids
     * @param {string} userIds Comma-separated list of user IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findList(userIds: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findList(userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the property list with specified user id
     * @param {string} id user id
     * @param {number} [pageFrom] 
     * @param {number} [pageTo] 
     * @param {string} [propertyPublicationState] 
     * @param {string} [xmlId] 
     * @param {string} [aPIVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findPropertiesByUser(id: string, pageFrom?: number, pageTo?: number, propertyPublicationState?: string, xmlId?: string, aPIVersion?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findPropertiesByUser(id, pageFrom, pageTo, propertyPublicationState, xmlId, aPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the testimonials list with specified user id
     * @param {string} id user id
     * @param {number} [pageFrom] 
     * @param {number} [pageTo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findTestimonialsByUser(id: string, pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findTestimonialsByUser(id, pageFrom, pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of connections for a specific user
     * @summary Get a user connections
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUserConnections1(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUserConnections1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all users who have subscribed to the specified subscription plan
     * @summary Gets the users subscribed to a subscription plan name like Professional
     * @param {string} subscriptionPlanName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSubscribedUsers(subscriptionPlanName: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getSubscribedUsers(subscriptionPlanName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of a user profile for sharing purposes
     * @summary Get HTML preview of a user profile
     * @param {number} [id] 
     * @param {string} [lang] 
     * @param {string} [acceptLanguage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public previewProperty1(id?: number, lang?: string, acceptLanguage?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).previewProperty1(id, lang, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user account in the system
     * @summary Register new user in the system
     * @param {string} [origin] 
     * @param {boolean} [skipEmailValidation] Skip email validation step
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public register(origin?: string, skipEmailValidation?: boolean, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).register(origin, skipEmailValidation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an activation link to the user\'s email for account verification
     * @summary Request activation link
     * @param {string} [origin] 
     * @param {string} [email] 
     * @param {string} [password] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public requestActivationLink(origin?: string, email?: string, password?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).requestActivationLink(origin, email, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request testimonial from specified user id
     * @param {string} id user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public requestTestimonialFromUser(id: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).requestTestimonialFromUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all endorsements for a specific user skill
     * @summary Retrieve skill endorsements
     * @param {number} userId ID of the user whose skill endorsements to retrieve
     * @param {number} skillId ID of the skill to retrieve endorsements for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public retrieveSkillEndorsements(userId: number, skillId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).retrieveSkillEndorsements(userId, skillId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all skills associated with a user
     * @summary Retrieve user skills
     * @param {number} userId ID of the user to retrieve skills for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public retrieveUserSkills1(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).retrieveUserSkills1(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates user profile information in the system
     * @summary Save the data of user in the system
     * @param {string} [oAuthToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public save1(oAuthToken?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).save1(oAuthToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LogEntry} [logEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public saveLog(logEntry?: LogEntry, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).saveLog(logEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for users matching the specified filter criteria
     * @summary Search users with specified filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public searchUsers(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).searchUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public sendPayedSusbscribersAlert(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).sendPayedSusbscribersAlert(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a verification code to the user\'s phone number for verification purposes
     * @summary Send a code to the previously saved phone number of the user
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public sendPhoneVerificationCodeCommand(userId: number, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).sendPhoneVerificationCodeCommand(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



