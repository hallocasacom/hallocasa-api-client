/* tslint:disable */
/* eslint-disable */
/**
 * Hallocasa API
 * Hallocasa API Documentation
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Represents an access token used for API authentication and authorization
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * The actual access token value (JWT)
     * @type {string}
     * @memberof AccessToken
     */
    'tokenValue': string;
    /**
     * Date and time when the access token was registered/issued
     * @type {number}
     * @memberof AccessToken
     */
    'registered': number;
    /**
     * Token expiration time in milliseconds from the registered date
     * @type {number}
     * @memberof AccessToken
     */
    'expiresIn': number;
    /**
     * 
     * @type {boolean}
     * @memberof AccessToken
     */
    'expired'?: boolean;
}
/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'formatted'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'line1'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'line2'?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'city'?: string;
    /**
     * 
     * @type {Country}
     * @memberof Address
     */
    'country'?: Country;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    'zipCode'?: string;
}
/**
 * 
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'userAlertType'?: AlertUserAlertTypeEnum;
    /**
     * Alert criteria in JSON format
     * @type {object}
     * @memberof Alert
     */
    'alertCriteria'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof Alert
     */
    'allowBrokerContact'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'lastNotification'?: string;
    /**
     * 
     * @type {string}
     * @memberof Alert
     */
    'createdAt'?: string;
    /**
     * Alert result data in JSON format
     * @type {object}
     * @memberof Alert
     */
    'result'?: object;
    /**
     * 
     * @type {number}
     * @memberof Alert
     */
    'newsletterOwnerId'?: number;
}

export const AlertUserAlertTypeEnum = {
    Property: 'PROPERTY'
} as const;

export type AlertUserAlertTypeEnum = typeof AlertUserAlertTypeEnum[keyof typeof AlertUserAlertTypeEnum];

/**
 * 
 * @export
 * @interface AlertWithUserProfile
 */
export interface AlertWithUserProfile {
    /**
     * 
     * @type {number}
     * @memberof AlertWithUserProfile
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof AlertWithUserProfile
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AlertWithUserProfile
     */
    'userAlertType'?: AlertWithUserProfileUserAlertTypeEnum;
    /**
     * Alert criteria in JSON format
     * @type {object}
     * @memberof AlertWithUserProfile
     */
    'alertCriteria'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof AlertWithUserProfile
     */
    'allowBrokerContact'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AlertWithUserProfile
     */
    'lastNotification'?: string;
    /**
     * 
     * @type {string}
     * @memberof AlertWithUserProfile
     */
    'createdAt'?: string;
    /**
     * Alert result data in JSON format
     * @type {object}
     * @memberof AlertWithUserProfile
     */
    'result'?: object;
    /**
     * Profile name of the user who owns this alert (only included for non-Free subscribers)
     * @type {string}
     * @memberof AlertWithUserProfile
     */
    'userProfileName'?: string;
    /**
     * 
     * @type {number}
     * @memberof AlertWithUserProfile
     */
    'newsletterOwnerId'?: number;
}

export const AlertWithUserProfileUserAlertTypeEnum = {
    Property: 'PROPERTY'
} as const;

export type AlertWithUserProfileUserAlertTypeEnum = typeof AlertWithUserProfileUserAlertTypeEnum[keyof typeof AlertWithUserProfileUserAlertTypeEnum];

/**
 * API Key information
 * @export
 * @interface ApiKeyDto
 */
export interface ApiKeyDto {
    /**
     * API Key ID
     * @type {number}
     * @memberof ApiKeyDto
     */
    'id'?: number;
    /**
     * User ID
     * @type {number}
     * @memberof ApiKeyDto
     */
    'userId'?: number;
    /**
     * API Key value (only shown when creating)
     * @type {string}
     * @memberof ApiKeyDto
     */
    'apiKey'?: string;
    /**
     * API Key name
     * @type {string}
     * @memberof ApiKeyDto
     */
    'name'?: string;
    /**
     * API Key description
     * @type {string}
     * @memberof ApiKeyDto
     */
    'description'?: string;
    /**
     * Whether the API key is active
     * @type {boolean}
     * @memberof ApiKeyDto
     */
    'isActive'?: boolean;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof ApiKeyDto
     */
    'createdAt'?: string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof ApiKeyDto
     */
    'updatedAt'?: string;
    /**
     * Last used timestamp
     * @type {string}
     * @memberof ApiKeyDto
     */
    'lastUsedAt'?: string;
    /**
     * Expiration timestamp
     * @type {string}
     * @memberof ApiKeyDto
     */
    'expiresAt'?: string;
    /**
     * Masked API key for display (shows first and last 4 characters)
     * @type {string}
     * @memberof ApiKeyDto
     */
    'maskedApiKey'?: string;
}
/**
 * 
 * @export
 * @interface AuthInfoDto
 */
export interface AuthInfoDto {
    /**
     * 
     * @type {UserDto}
     * @memberof AuthInfoDto
     */
    'user'?: UserDto;
    /**
     * 
     * @type {AccessToken}
     * @memberof AuthInfoDto
     */
    'accessToken'?: AccessToken;
    /**
     * 
     * @type {RefreshToken}
     * @memberof AuthInfoDto
     */
    'refreshToken'?: RefreshToken;
}
/**
 * 
 * @export
 * @interface Brokerage
 */
export interface Brokerage {
    /**
     * 
     * @type {number}
     * @memberof Brokerage
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Brokerage
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'updatedAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Brokerage
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface CheckoutSessionDto
 */
export interface CheckoutSessionDto {
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionDto
     */
    'id'?: string;
    /**
     * 
     * @type {SubscriptionPlanDto}
     * @memberof CheckoutSessionDto
     */
    'subscriptionPlan': SubscriptionPlanDto;
    /**
     * 
     * @type {SubscriptionPriceDto}
     * @memberof CheckoutSessionDto
     */
    'price': SubscriptionPriceDto;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionDto
     */
    'status'?: CheckoutSessionDtoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionDto
     */
    'affiliateRefNumber'?: string;
    /**
     * 
     * @type {SubscribedUserDto}
     * @memberof CheckoutSessionDto
     */
    'user': SubscribedUserDto;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionDto
     */
    'successUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof CheckoutSessionDto
     */
    'cancelUrl'?: string;
}

export const CheckoutSessionDtoStatusEnum = {
    InProcess: 'IN_PROCESS',
    Success: 'SUCCESS',
    Canceled: 'CANCELED',
    Failed: 'FAILED'
} as const;

export type CheckoutSessionDtoStatusEnum = typeof CheckoutSessionDtoStatusEnum[keyof typeof CheckoutSessionDtoStatusEnum];

/**
 * Country information
 * @export
 * @interface Country
 */
export interface Country {
    /**
     * Country identifier
     * @type {number}
     * @memberof Country
     */
    'id': number;
    /**
     * Country code (ISO 3166 alpha-2)
     * @type {string}
     * @memberof Country
     */
    'code'?: string;
    /**
     * Country name
     * @type {string}
     * @memberof Country
     */
    'name'?: string;
    /**
     * Language code
     * @type {string}
     * @memberof Country
     */
    'lang'?: string;
    /**
     * 
     * @type {Currency}
     * @memberof Country
     */
    'currency'?: Currency;
    /**
     * Locale code
     * @type {string}
     * @memberof Country
     */
    'locale'?: string;
}
/**
 * 
 * @export
 * @interface CountryPhonePrefix
 */
export interface CountryPhonePrefix {
    /**
     * 
     * @type {number}
     * @memberof CountryPhonePrefix
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CountryPhonePrefix
     */
    'prefix'?: number;
    /**
     * 
     * @type {string}
     * @memberof CountryPhonePrefix
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CountryPhonePrefix
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface CountryTelephonePrefix
 */
export interface CountryTelephonePrefix {
    /**
     * 
     * @type {number}
     * @memberof CountryTelephonePrefix
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof CountryTelephonePrefix
     */
    'prefix'?: number;
    /**
     * 
     * @type {string}
     * @memberof CountryTelephonePrefix
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CountryTelephonePrefix
     */
    'lang'?: string;
}
/**
 * Request to create a new API key
 * @export
 * @interface CreateApiKeyRequestDto
 */
export interface CreateApiKeyRequestDto {
    /**
     * Name for the API key
     * @type {string}
     * @memberof CreateApiKeyRequestDto
     */
    'name': string;
    /**
     * Description of the API key usage
     * @type {string}
     * @memberof CreateApiKeyRequestDto
     */
    'description'?: string;
    /**
     * Optional expiration date for the API key
     * @type {string}
     * @memberof CreateApiKeyRequestDto
     */
    'expiresAt'?: string;
}
/**
 * Currency information
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * Currency identifier
     * @type {number}
     * @memberof Currency
     */
    'id'?: number;
    /**
     * Currency code (ISO 4217)
     * @type {string}
     * @memberof Currency
     */
    'abbreviation'?: string;
    /**
     * Currency name
     * @type {string}
     * @memberof Currency
     */
    'name'?: string;
    /**
     * Language code
     * @type {string}
     * @memberof Currency
     */
    'lang'?: string;
    /**
     * Currency symbol
     * @type {string}
     * @memberof Currency
     */
    'prefix'?: string;
}
/**
 * If minCrcyValue is specified, maxCrcyValue must be specified too. If both are specified, they must have the same currency.
 * @export
 * @interface CurrencyAmmount
 */
export interface CurrencyAmmount {
    /**
     * 
     * @type {Currency}
     * @memberof CurrencyAmmount
     */
    'currency'?: Currency;
    /**
     * 
     * @type {number}
     * @memberof CurrencyAmmount
     */
    'ammount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof CurrencyAmmount
     */
    'valid'?: boolean;
}
/**
 * 
 * @export
 * @interface CustomerSessionDto
 */
export interface CustomerSessionDto {
    /**
     * 
     * @type {string}
     * @memberof CustomerSessionDto
     */
    'id'?: string;
    /**
     * 
     * @type {SubscribedUserDto}
     * @memberof CustomerSessionDto
     */
    'user'?: SubscribedUserDto;
    /**
     * 
     * @type {string}
     * @memberof CustomerSessionDto
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomerSessionDto
     */
    'returnUrl'?: string;
}
/**
 * 
 * @export
 * @interface DropdownOption
 */
export interface DropdownOption {
    /**
     * 
     * @type {number}
     * @memberof DropdownOption
     */
    'optionId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data1'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data2'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data3'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data4'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data5'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data6'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data7'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOption
     */
    'data8'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DropdownOption
     */
    'dependsOnLang'?: boolean;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof DropdownOption
     */
    'parentInfo'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface DropdownOptionGroup
 */
export interface DropdownOptionGroup {
    /**
     * 
     * @type {number}
     * @memberof DropdownOptionGroup
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DropdownOptionGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DropdownOptionGroup
     */
    'translationManagement'?: DropdownOptionGroupTranslationManagementEnum;
    /**
     * 
     * @type {Array<DropdownOption>}
     * @memberof DropdownOptionGroup
     */
    'dropdownOptionList'?: Array<DropdownOption>;
}

export const DropdownOptionGroupTranslationManagementEnum = {
    Total: 'TOTAL',
    Partial: 'PARTIAL',
    None: 'NONE'
} as const;

export type DropdownOptionGroupTranslationManagementEnum = typeof DropdownOptionGroupTranslationManagementEnum[keyof typeof DropdownOptionGroupTranslationManagementEnum];

/**
 * 
 * @export
 * @interface FBPropertyDto
 */
export interface FBPropertyDto {
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'availability'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'latitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'longitude'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'home_listing_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'home_listing_group_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'address.addr1'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'address.city'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'address.region'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'address.country'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'address.postal_code'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'image[0].url'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'num_beds'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'num_baths'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'num_rooms'?: string;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'property_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof FBPropertyDto
     */
    'area_size'?: number;
    /**
     * 
     * @type {string}
     * @memberof FBPropertyDto
     */
    'area_unit'?: string;
}
/**
 * 
 * @export
 * @interface Favorite
 */
export interface Favorite {
    /**
     * 
     * @type {number}
     * @memberof Favorite
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Favorite
     */
    'resourceType': FavoriteResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Favorite
     */
    'resourceId': string;
    /**
     * Resource data in JSON format
     * @type {object}
     * @memberof Favorite
     */
    'resource'?: object;
}

export const FavoriteResourceTypeEnum = {
    Property: 'PROPERTY'
} as const;

export type FavoriteResourceTypeEnum = typeof FavoriteResourceTypeEnum[keyof typeof FavoriteResourceTypeEnum];

/**
 * 
 * @export
 * @interface FeatureDto
 */
export interface FeatureDto {
    /**
     * 
     * @type {number}
     * @memberof FeatureDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeatureDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureDto
     */
    'lang'?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureDto
     */
    'descriptionLang'?: string;
}
/**
 * 
 * @export
 * @interface FilterShowingStep
 */
export interface FilterShowingStep {
    /**
     * 
     * @type {string}
     * @memberof FilterShowingStep
     */
    'sequenceBefore'?: FilterShowingStepSequenceBeforeEnum;
    /**
     * 
     * @type {HcFilterCondition}
     * @memberof FilterShowingStep
     */
    'filterCondition'?: HcFilterCondition;
    /**
     * 
     * @type {string}
     * @memberof FilterShowingStep
     */
    'sequenceAfter'?: FilterShowingStepSequenceAfterEnum;
}

export const FilterShowingStepSequenceBeforeEnum = {
    InitGroup: 'INIT_GROUP',
    EndGroup: 'END_GROUP',
    And: 'AND',
    Or: 'OR'
} as const;

export type FilterShowingStepSequenceBeforeEnum = typeof FilterShowingStepSequenceBeforeEnum[keyof typeof FilterShowingStepSequenceBeforeEnum];
export const FilterShowingStepSequenceAfterEnum = {
    InitGroup: 'INIT_GROUP',
    EndGroup: 'END_GROUP',
    And: 'AND',
    Or: 'OR'
} as const;

export type FilterShowingStepSequenceAfterEnum = typeof FilterShowingStepSequenceAfterEnum[keyof typeof FilterShowingStepSequenceAfterEnum];

/**
 * 
 * @export
 * @interface GeoLocation
 */
export interface GeoLocation {
    /**
     * 
     * @type {number}
     * @memberof GeoLocation
     */
    'latitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof GeoLocation
     */
    'longitude'?: number;
}
/**
 * 
 * @export
 * @interface GeoPlace
 */
export interface GeoPlace {
    /**
     * 
     * @type {GeoLocation}
     * @memberof GeoPlace
     */
    'geoLocation'?: GeoLocation;
    /**
     * 
     * @type {Address}
     * @memberof GeoPlace
     */
    'address'?: Address;
}
/**
 * 
 * @export
 * @interface GooglePlaceReview
 */
export interface GooglePlaceReview {
    /**
     * 
     * @type {string}
     * @memberof GooglePlaceReview
     */
    'authorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof GooglePlaceReview
     */
    'authorUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof GooglePlaceReview
     */
    'language'?: string;
    /**
     * 
     * @type {string}
     * @memberof GooglePlaceReview
     */
    'originalLanguage'?: string;
    /**
     * 
     * @type {string}
     * @memberof GooglePlaceReview
     */
    'profilePhotoUrl'?: string;
    /**
     * 
     * @type {number}
     * @memberof GooglePlaceReview
     */
    'rating'?: number;
    /**
     * 
     * @type {string}
     * @memberof GooglePlaceReview
     */
    'relativeTimeDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof GooglePlaceReview
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof GooglePlaceReview
     */
    'time'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GooglePlaceReview
     */
    'translated'?: boolean;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof Group
     */
    'owner'?: User;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'locationLatitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'locationLongitude'?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'locationName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'locationDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'backgroundImage'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'creationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'groupStatus'?: GroupGroupStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'groupType'?: GroupGroupTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'requestStatus'?: GroupRequestStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'backgroundImageBase64'?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'logoImageBase64'?: string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'noOfMembers'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'userAdmin'?: boolean;
}

export const GroupGroupStatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED',
    Deleted: 'DELETED'
} as const;

export type GroupGroupStatusEnum = typeof GroupGroupStatusEnum[keyof typeof GroupGroupStatusEnum];
export const GroupGroupTypeEnum = {
    Group: 'GROUP',
    Association: 'ASSOCIATION',
    Certification: 'CERTIFICATION'
} as const;

export type GroupGroupTypeEnum = typeof GroupGroupTypeEnum[keyof typeof GroupGroupTypeEnum];
export const GroupRequestStatusEnum = {
    None: 'NONE',
    RequestingAssociation: 'REQUESTING_ASSOCIATION',
    RequestingCertification: 'REQUESTING_CERTIFICATION'
} as const;

export type GroupRequestStatusEnum = typeof GroupRequestStatusEnum[keyof typeof GroupRequestStatusEnum];

/**
 * 
 * @export
 * @interface GroupFilterResult
 */
export interface GroupFilterResult {
    /**
     * 
     * @type {number}
     * @memberof GroupFilterResult
     */
    'count'?: number;
    /**
     * 
     * @type {Array<Group>}
     * @memberof GroupFilterResult
     */
    'list'?: Array<Group>;
}
/**
 * 
 * @export
 * @interface GroupMember
 */
export interface GroupMember {
    /**
     * 
     * @type {number}
     * @memberof GroupMember
     */
    'id'?: number;
    /**
     * 
     * @type {User}
     * @memberof GroupMember
     */
    'user'?: User;
    /**
     * 
     * @type {Group}
     * @memberof GroupMember
     */
    'group'?: Group;
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'creationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupMember
     */
    'groupMemberStatus'?: GroupMemberGroupMemberStatusEnum;
}

export const GroupMemberGroupMemberStatusEnum = {
    Invited: 'INVITED',
    Requested: 'REQUESTED',
    Accepted: 'ACCEPTED',
    Admin: 'ADMIN',
    Rejected: 'REJECTED',
    Removed: 'REMOVED',
    Left: 'LEFT'
} as const;

export type GroupMemberGroupMemberStatusEnum = typeof GroupMemberGroupMemberStatusEnum[keyof typeof GroupMemberGroupMemberStatusEnum];

/**
 * 
 * @export
 * @interface GroupMemberFilterResult
 */
export interface GroupMemberFilterResult {
    /**
     * 
     * @type {number}
     * @memberof GroupMemberFilterResult
     */
    'count'?: number;
    /**
     * 
     * @type {Array<GroupMember>}
     * @memberof GroupMemberFilterResult
     */
    'list'?: Array<GroupMember>;
}
/**
 * The parent filter of the current filter. If the current filter has a parent filter
 * @export
 * @interface HcFilter
 */
export interface HcFilter {
    /**
     * 
     * @type {string}
     * @memberof HcFilter
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HcFilter
     */
    'lang'?: string;
    /**
     * 
     * @type {HcFilterType}
     * @memberof HcFilter
     */
    'filterType'?: HcFilterType;
    /**
     * 
     * @type {HcFilterNature}
     * @memberof HcFilter
     */
    'filterNature'?: HcFilterNature;
    /**
     * 
     * @type {Array<FilterShowingStep>}
     * @memberof HcFilter
     */
    'showingStepList'?: Array<FilterShowingStep>;
    /**
     * 
     * @type {HcFilter}
     * @memberof HcFilter
     */
    'parentFilter'?: HcFilter;
    /**
     * 
     * @type {string}
     * @memberof HcFilter
     */
    'choice'?: HcFilterChoiceEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilter
     */
    'usePropertyField'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HcFilter
     */
    'filterWorkerOption'?: HcFilterFilterWorkerOptionEnum;
    /**
     * 
     * @type {string}
     * @memberof HcFilter
     */
    'hcListerOption'?: HcFilterHcListerOptionEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilter
     */
    'useStaticFilterOptions'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilter
     */
    'forceAllFilterOptions'?: boolean;
    /**
     * id = 1 requires the appliance of the parent filter with id = 35
     * @type {number}
     * @memberof HcFilter
     */
    'id'?: number;
}

export const HcFilterChoiceEnum = {
    Show: 'SHOW',
    Hide: 'HIDE'
} as const;

export type HcFilterChoiceEnum = typeof HcFilterChoiceEnum[keyof typeof HcFilterChoiceEnum];
export const HcFilterFilterWorkerOptionEnum = {
    PropertyLocationKey: 'PROPERTY_LOCATION_KEY',
    CountryKey: 'COUNTRY_KEY',
    PropertyProposalKey: 'PROPERTY_PROPOSAL_KEY',
    Range: 'RANGE',
    Dropdown: 'DROPDOWN',
    Boolean: 'BOOLEAN',
    CurrencyRange: 'CURRENCY_RANGE',
    Roi: 'ROI',
    FreeText: 'FREE_TEXT',
    Id: 'ID',
    PublicationState: 'PUBLICATION_STATE',
    PublicationDate: 'PUBLICATION_DATE',
    GeolocationArea: 'GEOLOCATION_AREA',
    Groups: 'GROUPS',
    UserId: 'USER_ID',
    XmlId: 'XML_ID'
} as const;

export type HcFilterFilterWorkerOptionEnum = typeof HcFilterFilterWorkerOptionEnum[keyof typeof HcFilterFilterWorkerOptionEnum];
export const HcFilterHcListerOptionEnum = {
    PropertyType: 'PROPERTY_TYPE'
} as const;

export type HcFilterHcListerOptionEnum = typeof HcFilterHcListerOptionEnum[keyof typeof HcFilterHcListerOptionEnum];

/**
 * 
 * @export
 * @interface HcFilterCondition
 */
export interface HcFilterCondition {
    /**
     * 
     * @type {number}
     * @memberof HcFilterCondition
     */
    'filterId'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'searchSpecific'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'containsAtLeastOne'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'containsAll'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'containsNumber'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof HcFilterCondition
     */
    'number'?: number;
    /**
     * 
     * @type {number}
     * @memberof HcFilterCondition
     */
    'selectedNumberAny'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilterCondition
     */
    'minOperand'?: HcFilterConditionMinOperandEnum;
    /**
     * 
     * @type {string}
     * @memberof HcFilterCondition
     */
    'maxOperand'?: HcFilterConditionMaxOperandEnum;
    /**
     * 
     * @type {number}
     * @memberof HcFilterCondition
     */
    'minValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof HcFilterCondition
     */
    'maxValue'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'applyMinConstraint'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'applyMaxConstraint'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterCondition
     */
    'apply'?: boolean;
}

export const HcFilterConditionMinOperandEnum = {
    Gt: 'GT',
    Get: 'GET',
    Eq: 'EQ',
    Lt: 'LT',
    Let: 'LET'
} as const;

export type HcFilterConditionMinOperandEnum = typeof HcFilterConditionMinOperandEnum[keyof typeof HcFilterConditionMinOperandEnum];
export const HcFilterConditionMaxOperandEnum = {
    Gt: 'GT',
    Get: 'GET',
    Eq: 'EQ',
    Lt: 'LT',
    Let: 'LET'
} as const;

export type HcFilterConditionMaxOperandEnum = typeof HcFilterConditionMaxOperandEnum[keyof typeof HcFilterConditionMaxOperandEnum];

/**
 * 
 * @export
 * @interface HcFilterEntry
 */
export interface HcFilterEntry {
    /**
     * 
     * @type {number}
     * @memberof HcFilterEntry
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'lang'?: string;
    /**
     * 
     * @type {HcFilterTypeEntry}
     * @memberof HcFilterEntry
     */
    'filterType'?: HcFilterTypeEntry;
    /**
     * 
     * @type {HcFilterNature}
     * @memberof HcFilterEntry
     */
    'filterNature'?: HcFilterNature;
    /**
     * 
     * @type {Array<FilterShowingStep>}
     * @memberof HcFilterEntry
     */
    'showingStepList'?: Array<FilterShowingStep>;
    /**
     * 
     * @type {HcFilter}
     * @memberof HcFilterEntry
     */
    'parentFilter'?: HcFilter;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'choice'?: HcFilterEntryChoiceEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'usePropertyField'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'filterWorkerOption'?: HcFilterEntryFilterWorkerOptionEnum;
    /**
     * 
     * @type {number}
     * @memberof HcFilterEntry
     */
    'minValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof HcFilterEntry
     */
    'maxValue'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'minValueDateInPast'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'minValueDateInFuture'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'maxValueDateInPast'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'maxValueDateInFuture'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'useStaticFilterOptions'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterEntry
     */
    'forceAllFilterOptions'?: boolean;
    /**
     * 
     * @type {DropdownOptionGroup}
     * @memberof HcFilterEntry
     */
    'dropdownOptionGroup'?: DropdownOptionGroup;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'yesText'?: string;
    /**
     * 
     * @type {string}
     * @memberof HcFilterEntry
     */
    'noText'?: string;
}

export const HcFilterEntryChoiceEnum = {
    Show: 'SHOW',
    Hide: 'HIDE'
} as const;

export type HcFilterEntryChoiceEnum = typeof HcFilterEntryChoiceEnum[keyof typeof HcFilterEntryChoiceEnum];
export const HcFilterEntryFilterWorkerOptionEnum = {
    PropertyLocationKey: 'PROPERTY_LOCATION_KEY',
    CountryKey: 'COUNTRY_KEY',
    PropertyProposalKey: 'PROPERTY_PROPOSAL_KEY',
    Range: 'RANGE',
    Dropdown: 'DROPDOWN',
    Boolean: 'BOOLEAN',
    CurrencyRange: 'CURRENCY_RANGE',
    Roi: 'ROI',
    FreeText: 'FREE_TEXT',
    Id: 'ID',
    PublicationState: 'PUBLICATION_STATE',
    PublicationDate: 'PUBLICATION_DATE',
    GeolocationArea: 'GEOLOCATION_AREA',
    Groups: 'GROUPS',
    UserId: 'USER_ID',
    XmlId: 'XML_ID'
} as const;

export type HcFilterEntryFilterWorkerOptionEnum = typeof HcFilterEntryFilterWorkerOptionEnum[keyof typeof HcFilterEntryFilterWorkerOptionEnum];

/**
 * 
 * @export
 * @interface HcFilterNature
 */
export interface HcFilterNature {
    /**
     * 
     * @type {number}
     * @memberof HcFilterNature
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilterNature
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface HcFilterType
 */
export interface HcFilterType {
    /**
     * 
     * @type {number}
     * @memberof HcFilterType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilterType
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HcFilterType
     */
    'filterTypeNature'?: HcFilterTypeFilterTypeNatureEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useSlider'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'validateMin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'validateMax'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'allowMultiple'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useSearch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useSort'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useSelectAll'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useRemoteList'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useLinks'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useYesNoDropdown'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useCheckbox'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useRadio'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'useText'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'toggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'sortSign'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'rangeOnlyFrom'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterType
     */
    'rangeOnlyTo'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HcFilterType
     */
    'rangeFieldPresentation'?: HcFilterTypeRangeFieldPresentationEnum;
}

export const HcFilterTypeFilterTypeNatureEnum = {
    Dropdown: 'DROPDOWN',
    Yesno: 'YESNO',
    Range: 'RANGE',
    Text: 'TEXT',
    AreaRange: 'AREA_RANGE'
} as const;

export type HcFilterTypeFilterTypeNatureEnum = typeof HcFilterTypeFilterTypeNatureEnum[keyof typeof HcFilterTypeFilterTypeNatureEnum];
export const HcFilterTypeRangeFieldPresentationEnum = {
    Integer: 'INTEGER',
    Double: 'DOUBLE',
    Currency: 'CURRENCY',
    Date: 'DATE'
} as const;

export type HcFilterTypeRangeFieldPresentationEnum = typeof HcFilterTypeRangeFieldPresentationEnum[keyof typeof HcFilterTypeRangeFieldPresentationEnum];

/**
 * 
 * @export
 * @interface HcFilterTypeEntry
 */
export interface HcFilterTypeEntry {
    /**
     * 
     * @type {number}
     * @memberof HcFilterTypeEntry
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof HcFilterTypeEntry
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof HcFilterTypeEntry
     */
    'filterTypeNature'?: HcFilterTypeEntryFilterTypeNatureEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useSlider'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'onlyFrom'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'onlyTo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'validateMin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'validateMax'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HcFilterTypeEntry
     */
    'rangeFieldPresentation'?: HcFilterTypeEntryRangeFieldPresentationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'allowMultiple'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useSearch'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useSort'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useSelectAll'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useRemoteList'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useLinks'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useYesNoDropdown'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useCheckbox'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useRadio'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'useText'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'toggle'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof HcFilterTypeEntry
     */
    'sortSign'?: boolean;
}

export const HcFilterTypeEntryFilterTypeNatureEnum = {
    Dropdown: 'DROPDOWN',
    Yesno: 'YESNO',
    Range: 'RANGE',
    Text: 'TEXT',
    AreaRange: 'AREA_RANGE'
} as const;

export type HcFilterTypeEntryFilterTypeNatureEnum = typeof HcFilterTypeEntryFilterTypeNatureEnum[keyof typeof HcFilterTypeEntryFilterTypeNatureEnum];
export const HcFilterTypeEntryRangeFieldPresentationEnum = {
    Integer: 'INTEGER',
    Double: 'DOUBLE',
    Currency: 'CURRENCY',
    Date: 'DATE'
} as const;

export type HcFilterTypeEntryRangeFieldPresentationEnum = typeof HcFilterTypeEntryRangeFieldPresentationEnum[keyof typeof HcFilterTypeEntryRangeFieldPresentationEnum];

/**
 * 
 * @export
 * @interface IdentityVerificationCheckRequest
 */
export interface IdentityVerificationCheckRequest {
    /**
     * 
     * @type {string}
     * @memberof IdentityVerificationCheckRequest
     */
    'verificationSessionId': string;
}
/**
 * 
 * @export
 * @interface IdentityVerificationStartResponse
 */
export interface IdentityVerificationStartResponse {
    /**
     * 
     * @type {string}
     * @memberof IdentityVerificationStartResponse
     */
    'verificationUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof IdentityVerificationStartResponse
     */
    'verificationSessionId'?: string;
}
/**
 * 
 * @export
 * @interface Language
 */
export interface Language {
    /**
     * 
     * @type {number}
     * @memberof Language
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Language
     */
    'locale'?: string;
}
/**
 * 
 * @export
 * @interface LocaleSet
 */
export interface LocaleSet {
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'pnemonic'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'enUS'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'esES'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'deDE'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'zhCN'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'ruRU'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'frFR'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'ptPT'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'itIT'?: string;
    /**
     * 
     * @type {string}
     * @memberof LocaleSet
     */
    'jaJP'?: string;
}
/**
 * 
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'module'?: string;
    /**
     * 
     * @type {string}
     * @memberof LogEntry
     */
    'description'?: string;
}
/**
 * Newsletter subscriber information
 * @export
 * @interface NewsletterSubscriberDto
 */
export interface NewsletterSubscriberDto {
    /**
     * 
     * @type {Alert}
     * @memberof NewsletterSubscriberDto
     */
    'alert'?: Alert;
    /**
     * 
     * @type {SkilledUser}
     * @memberof NewsletterSubscriberDto
     */
    'user'?: SkilledUser;
}
/**
 * Request object for password recovery operations
 * @export
 * @interface PasswordRecoveryRequest
 */
export interface PasswordRecoveryRequest {
    /**
     * New password to set for the user
     * @type {string}
     * @memberof PasswordRecoveryRequest
     */
    'newPassword': string;
    /**
     * 
     * @type {PasswordRecoveryToken}
     * @memberof PasswordRecoveryRequest
     */
    'passwordRecoveryToken': PasswordRecoveryToken;
}
/**
 * Token used for password recovery process
 * @export
 * @interface PasswordRecoveryToken
 */
export interface PasswordRecoveryToken {
    /**
     * Unique identifier for the token
     * @type {number}
     * @memberof PasswordRecoveryToken
     */
    'id'?: number;
    /**
     * ID of the associated user
     * @type {number}
     * @memberof PasswordRecoveryToken
     */
    'idAssociated'?: number;
    /**
     * Token content that is sent in the recovery email
     * @type {string}
     * @memberof PasswordRecoveryToken
     */
    'tokenContent': string;
    /**
     * Expiration date of the token
     * @type {string}
     * @memberof PasswordRecoveryToken
     */
    'dueDate'?: string;
    /**
     * Whether the token is active or already used
     * @type {boolean}
     * @memberof PasswordRecoveryToken
     */
    'active'?: boolean;
    /**
     * Date when the token was created
     * @type {string}
     * @memberof PasswordRecoveryToken
     */
    'expeditionDate'?: string;
}
/**
 * 
 * @export
 * @interface PhoneCodeCheckResource
 */
export interface PhoneCodeCheckResource {
    /**
     * 
     * @type {string}
     * @memberof PhoneCodeCheckResource
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface PhoneCodeRequestResource
 */
export interface PhoneCodeRequestResource {
    /**
     * 
     * @type {string}
     * @memberof PhoneCodeRequestResource
     */
    'verificationType': string;
}
/**
 * 
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'id'?: string;
    /**
     * 
     * @type {User}
     * @memberof Property
     */
    'user': User;
    /**
     * 
     * @type {PropertyType}
     * @memberof Property
     */
    'propertyType'?: PropertyType;
    /**
     * 
     * @type {PropertyLocation}
     * @memberof Property
     */
    'propertyLocation'?: PropertyLocation;
    /**
     * 
     * @type {PropertyProposal}
     * @memberof Property
     */
    'propertyProposal'?: PropertyProposal;
    /**
     * 
     * @type {Country}
     * @memberof Property
     */
    'country'?: Country;
    /**
     * 
     * @type {PropertyKey}
     * @memberof Property
     */
    'propertyKey'?: PropertyKey;
    /**
     * 
     * @type {Array<PropertyField>}
     * @memberof Property
     */
    'fieldList'?: Array<PropertyField>;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'publishDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'modifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'publicationState'?: PropertyPublicationStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'isPrivate'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'isDraft'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Property
     */
    'groupIds'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'shouldPublishEmailsToGroups'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Property
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Property
     */
    'isPasswordProtected'?: boolean;
}

export const PropertyPublicationStateEnum = {
    Available: 'AVAILABLE',
    Rented: 'RENTED',
    Sold: 'SOLD',
    Draft: 'DRAFT'
} as const;

export type PropertyPublicationStateEnum = typeof PropertyPublicationStateEnum[keyof typeof PropertyPublicationStateEnum];

/**
 * The property field which is needed for the filterWorkerOption: RANGE, DROPDOWN, BOOLEAN and CURRENCY_RANGE
 * @export
 * @interface PropertyField
 */
export interface PropertyField {
    /**
     * 
     * @type {number}
     * @memberof PropertyField
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'lang'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyField
     */
    'basic'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyField
     */
    'primaryKey'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyField
     */
    'multilanguageValue'?: boolean;
    /**
     * 
     * @type {PropertyFieldType}
     * @memberof PropertyField
     */
    'propertyFieldType'?: PropertyFieldType;
    /**
     * 
     * @type {PropertyFieldValueType}
     * @memberof PropertyField
     */
    'propertyFieldValueType'?: PropertyFieldValueType;
    /**
     * 
     * @type {Array<PropertyFieldValue>}
     * @memberof PropertyField
     */
    'fieldValueList'?: Array<PropertyFieldValue>;
    /**
     * 
     * @type {DropdownOptionGroup}
     * @memberof PropertyField
     */
    'dropdownOptionGroup'?: DropdownOptionGroup;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'tooltipLang'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'textType'?: PropertyFieldTextTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'data1Type'?: PropertyFieldData1TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'data2Type'?: PropertyFieldData2TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'data3Type'?: PropertyFieldData3TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PropertyField
     */
    'hcListerOption'?: PropertyFieldHcListerOptionEnum;
}

export const PropertyFieldTextTypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
} as const;

export type PropertyFieldTextTypeEnum = typeof PropertyFieldTextTypeEnum[keyof typeof PropertyFieldTextTypeEnum];
export const PropertyFieldData1TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
} as const;

export type PropertyFieldData1TypeEnum = typeof PropertyFieldData1TypeEnum[keyof typeof PropertyFieldData1TypeEnum];
export const PropertyFieldData2TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
} as const;

export type PropertyFieldData2TypeEnum = typeof PropertyFieldData2TypeEnum[keyof typeof PropertyFieldData2TypeEnum];
export const PropertyFieldData3TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
} as const;

export type PropertyFieldData3TypeEnum = typeof PropertyFieldData3TypeEnum[keyof typeof PropertyFieldData3TypeEnum];
export const PropertyFieldHcListerOptionEnum = {
    PropertyType: 'PROPERTY_TYPE'
} as const;

export type PropertyFieldHcListerOptionEnum = typeof PropertyFieldHcListerOptionEnum[keyof typeof PropertyFieldHcListerOptionEnum];

/**
 * 
 * @export
 * @interface PropertyFieldType
 */
export interface PropertyFieldType {
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyFieldType
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PropertyFieldValue
 */
export interface PropertyFieldValue {
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValue
     */
    'bdid'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValue
     */
    'identifier'?: number;
    /**
     * 
     * @type {PropertyFieldValueSpec}
     * @memberof PropertyFieldValue
     */
    'text'?: PropertyFieldValueSpec;
    /**
     * 
     * @type {PropertyFieldValueSpec}
     * @memberof PropertyFieldValue
     */
    'data1'?: PropertyFieldValueSpec;
    /**
     * 
     * @type {PropertyFieldValueSpec}
     * @memberof PropertyFieldValue
     */
    'data2'?: PropertyFieldValueSpec;
    /**
     * 
     * @type {PropertyFieldValueSpec}
     * @memberof PropertyFieldValue
     */
    'data3'?: PropertyFieldValueSpec;
}
/**
 * 
 * @export
 * @interface PropertyFieldValueSpec
 */
export interface PropertyFieldValueSpec {
    /**
     * 
     * @type {string}
     * @memberof PropertyFieldValueSpec
     */
    'strVal'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyFieldValueSpec
     */
    'boolVal'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PropertyFieldValueSpec
     */
    'dateVal'?: string;
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValueSpec
     */
    'doubleVal'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValueSpec
     */
    'intVal'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValueSpec
     */
    'bigIntVal'?: number;
}
/**
 * 
 * @export
 * @interface PropertyFieldValueType
 */
export interface PropertyFieldValueType {
    /**
     * 
     * @type {number}
     * @memberof PropertyFieldValueType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyFieldValueType
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PropertyFilter
 */
export interface PropertyFilter {
    /**
     * 
     * @type {HcFilter}
     * @memberof PropertyFilter
     */
    'filter'?: HcFilter;
    /**
     * 
     * @type {PropertyField}
     * @memberof PropertyFilter
     */
    'propertyField'?: PropertyField;
    /**
     * 
     * @type {boolean}
     * @memberof PropertyFilter
     */
    'validForFiltering'?: boolean;
}
/**
 * 
 * @export
 * @interface PropertyFilterCriteria
 */
export interface PropertyFilterCriteria {
    /**
     * 
     * @type {Array<PropertyFilterSubmission>}
     * @memberof PropertyFilterCriteria
     */
    'filterList'?: Array<PropertyFilterSubmission>;
    /**
     * 
     * @type {ResultRequest}
     * @memberof PropertyFilterCriteria
     */
    'resultRequest'?: ResultRequest;
}
/**
 * Must not be null
 * @export
 * @interface PropertyFilterEntry
 */
export interface PropertyFilterEntry {
    /**
     * 
     * @type {HcFilterEntry}
     * @memberof PropertyFilterEntry
     */
    'filter': HcFilterEntry;
    /**
     * 
     * @type {PropertyField}
     * @memberof PropertyFilterEntry
     */
    'propertyField'?: PropertyField;
}
/**
 * Result of property filtering operation containing count and list of properties
 * @export
 * @interface PropertyFilterResult
 */
export interface PropertyFilterResult {
    /**
     * Total number of properties matching the filter criteria
     * @type {number}
     * @memberof PropertyFilterResult
     */
    'count'?: number;
    /**
     * List of properties matching the filter criteria
     * @type {Array<Property>}
     * @memberof PropertyFilterResult
     */
    'propertyList'?: Array<Property>;
}
/**
 * 
 * @export
 * @interface PropertyFilterSubmission
 */
export interface PropertyFilterSubmission {
    /**
     * 
     * @type {boolean}
     * @memberof PropertyFilterSubmission
     */
    'apply'?: boolean;
    /**
     * 
     * @type {PropertyFilterEntry}
     * @memberof PropertyFilterSubmission
     */
    'propertyFilter': PropertyFilterEntry;
    /**
     * minValue is being used for the filterWorkerOption RANGE
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'minValue'?: number;
    /**
     * maxValue is being used for the filterWorkerOption RANGE
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'maxValue'?: number;
    /**
     * minDateValue is being used for the filterWorkerOption PUBLICATION_DATE
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'minDateValue'?: string;
    /**
     * maxDateValue is being used for the filterWorkerOption PUBLICATION_DATE
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'maxDateValue'?: string;
    /**
     * 
     * @type {CurrencyAmmount}
     * @memberof PropertyFilterSubmission
     */
    'minCrcyValue'?: CurrencyAmmount;
    /**
     * 
     * @type {CurrencyAmmount}
     * @memberof PropertyFilterSubmission
     */
    'maxCrcyValue'?: CurrencyAmmount;
    /**
     * minLocalDateTimeValue is being used for the filterWorkerOption PUBLICATION_DATE
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'minLocalDateTimeValue'?: string;
    /**
     * maxLocalDateTimeValue is being used for the filterWorkerOption PUBLICATION_DATE
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'maxLocalDateTimeValue'?: string;
    /**
     * latitudeValue is being used for the filterWorkerOption GEOLOCATION_AREA
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'latitudeValue'?: number;
    /**
     * longitudeValue is being used for the filterWorkerOption GEOLOCATION_AREA
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'longitudeValue'?: number;
    /**
     * Radius value in meters. Is being used for the filterWorkerOption GEOLOCATION_AREA
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'radiusValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PropertyFilterSubmission
     */
    'userId'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'xmlId'?: string;
    /**
     * Make sure freeText is UTF-8 encoded. freeText is being used for the filterWorkerOption FREE_TEXT
     * @type {string}
     * @memberof PropertyFilterSubmission
     */
    'freeText'?: string;
    /**
     * 
     * @type {Array<DropdownOption>}
     * @memberof PropertyFilterSubmission
     */
    'selectedFilterOptions'?: Array<DropdownOption>;
}
/**
 * 
 * @export
 * @interface PropertyKey
 */
export interface PropertyKey {
    /**
     * 
     * @type {PropertyType}
     * @memberof PropertyKey
     */
    'propertyType': PropertyType;
    /**
     * 
     * @type {PropertyLocation}
     * @memberof PropertyKey
     */
    'propertyLocation': PropertyLocation;
    /**
     * 
     * @type {PropertyProposal}
     * @memberof PropertyKey
     */
    'propertyProposal': PropertyProposal;
    /**
     * 
     * @type {Country}
     * @memberof PropertyKey
     */
    'country': Country;
    /**
     * 
     * @type {string}
     * @memberof PropertyKey
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface PropertyLocation
 */
export interface PropertyLocation {
    /**
     * 
     * @type {number}
     * @memberof PropertyLocation
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof PropertyLocation
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyLocation
     */
    'lang'?: string;
}
/**
 * 
 * @export
 * @interface PropertyProposal
 */
export interface PropertyProposal {
    /**
     * 
     * @type {number}
     * @memberof PropertyProposal
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyProposal
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyProposal
     */
    'lang'?: string;
}
/**
 * Request object for updating property publication state
 * @export
 * @interface PropertyPublicationStateRequest
 */
export interface PropertyPublicationStateRequest {
    /**
     * Publication state to set
     * @type {string}
     * @memberof PropertyPublicationStateRequest
     */
    'status': PropertyPublicationStateRequestStatusEnum;
}

export const PropertyPublicationStateRequestStatusEnum = {
    Available: 'AVAILABLE',
    Rented: 'RENTED',
    Sold: 'SOLD',
    Draft: 'DRAFT'
} as const;

export type PropertyPublicationStateRequestStatusEnum = typeof PropertyPublicationStateRequestStatusEnum[keyof typeof PropertyPublicationStateRequestStatusEnum];

/**
 * Property type information
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
    /**
     * Unique identifier for the property type
     * @type {number}
     * @memberof PropertyType
     */
    'id': number;
    /**
     * Name of the property type
     * @type {string}
     * @memberof PropertyType
     */
    'name'?: string;
    /**
     * Language key for internationalization
     * @type {string}
     * @memberof PropertyType
     */
    'lang'?: string;
    /**
     * Whether the property type is active
     * @type {boolean}
     * @memberof PropertyType
     */
    'active'?: boolean;
    /**
     * 
     * @type {PropertyTypeGroup}
     * @memberof PropertyType
     */
    'group'?: PropertyTypeGroup;
}
/**
 * Group for categorizing property types
 * @export
 * @interface PropertyTypeGroup
 */
export interface PropertyTypeGroup {
    /**
     * Unique identifier for the property type group
     * @type {number}
     * @memberof PropertyTypeGroup
     */
    'id'?: number;
    /**
     * Name of the property type group
     * @type {string}
     * @memberof PropertyTypeGroup
     */
    'name'?: string;
}
/**
 * Represents a refresh token used for extending authentication sessions
 * @export
 * @interface RefreshToken
 */
export interface RefreshToken {
    /**
     * The actual refresh token value (JWT)
     * @type {string}
     * @memberof RefreshToken
     */
    'tokenValue': string;
    /**
     * Unique identifier of the user who owns this refresh token
     * @type {string}
     * @memberof RefreshToken
     */
    'email': string;
    /**
     * Identifier of the client application that requested this token
     * @type {string}
     * @memberof RefreshToken
     */
    'clientId': string;
    /**
     * Date and time when the refresh token was issued
     * @type {string}
     * @memberof RefreshToken
     */
    'issued': string;
    /**
     * Date and time when the refresh token expires
     * @type {string}
     * @memberof RefreshToken
     */
    'expires': string;
    /**
     * Whether the refresh token has been revoked/invalidated
     * @type {boolean}
     * @memberof RefreshToken
     */
    'revoked'?: boolean;
    /**
     * Checks if the refresh token is valid (not revoked and not expired)
     * @type {boolean}
     * @memberof RefreshToken
     */
    'valid'?: boolean;
    /**
     * Checks if the refresh token has expired based on current date/time
     * @type {boolean}
     * @memberof RefreshToken
     */
    'expired'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultRequest
 */
export interface ResultRequest {
    /**
     * 
     * @type {number}
     * @memberof ResultRequest
     */
    'pageTo'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ResultRequest
     */
    'orderByMostRecent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResultRequest
     */
    'orderByLessRecent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResultRequest
     */
    'asc'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResultRequest
     */
    'loadCount'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ResultRequest
     */
    'orderBy'?: Array<string>;
    /**
     * Page number to start from (must be >= 1)
     * @type {number}
     * @memberof ResultRequest
     */
    'pageFrom'?: number;
}
/**
 * 
 * @export
 * @interface Skill
 */
export interface Skill {
    /**
     * 
     * @type {number}
     * @memberof Skill
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof Skill
     */
    'locale'?: string;
}
/**
 * 
 * @export
 * @interface SkillEndorsement
 */
export interface SkillEndorsement {
    /**
     * 
     * @type {number}
     * @memberof SkillEndorsement
     */
    'id'?: number;
    /**
     * 
     * @type {SkilledUser}
     * @memberof SkillEndorsement
     */
    'user': SkilledUser;
    /**
     * 
     * @type {SkilledUser}
     * @memberof SkillEndorsement
     */
    'endorser': SkilledUser;
    /**
     * 
     * @type {Skill}
     * @memberof SkillEndorsement
     */
    'skill': Skill;
    /**
     * 
     * @type {string}
     * @memberof SkillEndorsement
     */
    'dateTime'?: string;
}
/**
 * 
 * @export
 * @interface SkilledUser
 */
export interface SkilledUser {
    /**
     * 
     * @type {Language}
     * @memberof SkilledUser
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'confirmedFlag'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'registerDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'webSite'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'linkedIn'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'skype'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'base64Image'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imageLink'?: string;
    /**
     * 
     * @type {Language}
     * @memberof SkilledUser
     */
    'mainSpokenLanguage'?: Language;
    /**
     * 
     * @type {CountryTelephonePrefix}
     * @memberof SkilledUser
     */
    'telephonePrefix'?: CountryTelephonePrefix;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'telephoneNumber'?: string;
    /**
     * 
     * @type {Array<UserType>}
     * @memberof SkilledUser
     */
    'userTypes'?: Array<UserType>;
    /**
     * 
     * @type {Array<UserLanguage>}
     * @memberof SkilledUser
     */
    'userLanguages'?: Array<UserLanguage>;
    /**
     * 
     * @type {Array<UserDescription>}
     * @memberof SkilledUser
     */
    'userDescriptions'?: Array<UserDescription>;
    /**
     * 
     * @type {Array<UserFaq>}
     * @memberof SkilledUser
     */
    'userFaqs'?: Array<UserFaq>;
    /**
     * 
     * @type {Country}
     * @memberof SkilledUser
     */
    'country'?: Country;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'backgroundImageBase64'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'backgroundImageLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'profileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'lastActivity'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'chatStatus'?: string;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'chatsCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'phoneVerified'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'identityVerified'?: boolean;
    /**
     * 
     * @type {GeoPlace}
     * @memberof SkilledUser
     */
    'geoPlace'?: GeoPlace;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'chamberOfCommerceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'facebookUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'instagramUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'twitterUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'wechatUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'vkUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'videoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'bookAnAppointmentUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'googlePlaceId'?: string;
    /**
     * 
     * @type {Array<GooglePlaceReview>}
     * @memberof SkilledUser
     */
    'googlePlaceReviews'?: Array<GooglePlaceReview>;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'googleRating'?: number;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'googleUserRatingsTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'achievementsYearsOfExperience'?: number;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'achievementsDealsClosed'?: number;
    /**
     * 
     * @type {number}
     * @memberof SkilledUser
     */
    'achievementsPercentageOfAllAgents'?: number;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'achievementsGooglePlaceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'focusOnCommercial'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'focusOnResidential'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'focusOnRental'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'focusOnSelling'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imprintTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imprintDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imprintBase64Image'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imprintLogoLink'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'showEmailInProfile'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'showEmailInProperty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'showPhoneInProperty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'allowSaveContact'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'referral'?: string;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'subscriptionPlanName'?: SkilledUserSubscriptionPlanNameEnum;
    /**
     * 
     * @type {boolean}
     * @memberof SkilledUser
     */
    'hidePublicProfile'?: boolean;
    /**
     * 
     * @type {Array<UserSkill>}
     * @memberof SkilledUser
     */
    'skills'?: Array<UserSkill>;
    /**
     * 
     * @type {Brokerage}
     * @memberof SkilledUser
     */
    'brokerage'?: Brokerage;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'groupMemberStatus'?: string;
    /**
     * 
     * @type {Array<UserGroup>}
     * @memberof SkilledUser
     */
    'groups'?: Array<UserGroup>;
    /**
     * 
     * @type {Array<UserOperatingLocation>}
     * @memberof SkilledUser
     */
    'operatingLocations'?: Array<UserOperatingLocation>;
    /**
     * Connection degree to the logged-in user
     * @type {string}
     * @memberof SkilledUser
     */
    'connectionDegree'?: SkilledUserConnectionDegreeEnum;
    /**
     * 
     * @type {string}
     * @memberof SkilledUser
     */
    'imprintImageLink'?: string;
}

export const SkilledUserSubscriptionPlanNameEnum = {
    Free: 'Free',
    Professional: 'Professional',
    Business: 'Business',
    Brokerage: 'Brokerage'
} as const;

export type SkilledUserSubscriptionPlanNameEnum = typeof SkilledUserSubscriptionPlanNameEnum[keyof typeof SkilledUserSubscriptionPlanNameEnum];
export const SkilledUserConnectionDegreeEnum = {
    _1st: '1st',
    _2nd: '2nd',
    _3rd: '3rd+'
} as const;

export type SkilledUserConnectionDegreeEnum = typeof SkilledUserConnectionDegreeEnum[keyof typeof SkilledUserConnectionDegreeEnum];

/**
 * 
 * @export
 * @interface StripeEvent
 */
export interface StripeEvent {
    /**
     * 
     * @type {string}
     * @memberof StripeEvent
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof StripeEvent
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface StripeEventData
 */
export interface StripeEventData {
    /**
     * Stripe event object data in JSON format
     * @type {object}
     * @memberof StripeEventData
     */
    'object'?: object;
    /**
     * Previous attributes of the object before the event
     * @type {object}
     * @memberof StripeEventData
     */
    'previous_attributes'?: object;
}
/**
 * 
 * @export
 * @interface SubscribedUser
 */
export interface SubscribedUser {
    /**
     * 
     * @type {number}
     * @memberof SubscribedUser
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUser
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUser
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUser
     */
    'paymentAppId'?: string;
    /**
     * 
     * @type {Address}
     * @memberof SubscribedUser
     */
    'address'?: Address;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUser
     */
    'created'?: string;
}
/**
 * 
 * @export
 * @interface SubscribedUserDto
 */
export interface SubscribedUserDto {
    /**
     * 
     * @type {number}
     * @memberof SubscribedUserDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscribedUserDto
     */
    'lastName'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionPlanDto
 */
export interface SubscriptionPlanDto {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionPlanDto
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPlanDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPlanDto
     */
    'lang'?: string;
    /**
     * 
     * @type {Array<SubscriptionPlanFeatureDto>}
     * @memberof SubscriptionPlanDto
     */
    'features'?: Array<SubscriptionPlanFeatureDto>;
    /**
     * 
     * @type {Array<SubscriptionPriceDto>}
     * @memberof SubscriptionPlanDto
     */
    'prices'?: Array<SubscriptionPriceDto>;
}
/**
 * 
 * @export
 * @interface SubscriptionPlanFeatureDto
 */
export interface SubscriptionPlanFeatureDto {
    /**
     * 
     * @type {FeatureDto}
     * @memberof SubscriptionPlanFeatureDto
     */
    'feature'?: FeatureDto;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SubscriptionPlanFeatureDto
     */
    'metadata'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface SubscriptionPriceDto
 */
export interface SubscriptionPriceDto {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPriceDto
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionPriceDto
     */
    'price'?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPriceDto
     */
    'currency'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionPriceDto
     */
    'renewalType'?: SubscriptionPriceDtoRenewalTypeEnum;
}

export const SubscriptionPriceDtoRenewalTypeEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Every3Months: 'EVERY_3_MONTHS',
    Every6Months: 'EVERY_6_MONTHS',
    Yearly: 'YEARLY'
} as const;

export type SubscriptionPriceDtoRenewalTypeEnum = typeof SubscriptionPriceDtoRenewalTypeEnum[keyof typeof SubscriptionPriceDtoRenewalTypeEnum];

/**
 * 
 * @export
 * @interface Testimonial
 */
export interface Testimonial {
    /**
     * 
     * @type {number}
     * @memberof Testimonial
     */
    'id'?: number;
    /**
     * 
     * @type {Property}
     * @memberof Testimonial
     */
    'property'?: Property;
    /**
     * 
     * @type {string}
     * @memberof Testimonial
     */
    'publishDate'?: string;
    /**
     * 
     * @type {User}
     * @memberof Testimonial
     */
    'publisher'?: User;
    /**
     * 
     * @type {User}
     * @memberof Testimonial
     */
    'user'?: User;
    /**
     * 
     * @type {string}
     * @memberof Testimonial
     */
    'testimonial'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Testimonial
     */
    'published'?: boolean;
}
/**
 * 
 * @export
 * @interface TestimonialFilterResult
 */
export interface TestimonialFilterResult {
    /**
     * 
     * @type {number}
     * @memberof TestimonialFilterResult
     */
    'count'?: number;
    /**
     * 
     * @type {Array<Testimonial>}
     * @memberof TestimonialFilterResult
     */
    'testimonialList'?: Array<Testimonial>;
}
/**
 * 
 * @export
 * @interface TestimonialRequest
 */
export interface TestimonialRequest {
    /**
     * 
     * @type {number}
     * @memberof TestimonialRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TestimonialRequest
     */
    'creationDate'?: string;
    /**
     * 
     * @type {User}
     * @memberof TestimonialRequest
     */
    'requester'?: User;
    /**
     * 
     * @type {User}
     * @memberof TestimonialRequest
     */
    'user'?: User;
    /**
     * 
     * @type {boolean}
     * @memberof TestimonialRequest
     */
    'requestCompleted'?: boolean;
}
/**
 * 
 * @export
 * @interface TextTranslation
 */
export interface TextTranslation {
    /**
     * 
     * @type {string}
     * @memberof TextTranslation
     */
    'translatedText'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextTranslation
     */
    'translatedLanguage'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextTranslation
     */
    'originalText'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {Language}
     * @memberof User
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'confirmedFlag'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'registerDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'webSite'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'linkedIn'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'skype'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'base64Image'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imageLink'?: string;
    /**
     * 
     * @type {Language}
     * @memberof User
     */
    'mainSpokenLanguage'?: Language;
    /**
     * 
     * @type {CountryTelephonePrefix}
     * @memberof User
     */
    'telephonePrefix'?: CountryTelephonePrefix;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'telephoneNumber'?: string;
    /**
     * 
     * @type {Array<UserType>}
     * @memberof User
     */
    'userTypes'?: Array<UserType>;
    /**
     * 
     * @type {Array<UserLanguage>}
     * @memberof User
     */
    'userLanguages'?: Array<UserLanguage>;
    /**
     * 
     * @type {Array<UserDescription>}
     * @memberof User
     */
    'userDescriptions'?: Array<UserDescription>;
    /**
     * 
     * @type {Array<UserFaq>}
     * @memberof User
     */
    'userFaqs'?: Array<UserFaq>;
    /**
     * 
     * @type {Country}
     * @memberof User
     */
    'country'?: Country;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'backgroundImageBase64'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'backgroundImageLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'profileName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastActivity'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'chatStatus'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'chatsCount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'phoneVerified'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'identityVerified'?: boolean;
    /**
     * 
     * @type {GeoPlace}
     * @memberof User
     */
    'geoPlace'?: GeoPlace;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'chamberOfCommerceUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'facebookUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'instagramUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'twitterUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'wechatUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'vkUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'videoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bookAnAppointmentUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'googlePlaceId'?: string;
    /**
     * 
     * @type {Array<GooglePlaceReview>}
     * @memberof User
     */
    'googlePlaceReviews'?: Array<GooglePlaceReview>;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'googleRating'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'googleUserRatingsTotal'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'achievementsYearsOfExperience'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'achievementsDealsClosed'?: number;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'achievementsPercentageOfAllAgents'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'achievementsGooglePlaceId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'focusOnCommercial'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'focusOnResidential'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'focusOnRental'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'focusOnSelling'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imprintTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imprintDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imprintBase64Image'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imprintLogoLink'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'showEmailInProfile'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'showEmailInProperty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'showPhoneInProperty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'allowSaveContact'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'referral'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'subscriptionPlanName'?: UserSubscriptionPlanNameEnum;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'hidePublicProfile'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'imprintImageLink'?: string;
}

export const UserSubscriptionPlanNameEnum = {
    Free: 'Free',
    Professional: 'Professional',
    Business: 'Business',
    Brokerage: 'Brokerage'
} as const;

export type UserSubscriptionPlanNameEnum = typeof UserSubscriptionPlanNameEnum[keyof typeof UserSubscriptionPlanNameEnum];

/**
 * 
 * @export
 * @interface UserDescription
 */
export interface UserDescription {
    /**
     * 
     * @type {Language}
     * @memberof UserDescription
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof UserDescription
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {number}
     * @memberof UserDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserDto
     */
    'confirmedFlag'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof UserDto
     */
    'subscriptions'?: Array<object>;
    /**
     * 
     * @type {Array<UserPermission>}
     * @memberof UserDto
     */
    'userPermissions'?: Array<UserPermission>;
}
/**
 * 
 * @export
 * @interface UserFaq
 */
export interface UserFaq {
    /**
     * 
     * @type {number}
     * @memberof UserFaq
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserFaq
     */
    'position'?: number;
    /**
     * 
     * @type {Array<UserFaqTranslation>}
     * @memberof UserFaq
     */
    'translations'?: Array<UserFaqTranslation>;
}
/**
 * 
 * @export
 * @interface UserFaqTranslation
 */
export interface UserFaqTranslation {
    /**
     * 
     * @type {Language}
     * @memberof UserFaqTranslation
     */
    'language'?: Language;
    /**
     * 
     * @type {string}
     * @memberof UserFaqTranslation
     */
    'question'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserFaqTranslation
     */
    'answer'?: string;
}
/**
 * Filter request for searching users with various criteria including location, user types, languages, and business focus areas
 * @export
 * @interface UserFilterRequest
 */
export interface UserFilterRequest {
    /**
     * 
     * @type {UserFilterResultSpec}
     * @memberof UserFilterRequest
     */
    'resultRequest': UserFilterResultSpec;
    /**
     * Filter by user name (partial match supported)
     * @type {string}
     * @memberof UserFilterRequest
     */
    'name'?: string;
    /**
     * Filter by countries where users operate
     * @type {Array<Country>}
     * @memberof UserFilterRequest
     */
    'countries'?: Array<Country>;
    /**
     * Latitude for location-based search (must be used with longitude and radius)
     * @type {number}
     * @memberof UserFilterRequest
     */
    'latitude'?: number;
    /**
     * Longitude for location-based search (must be used with latitude and radius)
     * @type {number}
     * @memberof UserFilterRequest
     */
    'longitude'?: number;
    /**
     * Search radius in kilometers for location-based search (must be used with latitude and longitude)
     * @type {number}
     * @memberof UserFilterRequest
     */
    'radius'?: number;
    /**
     * Filter by user types
     * @type {Array<UserType>}
     * @memberof UserFilterRequest
     */
    'userTypes'?: Array<UserType>;
    /**
     * Filter by languages spoken by users
     * @type {Array<Language>}
     * @memberof UserFilterRequest
     */
    'languages'?: Array<Language>;
    /**
     * Filter only users with WhatsApp
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterWhatsApp'?: boolean;
    /**
     * Filter only users with telephone number
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterTelephoneNumber'?: boolean;
    /**
     * Filter only users with Google Place ID
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterGooglePlaceId'?: boolean;
    /**
     * Filter users focused on commercial properties
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterFocusOnCommercial'?: boolean;
    /**
     * Filter users focused on residential properties
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterFocusOnResidential'?: boolean;
    /**
     * Filter users focused on rental properties
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterFocusOnRental'?: boolean;
    /**
     * Filter users focused on selling properties
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterFocusOnSelling'?: boolean;
    /**
     * Filter users with social media presence
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'filterSocial'?: boolean;
    /**
     * Filter by brokerage IDs
     * @type {Array<number>}
     * @memberof UserFilterRequest
     */
    'brokerages'?: Array<number>;
    /**
     * Filter by specific user IDs
     * @type {Array<number>}
     * @memberof UserFilterRequest
     */
    'userIds'?: Array<number>;
    /**
     * Filter by user skills
     * @type {Array<Skill>}
     * @memberof UserFilterRequest
     */
    'skills'?: Array<Skill>;
    /**
     * Include chats count for each user (expensive operation)
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'includeChatsCount'?: boolean;
    /**
     * Include chat status for each user (expensive operation)
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'includeChatStatus'?: boolean;
    /**
     * Include groups for each user (expensive operation)
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'includeGroups'?: boolean;
    /**
     * Include connection degrees when authenticated (expensive operation)
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'includeConnectionDegrees'?: boolean;
    /**
     * Include Google Place reviews for each user (expensive operation)
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'includeGoogleReviews'?: boolean;
    /**
     * Include subscription plan names (expensive operation)
     * @type {boolean}
     * @memberof UserFilterRequest
     */
    'includeSubscriptionPlans'?: boolean;
}
/**
 * 
 * @export
 * @interface UserFilterResult
 */
export interface UserFilterResult {
    /**
     * 
     * @type {number}
     * @memberof UserFilterResult
     */
    'count'?: number;
    /**
     * 
     * @type {Array<SkilledUser>}
     * @memberof UserFilterResult
     */
    'userList'?: Array<SkilledUser>;
}
/**
 * Result specification for pagination and sorting of user search results
 * @export
 * @interface UserFilterResultSpec
 */
export interface UserFilterResultSpec {
    /**
     * 
     * @type {number}
     * @memberof UserFilterResultSpec
     */
    'pageFrom'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserFilterResultSpec
     */
    'pageTo'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'orderByMostRecent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'orderByLessRecent'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'asc'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'loadCount'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserFilterResultSpec
     */
    'orderBy'?: Array<string>;
    /**
     * Sort users by most recent login first
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'orderByMostRecentLogin'?: boolean;
    /**
     * Sort users by least recent login first
     * @type {boolean}
     * @memberof UserFilterResultSpec
     */
    'orderByLessRecentLogin'?: boolean;
}
/**
 * 
 * @export
 * @interface UserGroup
 */
export interface UserGroup {
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    'logo'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    'url'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    'memberStatus'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserGroup
     */
    'owner'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    'joinedDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserGroup
     */
    'ownerId'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    'ownerName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGroup
     */
    'groupType'?: UserGroupGroupTypeEnum;
}

export const UserGroupGroupTypeEnum = {
    Group: 'GROUP',
    Association: 'ASSOCIATION',
    Certification: 'CERTIFICATION'
} as const;

export type UserGroupGroupTypeEnum = typeof UserGroupGroupTypeEnum[keyof typeof UserGroupGroupTypeEnum];

/**
 * 
 * @export
 * @interface UserLanguage
 */
export interface UserLanguage {
    /**
     * 
     * @type {Language}
     * @memberof UserLanguage
     */
    'language'?: Language;
    /**
     * 
     * @type {boolean}
     * @memberof UserLanguage
     */
    'isMainLanguage'?: boolean;
}
/**
 * 
 * @export
 * @interface UserListRequest
 */
export interface UserListRequest {
    /**
     * 
     * @type {number}
     * @memberof UserListRequest
     */
    'userNumber'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof UserListRequest
     */
    'excludeIdList'?: Array<number>;
}
/**
 * 
 * @export
 * @interface UserOperatingLocation
 */
export interface UserOperatingLocation {
    /**
     * 
     * @type {number}
     * @memberof UserOperatingLocation
     */
    'locationNumber'?: number;
    /**
     * 
     * @type {GeoLocation}
     * @memberof UserOperatingLocation
     */
    'geoLocation': GeoLocation;
}
/**
 * 
 * @export
 * @interface UserPermission
 */
export interface UserPermission {
    /**
     * 
     * @type {string}
     * @memberof UserPermission
     */
    'name'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof UserPermission
     */
    'metadata'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface UserSkill
 */
export interface UserSkill {
    /**
     * 
     * @type {Skill}
     * @memberof UserSkill
     */
    'skill': Skill;
    /**
     * 
     * @type {number}
     * @memberof UserSkill
     */
    'endorsementsCount'?: number;
}
/**
 * 
 * @export
 * @interface UserSubscriptionDto
 */
export interface UserSubscriptionDto {
    /**
     * 
     * @type {SubscriptionPlanDto}
     * @memberof UserSubscriptionDto
     */
    'subscriptionPlan'?: SubscriptionPlanDto;
    /**
     * 
     * @type {string}
     * @memberof UserSubscriptionDto
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscriptionDto
     */
    'endDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSubscriptionDto
     */
    'renewalType'?: UserSubscriptionDtoRenewalTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserSubscriptionDto
     */
    'status'?: UserSubscriptionDtoStatusEnum;
}

export const UserSubscriptionDtoRenewalTypeEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Every3Months: 'EVERY_3_MONTHS',
    Every6Months: 'EVERY_6_MONTHS',
    Yearly: 'YEARLY'
} as const;

export type UserSubscriptionDtoRenewalTypeEnum = typeof UserSubscriptionDtoRenewalTypeEnum[keyof typeof UserSubscriptionDtoRenewalTypeEnum];
export const UserSubscriptionDtoStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type UserSubscriptionDtoStatusEnum = typeof UserSubscriptionDtoStatusEnum[keyof typeof UserSubscriptionDtoStatusEnum];

/**
 * 
 * @export
 * @interface UserType
 */
export interface UserType {
    /**
     * 
     * @type {number}
     * @memberof UserType
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserType
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserType
     */
    'lang'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserType
     */
    'tooltipLang'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserType
     */
    'manageTooltip'?: boolean;
}
/**
 * 
 * @export
 * @interface WeeklyAlertRange
 */
export interface WeeklyAlertRange {
    /**
     * 
     * @type {string}
     * @memberof WeeklyAlertRange
     */
    'from'?: string;
    /**
     * 
     * @type {string}
     * @memberof WeeklyAlertRange
     */
    'to'?: string;
}
/**
 * 
 * @export
 * @interface XmlUrl
 */
export interface XmlUrl {
    /**
     * 
     * @type {string}
     * @memberof XmlUrl
     */
    'url': string;
}

/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert1: async (userId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteAlert1', 'userId', userId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('deleteAlert1', 'alertId', alertId)
            const localVarPath = `/users/{userId}/alerts/{alertId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to retrieve results for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertResult1: async (userId: number, alertId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAlertResult1', 'userId', userId)
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('getAlertResult1', 'alertId', alertId)
            const localVarPath = `/users/{userId}/alerts/{alertId}/result`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all alerts from all users in the system. For users with non-Free subscription plans, the response includes their profile name. This is typically an admin-level operation.
         * @summary Get all alerts in the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlerts1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/alerts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {number} userId ID of the user to retrieve alerts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser2: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getByUser2', 'userId', userId)
            const localVarPath = `/users/{userId}/alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {number} userId ID of the user who subscribed to newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterAlerts1: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('newsletterAlerts1', 'userId', userId)
            const localVarPath = `/users/{userId}/alerts/newsletter-alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {number} userId ID of the user who owns the newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterSubscribers1: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('newsletterSubscribers1', 'userId', userId)
            const localVarPath = `/users/{userId}/alerts/newsletter-subscribers`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {number} userId ID of the user to create the alert for
         * @param {Alert} alert Alert to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlert1: async (userId: number, alert: Alert, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('saveAlert1', 'userId', userId)
            // verify required parameter 'alert' is not null or undefined
            assertParamExists('saveAlert1', 'alert', alert)
            const localVarPath = `/users/{userId}/alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(alert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {number} userId ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sendAlert', 'userId', userId)
            const localVarPath = `/users/{userId}/alerts/send-alert`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration)
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert1(userId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert1(userId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.deleteAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to retrieve results for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertResult1(userId: number, alertId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertResult1(userId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.getAlertResult1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all alerts from all users in the system. For users with non-Free subscription plans, the response includes their profile name. This is typically an admin-level operation.
         * @summary Get all alerts in the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllAlerts1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AlertWithUserProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllAlerts1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.getAllAlerts1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {number} userId ID of the user to retrieve alerts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUser2(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Alert>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUser2(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.getByUser2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {number} userId ID of the user who subscribed to newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsletterAlerts1(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NewsletterSubscriberDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsletterAlerts1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.newsletterAlerts1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {number} userId ID of the user who owns the newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsletterSubscribers1(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NewsletterSubscriberDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsletterSubscribers1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.newsletterSubscribers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {number} userId ID of the user to create the alert for
         * @param {Alert} alert Alert to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAlert1(userId: number, alert: Alert, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Alert>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveAlert1(userId, alert, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.saveAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {number} userId ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendAlert(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendAlert(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.sendAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlertsApiFp(configuration)
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {AlertsApiDeleteAlert1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert1(requestParameters: AlertsApiDeleteAlert1Request, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteAlert1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {AlertsApiGetAlertResult1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertResult1(requestParameters: AlertsApiGetAlertResult1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAlertResult1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all alerts from all users in the system. For users with non-Free subscription plans, the response includes their profile name. This is typically an admin-level operation.
         * @summary Get all alerts in the system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllAlerts1(options?: RawAxiosRequestConfig): AxiosPromise<Array<AlertWithUserProfile>> {
            return localVarFp.getAllAlerts1(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {AlertsApiGetByUser2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser2(requestParameters: AlertsApiGetByUser2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Alert>> {
            return localVarFp.getByUser2(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {AlertsApiNewsletterAlerts1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterAlerts1(requestParameters: AlertsApiNewsletterAlerts1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<NewsletterSubscriberDto>> {
            return localVarFp.newsletterAlerts1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {AlertsApiNewsletterSubscribers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterSubscribers1(requestParameters: AlertsApiNewsletterSubscribers1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<NewsletterSubscriberDto>> {
            return localVarFp.newsletterSubscribers1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {AlertsApiSaveAlert1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlert1(requestParameters: AlertsApiSaveAlert1Request, options?: RawAxiosRequestConfig): AxiosPromise<Alert> {
            return localVarFp.saveAlert1(requestParameters.userId, requestParameters.alert, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {AlertsApiSendAlertRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert(requestParameters: AlertsApiSendAlertRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.sendAlert(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for deleteAlert1 operation in AlertsApi.
 * @export
 * @interface AlertsApiDeleteAlert1Request
 */
export interface AlertsApiDeleteAlert1Request {
    /**
     * ID of the user who owns the alert
     * @type {number}
     * @memberof AlertsApiDeleteAlert1
     */
    readonly userId: number

    /**
     * ID of the alert to delete
     * @type {number}
     * @memberof AlertsApiDeleteAlert1
     */
    readonly alertId: number
}

/**
 * Request parameters for getAlertResult1 operation in AlertsApi.
 * @export
 * @interface AlertsApiGetAlertResult1Request
 */
export interface AlertsApiGetAlertResult1Request {
    /**
     * ID of the user who owns the alert
     * @type {number}
     * @memberof AlertsApiGetAlertResult1
     */
    readonly userId: number

    /**
     * ID of the alert to retrieve results for
     * @type {number}
     * @memberof AlertsApiGetAlertResult1
     */
    readonly alertId: number
}

/**
 * Request parameters for getByUser2 operation in AlertsApi.
 * @export
 * @interface AlertsApiGetByUser2Request
 */
export interface AlertsApiGetByUser2Request {
    /**
     * ID of the user to retrieve alerts for
     * @type {number}
     * @memberof AlertsApiGetByUser2
     */
    readonly userId: number
}

/**
 * Request parameters for newsletterAlerts1 operation in AlertsApi.
 * @export
 * @interface AlertsApiNewsletterAlerts1Request
 */
export interface AlertsApiNewsletterAlerts1Request {
    /**
     * ID of the user who subscribed to newsletters
     * @type {number}
     * @memberof AlertsApiNewsletterAlerts1
     */
    readonly userId: number
}

/**
 * Request parameters for newsletterSubscribers1 operation in AlertsApi.
 * @export
 * @interface AlertsApiNewsletterSubscribers1Request
 */
export interface AlertsApiNewsletterSubscribers1Request {
    /**
     * ID of the user who owns the newsletters
     * @type {number}
     * @memberof AlertsApiNewsletterSubscribers1
     */
    readonly userId: number
}

/**
 * Request parameters for saveAlert1 operation in AlertsApi.
 * @export
 * @interface AlertsApiSaveAlert1Request
 */
export interface AlertsApiSaveAlert1Request {
    /**
     * ID of the user to create the alert for
     * @type {number}
     * @memberof AlertsApiSaveAlert1
     */
    readonly userId: number

    /**
     * Alert to be created
     * @type {Alert}
     * @memberof AlertsApiSaveAlert1
     */
    readonly alert: Alert
}

/**
 * Request parameters for sendAlert operation in AlertsApi.
 * @export
 * @interface AlertsApiSendAlertRequest
 */
export interface AlertsApiSendAlertRequest {
    /**
     * ID of the user
     * @type {number}
     * @memberof AlertsApiSendAlert
     */
    readonly userId: number
}

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * Deletes a specific alert owned by the user
     * @summary Delete an alert
     * @param {AlertsApiDeleteAlert1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public deleteAlert1(requestParameters: AlertsApiDeleteAlert1Request, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).deleteAlert1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the results for a specific alert
     * @summary Get alert results
     * @param {AlertsApiGetAlertResult1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getAlertResult1(requestParameters: AlertsApiGetAlertResult1Request, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).getAlertResult1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all alerts from all users in the system. For users with non-Free subscription plans, the response includes their profile name. This is typically an admin-level operation.
     * @summary Get all alerts in the system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getAllAlerts1(options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).getAllAlerts1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all alerts associated with the specified user ID
     * @summary Get all alerts for a user
     * @param {AlertsApiGetByUser2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getByUser2(requestParameters: AlertsApiGetByUser2Request, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).getByUser2(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all newsletters that the specified user has subscribed to
     * @summary Get newsletters subscribed to
     * @param {AlertsApiNewsletterAlerts1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public newsletterAlerts1(requestParameters: AlertsApiNewsletterAlerts1Request, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).newsletterAlerts1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all subscribers to newsletters owned by the specified user
     * @summary Get newsletter subscribers
     * @param {AlertsApiNewsletterSubscribers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public newsletterSubscribers1(requestParameters: AlertsApiNewsletterSubscribers1Request, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).newsletterSubscribers1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new alert for the specified user
     * @summary Create a new alert
     * @param {AlertsApiSaveAlert1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public saveAlert1(requestParameters: AlertsApiSaveAlert1Request, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).saveAlert1(requestParameters.userId, requestParameters.alert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers the sending of customized property alerts to users
     * @summary Send customized property alerts
     * @param {AlertsApiSendAlertRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public sendAlert(requestParameters: AlertsApiSendAlertRequest, options?: RawAxiosRequestConfig) {
        return AlertsApiFp(this.configuration).sendAlert(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ApiKeysApi - axios parameter creator
 * @export
 */
export const ApiKeysApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate a new API key for the authenticated user
         * @summary Create new API key
         * @param {CreateApiKeyRequestDto} [createApiKeyRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey1: async (createApiKeyRequestDto?: CreateApiKeyRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createApiKeyRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate an API key belonging to the authenticated user
         * @summary Deactivate API key
         * @param {number} apiKeyId API Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateApiKey1: async (apiKeyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('deactivateApiKey1', 'apiKeyId', apiKeyId)
            const localVarPath = `/api-keys/{apiKeyId}/deactivate`
                .replace(`{${"apiKeyId"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key belonging to the authenticated user
         * @summary Delete API key
         * @param {number} apiKeyId API Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey1: async (apiKeyId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKeyId' is not null or undefined
            assertParamExists('deleteApiKey1', 'apiKeyId', apiKeyId)
            const localVarPath = `/api-keys/{apiKeyId}`
                .replace(`{${"apiKeyId"}}`, encodeURIComponent(String(apiKeyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all API keys for the authenticated user
         * @summary Get user API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserApiKeys1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiKeysApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate a new API key for the authenticated user
         * @summary Create new API key
         * @param {CreateApiKeyRequestDto} [createApiKeyRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKey1(createApiKeyRequestDto?: CreateApiKeyRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKey1(createApiKeyRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.createApiKey1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivate an API key belonging to the authenticated user
         * @summary Deactivate API key
         * @param {number} apiKeyId API Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateApiKey1(apiKeyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateApiKey1(apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.deactivateApiKey1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API key belonging to the authenticated user
         * @summary Delete API key
         * @param {number} apiKeyId API Key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteApiKey1(apiKeyId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteApiKey1(apiKeyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.deleteApiKey1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve all API keys for the authenticated user
         * @summary Get user API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserApiKeys1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiKeyDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserApiKeys1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ApiKeysApi.getUserApiKeys1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiKeysApiFp(configuration)
    return {
        /**
         * Generate a new API key for the authenticated user
         * @summary Create new API key
         * @param {ApiKeysApiCreateApiKey1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKey1(requestParameters: ApiKeysApiCreateApiKey1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyDto> {
            return localVarFp.createApiKey1(requestParameters.createApiKeyRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate an API key belonging to the authenticated user
         * @summary Deactivate API key
         * @param {ApiKeysApiDeactivateApiKey1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateApiKey1(requestParameters: ApiKeysApiDeactivateApiKey1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deactivateApiKey1(requestParameters.apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API key belonging to the authenticated user
         * @summary Delete API key
         * @param {ApiKeysApiDeleteApiKey1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApiKey1(requestParameters: ApiKeysApiDeleteApiKey1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteApiKey1(requestParameters.apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all API keys for the authenticated user
         * @summary Get user API keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserApiKeys1(options?: RawAxiosRequestConfig): AxiosPromise<ApiKeyDto> {
            return localVarFp.getUserApiKeys1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createApiKey1 operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiCreateApiKey1Request
 */
export interface ApiKeysApiCreateApiKey1Request {
    /**
     * 
     * @type {CreateApiKeyRequestDto}
     * @memberof ApiKeysApiCreateApiKey1
     */
    readonly createApiKeyRequestDto?: CreateApiKeyRequestDto
}

/**
 * Request parameters for deactivateApiKey1 operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiDeactivateApiKey1Request
 */
export interface ApiKeysApiDeactivateApiKey1Request {
    /**
     * API Key ID
     * @type {number}
     * @memberof ApiKeysApiDeactivateApiKey1
     */
    readonly apiKeyId: number
}

/**
 * Request parameters for deleteApiKey1 operation in ApiKeysApi.
 * @export
 * @interface ApiKeysApiDeleteApiKey1Request
 */
export interface ApiKeysApiDeleteApiKey1Request {
    /**
     * API Key ID
     * @type {number}
     * @memberof ApiKeysApiDeleteApiKey1
     */
    readonly apiKeyId: number
}

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * Generate a new API key for the authenticated user
     * @summary Create new API key
     * @param {ApiKeysApiCreateApiKey1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public createApiKey1(requestParameters: ApiKeysApiCreateApiKey1Request = {}, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).createApiKey1(requestParameters.createApiKeyRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate an API key belonging to the authenticated user
     * @summary Deactivate API key
     * @param {ApiKeysApiDeactivateApiKey1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deactivateApiKey1(requestParameters: ApiKeysApiDeactivateApiKey1Request, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).deactivateApiKey1(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an API key belonging to the authenticated user
     * @summary Delete API key
     * @param {ApiKeysApiDeleteApiKey1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deleteApiKey1(requestParameters: ApiKeysApiDeleteApiKey1Request, options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).deleteApiKey1(requestParameters.apiKeyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all API keys for the authenticated user
     * @summary Get user API keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public getUserApiKeys1(options?: RawAxiosRequestConfig) {
        return ApiKeysApiFp(this.configuration).getUserApiKeys1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BrokeragesApi - axios parameter creator
 * @export
 */
export const BrokeragesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/brokerages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BrokeragesApi - functional programming interface
 * @export
 */
export const BrokeragesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BrokeragesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Brokerage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrokeragesApi.retrieve1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BrokeragesApi - factory interface
 * @export
 */
export const BrokeragesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BrokeragesApiFp(configuration)
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve1(options?: RawAxiosRequestConfig): AxiosPromise<Array<Brokerage>> {
            return localVarFp.retrieve1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BrokeragesApi - object-oriented interface
 * @export
 * @class BrokeragesApi
 * @extends {BaseAPI}
 */
export class BrokeragesApi extends BaseAPI {
    /**
     * Returns a list of all available brokerages in the system
     * @summary Retrieve all brokerages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokeragesApi
     */
    public retrieve1(options?: RawAxiosRequestConfig) {
        return BrokeragesApiFp(this.configuration).retrieve1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CheckoutSessionsApi - axios parameter creator
 * @export
 */
export const CheckoutSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CheckoutSessionDto} checkoutSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession2: async (checkoutSessionDto: CheckoutSessionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'checkoutSessionDto' is not null or undefined
            assertParamExists('createCheckoutSession2', 'checkoutSessionDto', checkoutSessionDto)
            const localVarPath = `/checkout-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutSessionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckoutSessionsApi - functional programming interface
 * @export
 */
export const CheckoutSessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CheckoutSessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CheckoutSessionDto} checkoutSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSession2(checkoutSessionDto: CheckoutSessionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSession2(checkoutSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckoutSessionsApi.createCheckoutSession2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CheckoutSessionsApi - factory interface
 * @export
 */
export const CheckoutSessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CheckoutSessionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CheckoutSessionsApiCreateCheckoutSession2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession2(requestParameters: CheckoutSessionsApiCreateCheckoutSession2Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createCheckoutSession2(requestParameters.checkoutSessionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCheckoutSession2 operation in CheckoutSessionsApi.
 * @export
 * @interface CheckoutSessionsApiCreateCheckoutSession2Request
 */
export interface CheckoutSessionsApiCreateCheckoutSession2Request {
    /**
     * 
     * @type {CheckoutSessionDto}
     * @memberof CheckoutSessionsApiCreateCheckoutSession2
     */
    readonly checkoutSessionDto: CheckoutSessionDto
}

/**
 * CheckoutSessionsApi - object-oriented interface
 * @export
 * @class CheckoutSessionsApi
 * @extends {BaseAPI}
 */
export class CheckoutSessionsApi extends BaseAPI {
    /**
     * 
     * @summary Create checkout-session
     * @param {CheckoutSessionsApiCreateCheckoutSession2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutSessionsApi
     */
    public createCheckoutSession2(requestParameters: CheckoutSessionsApiCreateCheckoutSession2Request, options?: RawAxiosRequestConfig) {
        return CheckoutSessionsApiFp(this.configuration).createCheckoutSession2(requestParameters.checkoutSessionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Method to find a country by the caller IP
         * @param {string} [xForwardedFor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByIp1: async (xForwardedFor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/countries/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            if (xForwardedFor != null) {
                localVarHeaderParameter['X-Forwarded-For'] = String(xForwardedFor);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CountriesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCountries2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Country>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCountries2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getAllCountries2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Method to find a country by the caller IP
         * @param {string} [xForwardedFor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByIp1(xForwardedFor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Country>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByIp1(xForwardedFor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryByIp1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CountriesApiFp(configuration)
    return {
        /**
         * 
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries2(options?: RawAxiosRequestConfig): AxiosPromise<Array<Country>> {
            return localVarFp.getAllCountries2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Method to find a country by the caller IP
         * @param {CountriesApiGetCountryByIp1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByIp1(requestParameters: CountriesApiGetCountryByIp1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Country> {
            return localVarFp.getCountryByIp1(requestParameters.xForwardedFor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getCountryByIp1 operation in CountriesApi.
 * @export
 * @interface CountriesApiGetCountryByIp1Request
 */
export interface CountriesApiGetCountryByIp1Request {
    /**
     * 
     * @type {string}
     * @memberof CountriesApiGetCountryByIp1
     */
    readonly xForwardedFor?: string
}

/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * 
     * @summary Method to find all the countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getAllCountries2(options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getAllCountries2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Method to find a country by the caller IP
     * @param {CountriesApiGetCountryByIp1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    public getCountryByIp1(requestParameters: CountriesApiGetCountryByIp1Request = {}, options?: RawAxiosRequestConfig) {
        return CountriesApiFp(this.configuration).getCountryByIp1(requestParameters.xForwardedFor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CurrencyManagementApi - axios parameter creator
 * @export
 */
export const CurrencyManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyManagementApi - functional programming interface
 * @export
 */
export const CurrencyManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CurrencyManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencies1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Currency>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencies1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyManagementApi.getCurrencies1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CurrencyManagementApi - factory interface
 * @export
 */
export const CurrencyManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CurrencyManagementApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies1(options?: RawAxiosRequestConfig): AxiosPromise<Array<Currency>> {
            return localVarFp.getCurrencies1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CurrencyManagementApi - object-oriented interface
 * @export
 * @class CurrencyManagementApi
 * @extends {BaseAPI}
 */
export class CurrencyManagementApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves the list of all exchange available in application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyManagementApi
     */
    public getCurrencies1(options?: RawAxiosRequestConfig) {
        return CurrencyManagementApiFp(this.configuration).getCurrencies1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CustomerSessionsApi - axios parameter creator
 * @export
 */
export const CustomerSessionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CustomerSessionDto} customerSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession: async (customerSessionDto: CustomerSessionDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'customerSessionDto' is not null or undefined
            assertParamExists('createCheckoutSession', 'customerSessionDto', customerSessionDto)
            const localVarPath = `/customer-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerSessionDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerSessionsApi - functional programming interface
 * @export
 */
export const CustomerSessionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerSessionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CustomerSessionDto} customerSessionDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSession(customerSessionDto: CustomerSessionDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSession(customerSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerSessionsApi.createCheckoutSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomerSessionsApi - factory interface
 * @export
 */
export const CustomerSessionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerSessionsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create checkout-session
         * @param {CustomerSessionsApiCreateCheckoutSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession(requestParameters: CustomerSessionsApiCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.createCheckoutSession(requestParameters.customerSessionDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createCheckoutSession operation in CustomerSessionsApi.
 * @export
 * @interface CustomerSessionsApiCreateCheckoutSessionRequest
 */
export interface CustomerSessionsApiCreateCheckoutSessionRequest {
    /**
     * 
     * @type {CustomerSessionDto}
     * @memberof CustomerSessionsApiCreateCheckoutSession
     */
    readonly customerSessionDto: CustomerSessionDto
}

/**
 * CustomerSessionsApi - object-oriented interface
 * @export
 * @class CustomerSessionsApi
 * @extends {BaseAPI}
 */
export class CustomerSessionsApi extends BaseAPI {
    /**
     * 
     * @summary Create checkout-session
     * @param {CustomerSessionsApiCreateCheckoutSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerSessionsApi
     */
    public createCheckoutSession(requestParameters: CustomerSessionsApiCreateCheckoutSessionRequest, options?: RawAxiosRequestConfig) {
        return CustomerSessionsApiFp(this.configuration).createCheckoutSession(requestParameters.customerSessionDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [lang] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewHome1: async (id?: string, lang?: string, acceptLanguage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/home/preview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] 
         * @param {string} [lang] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewHome1(id?: string, lang?: string, acceptLanguage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewHome1(id, lang, acceptLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.previewHome1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {DefaultApiPreviewHome1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewHome1(requestParameters: DefaultApiPreviewHome1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.previewHome1(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for previewHome1 operation in DefaultApi.
 * @export
 * @interface DefaultApiPreviewHome1Request
 */
export interface DefaultApiPreviewHome1Request {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiPreviewHome1
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiPreviewHome1
     */
    readonly lang?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiPreviewHome1
     */
    readonly acceptLanguage?: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {DefaultApiPreviewHome1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public previewHome1(requestParameters: DefaultApiPreviewHome1Request = {}, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).previewHome1(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EndorsementsApi - axios parameter creator
 * @export
 */
export const EndorsementsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {number} userId ID of the user to get endorsements for
         * @param {number} [endorser] Optional endorser ID to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEndorsementsByUser1: async (userId: number, endorser?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveEndorsementsByUser1', 'userId', userId)
            const localVarPath = `/users/{userId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (endorser !== undefined) {
                localVarQueryParameter['endorser'] = endorser;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndorsementsApi - functional programming interface
 * @export
 */
export const EndorsementsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EndorsementsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {number} userId ID of the user to get endorsements for
         * @param {number} [endorser] Optional endorser ID to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveEndorsementsByUser1(userId: number, endorser?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkillEndorsement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveEndorsementsByUser1(userId, endorser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndorsementsApi.retrieveEndorsementsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EndorsementsApi - factory interface
 * @export
 */
export const EndorsementsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EndorsementsApiFp(configuration)
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {EndorsementsApiRetrieveEndorsementsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEndorsementsByUser1(requestParameters: EndorsementsApiRetrieveEndorsementsByUser1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SkillEndorsement>> {
            return localVarFp.retrieveEndorsementsByUser1(requestParameters.userId, requestParameters.endorser, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for retrieveEndorsementsByUser1 operation in EndorsementsApi.
 * @export
 * @interface EndorsementsApiRetrieveEndorsementsByUser1Request
 */
export interface EndorsementsApiRetrieveEndorsementsByUser1Request {
    /**
     * ID of the user to get endorsements for
     * @type {number}
     * @memberof EndorsementsApiRetrieveEndorsementsByUser1
     */
    readonly userId: number

    /**
     * Optional endorser ID to filter results
     * @type {number}
     * @memberof EndorsementsApiRetrieveEndorsementsByUser1
     */
    readonly endorser?: number
}

/**
 * EndorsementsApi - object-oriented interface
 * @export
 * @class EndorsementsApi
 * @extends {BaseAPI}
 */
export class EndorsementsApi extends BaseAPI {
    /**
     * Gets all endorsements for a specified user. Can be filtered by endorser ID.
     * @summary Retrieve endorsements for a user
     * @param {EndorsementsApiRetrieveEndorsementsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndorsementsApi
     */
    public retrieveEndorsementsByUser1(requestParameters: EndorsementsApiRetrieveEndorsementsByUser1Request, options?: RawAxiosRequestConfig) {
        return EndorsementsApiFp(this.configuration).retrieveEndorsementsByUser1(requestParameters.userId, requestParameters.endorser, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExchangeRatesApi - axios parameter creator
 * @export
 */
export const ExchangeRatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExchangeRates1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/exchange-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangeRatesApi - functional programming interface
 * @export
 */
export const ExchangeRatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExchangeRatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findExchangeRates1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: number; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findExchangeRates1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeRatesApi.findExchangeRates1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExchangeRatesApi - factory interface
 * @export
 */
export const ExchangeRatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExchangeRatesApiFp(configuration)
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExchangeRates1(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: { [key: string]: number; }; }> {
            return localVarFp.findExchangeRates1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExchangeRatesApi - object-oriented interface
 * @export
 * @class ExchangeRatesApi
 * @extends {BaseAPI}
 */
export class ExchangeRatesApi extends BaseAPI {
    /**
     * Returns a map of currency exchange rates between different currencies
     * @summary Method to find all the exchange rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeRatesApi
     */
    public findExchangeRates1(options?: RawAxiosRequestConfig) {
        return ExchangeRatesApiFp(this.configuration).findExchangeRates1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FacebookPropertiesApi - axios parameter creator
 * @export
 */
export const FacebookPropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {string} startDate Start date for property export (ISO format)
         * @param {string} endDate End date for property export (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties: async (startDate: string, endDate: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('uploadKyeroProperties', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('uploadKyeroProperties', 'endDate', endDate)
            const localVarPath = `/facebook-properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start-date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end-date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FacebookPropertiesApi - functional programming interface
 * @export
 */
export const FacebookPropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FacebookPropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {string} startDate Start date for property export (ISO format)
         * @param {string} endDate End date for property export (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroProperties(startDate: string, endDate: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FBPropertyDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroProperties(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacebookPropertiesApi.uploadKyeroProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FacebookPropertiesApi - factory interface
 * @export
 */
export const FacebookPropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FacebookPropertiesApiFp(configuration)
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {FacebookPropertiesApiUploadKyeroPropertiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties(requestParameters: FacebookPropertiesApiUploadKyeroPropertiesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<FBPropertyDto>> {
            return localVarFp.uploadKyeroProperties(requestParameters.startDate, requestParameters.endDate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for uploadKyeroProperties operation in FacebookPropertiesApi.
 * @export
 * @interface FacebookPropertiesApiUploadKyeroPropertiesRequest
 */
export interface FacebookPropertiesApiUploadKyeroPropertiesRequest {
    /**
     * Start date for property export (ISO format)
     * @type {string}
     * @memberof FacebookPropertiesApiUploadKyeroProperties
     */
    readonly startDate: string

    /**
     * End date for property export (ISO format)
     * @type {string}
     * @memberof FacebookPropertiesApiUploadKyeroProperties
     */
    readonly endDate: string
}

/**
 * FacebookPropertiesApi - object-oriented interface
 * @export
 * @class FacebookPropertiesApi
 * @extends {BaseAPI}
 */
export class FacebookPropertiesApi extends BaseAPI {
    /**
     * Exports property data to Facebook Marketplace format within the specified date range
     * @summary Export properties to Facebook Marketplace
     * @param {FacebookPropertiesApiUploadKyeroPropertiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacebookPropertiesApi
     */
    public uploadKyeroProperties(requestParameters: FacebookPropertiesApiUploadKyeroPropertiesRequest, options?: RawAxiosRequestConfig) {
        return FacebookPropertiesApiFp(this.configuration).uploadKyeroProperties(requestParameters.startDate, requestParameters.endDate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FavoritesApi - axios parameter creator
 * @export
 */
export const FavoritesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {number} userId ID of the user
         * @param {boolean} [includeResource] Whether to include the associated resource details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser: async (userId: number, includeResource?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getByUser', 'userId', userId)
            const localVarPath = `/users/{userId}/favorites`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (includeResource !== undefined) {
                localVarQueryParameter['includeResource'] = includeResource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {number} userId ID of the user
         * @param {Favorite} favorite Favorite to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserFavorite1: async (userId: number, favorite: Favorite, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('postUserFavorite1', 'userId', userId)
            // verify required parameter 'favorite' is not null or undefined
            assertParamExists('postUserFavorite1', 'favorite', favorite)
            const localVarPath = `/users/{userId}/favorites`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(favorite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {number} userId ID of the user
         * @param {number} favoriteId ID of the favorite to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFavorite1: async (userId: number, favoriteId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFavorite1', 'userId', userId)
            // verify required parameter 'favoriteId' is not null or undefined
            assertParamExists('removeUserFavorite1', 'favoriteId', favoriteId)
            const localVarPath = `/users/{userId}/favorites/{favoriteId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"favoriteId"}}`, encodeURIComponent(String(favoriteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FavoritesApi - functional programming interface
 * @export
 */
export const FavoritesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FavoritesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {number} userId ID of the user
         * @param {boolean} [includeResource] Whether to include the associated resource details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUser(userId: number, includeResource?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Favorite>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUser(userId, includeResource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoritesApi.getByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {number} userId ID of the user
         * @param {Favorite} favorite Favorite to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserFavorite1(userId: number, favorite: Favorite, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Favorite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserFavorite1(userId, favorite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoritesApi.postUserFavorite1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {number} userId ID of the user
         * @param {number} favoriteId ID of the favorite to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFavorite1(userId: number, favoriteId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFavorite1(userId, favoriteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoritesApi.removeUserFavorite1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FavoritesApi - factory interface
 * @export
 */
export const FavoritesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FavoritesApiFp(configuration)
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {FavoritesApiGetByUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser(requestParameters: FavoritesApiGetByUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Favorite>> {
            return localVarFp.getByUser(requestParameters.userId, requestParameters.includeResource, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {FavoritesApiPostUserFavorite1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserFavorite1(requestParameters: FavoritesApiPostUserFavorite1Request, options?: RawAxiosRequestConfig): AxiosPromise<Favorite> {
            return localVarFp.postUserFavorite1(requestParameters.userId, requestParameters.favorite, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {FavoritesApiRemoveUserFavorite1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFavorite1(requestParameters: FavoritesApiRemoveUserFavorite1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.removeUserFavorite1(requestParameters.userId, requestParameters.favoriteId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getByUser operation in FavoritesApi.
 * @export
 * @interface FavoritesApiGetByUserRequest
 */
export interface FavoritesApiGetByUserRequest {
    /**
     * ID of the user
     * @type {number}
     * @memberof FavoritesApiGetByUser
     */
    readonly userId: number

    /**
     * Whether to include the associated resource details
     * @type {boolean}
     * @memberof FavoritesApiGetByUser
     */
    readonly includeResource?: boolean
}

/**
 * Request parameters for postUserFavorite1 operation in FavoritesApi.
 * @export
 * @interface FavoritesApiPostUserFavorite1Request
 */
export interface FavoritesApiPostUserFavorite1Request {
    /**
     * ID of the user
     * @type {number}
     * @memberof FavoritesApiPostUserFavorite1
     */
    readonly userId: number

    /**
     * Favorite to add
     * @type {Favorite}
     * @memberof FavoritesApiPostUserFavorite1
     */
    readonly favorite: Favorite
}

/**
 * Request parameters for removeUserFavorite1 operation in FavoritesApi.
 * @export
 * @interface FavoritesApiRemoveUserFavorite1Request
 */
export interface FavoritesApiRemoveUserFavorite1Request {
    /**
     * ID of the user
     * @type {number}
     * @memberof FavoritesApiRemoveUserFavorite1
     */
    readonly userId: number

    /**
     * ID of the favorite to remove
     * @type {number}
     * @memberof FavoritesApiRemoveUserFavorite1
     */
    readonly favoriteId: number
}

/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
export class FavoritesApi extends BaseAPI {
    /**
     * Retrieves all favorites for a specific user
     * @summary Get user favorites
     * @param {FavoritesApiGetByUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public getByUser(requestParameters: FavoritesApiGetByUserRequest, options?: RawAxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).getByUser(requestParameters.userId, requestParameters.includeResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a new favorite item for a specific user
     * @summary Add a favorite
     * @param {FavoritesApiPostUserFavorite1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public postUserFavorite1(requestParameters: FavoritesApiPostUserFavorite1Request, options?: RawAxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).postUserFavorite1(requestParameters.userId, requestParameters.favorite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a specific favorite from a user\'s favorites list
     * @summary Remove a favorite
     * @param {FavoritesApiRemoveUserFavorite1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    public removeUserFavorite1(requestParameters: FavoritesApiRemoveUserFavorite1Request, options?: RawAxiosRequestConfig) {
        return FavoritesApiFp(this.configuration).removeUserFavorite1(requestParameters.userId, requestParameters.favoriteId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GeoLocationApi - axios parameter creator
 * @export
 */
export const GeoLocationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {string} [latlng] Comma-separated latitude and longitude coordinates
         * @param {string} [address] Text representation of an address to geocode
         * @param {string} [countryCode] ISO country code to restrict the address search
         * @param {string} [autoCompleteText] Text to use for location auto-completion suggestions
         * @param {number} [radius] Search radius in meters for location suggestions (used with latlng and autoCompleteText)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeoLocationsByLatLng1: async (latlng?: string, address?: string, countryCode?: string, autoCompleteText?: string, radius?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/geo-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (latlng !== undefined) {
                localVarQueryParameter['latlng'] = latlng;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }

            if (autoCompleteText !== undefined) {
                localVarQueryParameter['autoCompleteText'] = autoCompleteText;
            }

            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeoLocationApi - functional programming interface
 * @export
 */
export const GeoLocationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeoLocationApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {string} [latlng] Comma-separated latitude and longitude coordinates
         * @param {string} [address] Text representation of an address to geocode
         * @param {string} [countryCode] ISO country code to restrict the address search
         * @param {string} [autoCompleteText] Text to use for location auto-completion suggestions
         * @param {number} [radius] Search radius in meters for location suggestions (used with latlng and autoCompleteText)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeoLocationsByLatLng1(latlng?: string, address?: string, countryCode?: string, autoCompleteText?: string, radius?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeoPlace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeoLocationsByLatLng1(latlng, address, countryCode, autoCompleteText, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoLocationApi.getGeoLocationsByLatLng1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GeoLocationApi - factory interface
 * @export
 */
export const GeoLocationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeoLocationApiFp(configuration)
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {GeoLocationApiGetGeoLocationsByLatLng1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeoLocationsByLatLng1(requestParameters: GeoLocationApiGetGeoLocationsByLatLng1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<GeoPlace> {
            return localVarFp.getGeoLocationsByLatLng1(requestParameters.latlng, requestParameters.address, requestParameters.countryCode, requestParameters.autoCompleteText, requestParameters.radius, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getGeoLocationsByLatLng1 operation in GeoLocationApi.
 * @export
 * @interface GeoLocationApiGetGeoLocationsByLatLng1Request
 */
export interface GeoLocationApiGetGeoLocationsByLatLng1Request {
    /**
     * Comma-separated latitude and longitude coordinates
     * @type {string}
     * @memberof GeoLocationApiGetGeoLocationsByLatLng1
     */
    readonly latlng?: string

    /**
     * Text representation of an address to geocode
     * @type {string}
     * @memberof GeoLocationApiGetGeoLocationsByLatLng1
     */
    readonly address?: string

    /**
     * ISO country code to restrict the address search
     * @type {string}
     * @memberof GeoLocationApiGetGeoLocationsByLatLng1
     */
    readonly countryCode?: string

    /**
     * Text to use for location auto-completion suggestions
     * @type {string}
     * @memberof GeoLocationApiGetGeoLocationsByLatLng1
     */
    readonly autoCompleteText?: string

    /**
     * Search radius in meters for location suggestions (used with latlng and autoCompleteText)
     * @type {number}
     * @memberof GeoLocationApiGetGeoLocationsByLatLng1
     */
    readonly radius?: number
}

/**
 * GeoLocationApi - object-oriented interface
 * @export
 * @class GeoLocationApi
 * @extends {BaseAPI}
 */
export class GeoLocationApi extends BaseAPI {
    /**
     * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
     * @summary Retrieves geolocation information
     * @param {GeoLocationApiGetGeoLocationsByLatLng1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoLocationApi
     */
    public getGeoLocationsByLatLng1(requestParameters: GeoLocationApiGetGeoLocationsByLatLng1Request = {}, options?: RawAxiosRequestConfig) {
        return GeoLocationApiFp(this.configuration).getGeoLocationsByLatLng1(requestParameters.latlng, requestParameters.address, requestParameters.countryCode, requestParameters.autoCompleteText, requestParameters.radius, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveGroup1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('archiveGroup1', 'id', id)
            const localVarPath = `/groups/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateGroup1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateGroup1', 'id', id)
            const localVarPath = `/groups/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup1', 'id', id)
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only group owners can demote admins. Can only demote ADMIN members.
         * @summary Demote group admins to regular members
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to demote from admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demoteFromAdmin1: async (groupId: string, userIds?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('demoteFromAdmin1', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/demote-admin`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has archived
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findArchivedGroupsByUser1: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/archived`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it. Includes \'userAdmin\' field indicating whether the current user is an admin or owner of the group.
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup1: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('findGroup1', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the group with the specified slug. This endpoint is publicly accessible without authentication. If the user is authenticated and is a member or owner of the group, member count information will be included in the response. Otherwise, member count information will be excluded. Slug lookup is case-insensitive.
         * @summary Return the group with specified slug
         * @param {string} slug group slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupBySlug1: async (slug: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            assertParamExists('findGroupBySlug1', 'slug', slug)
            const localVarPath = `/groups/slug/{slug}`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupProperties1: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('findGroupProperties1', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/properties`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve groups of specific types (ASSOCIATION, CERTIFICATION) that the user has access to. This endpoint allows filtering for association groups or certificate groups where the user is either an owner or an accepted member. Only active groups are returned.
         * @summary Return groups filtered by group type
         * @param {string} [types] Comma-separated list of group types to filter by. Valid values: ASSOCIATION, CERTIFICATION
         * @param {number} [pageFrom] Starting page number for pagination (0-based)
         * @param {number} [pageTo] Ending page number for pagination (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupsByType1: async (types?: string, pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/by-type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (types !== undefined) {
                localVarQueryParameter['types'] = types;
            }

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return both owned Groups and Groups the user is a member of. Each group includes a \'userAdmin\' field indicating whether the current user is an admin or owner of that group.
         * @summary Return the groups list with specified user id
         * @param {number} [pageFrom] Start page number
         * @param {number} [pageTo] End page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupsByUser1: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the groups list with specified user id that are inactive
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInactiveGroupsByUser1: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/inactive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of groups where the current user has been invited but has not yet accepted or declined the invitation. These are groups owned by other users who have sent invitations to the current user.
         * @summary Get groups where the user has pending invitations
         * @param {number} [pageFrom] Starting page number for pagination (0-based)
         * @param {number} [pageTo] Ending page number for pagination (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvitedGroupsByUser1: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/invited`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has requested
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRequestedGroupsByUser1: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups/requested`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {string} groupId group id
         * @param {number} [pageFrom] Starting page index (zero-based)
         * @param {number} [pageTo] Ending page index (zero-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers1: async (groupId: string, pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupMembers1', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/members`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Invitation to Group
         * @param {string} groupId group id
         * @param {Array<number>} [userIds] List of user IDs to invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite: async (groupId: string, userIds?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupInvite', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/invite`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accept Group Invitation
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite2: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupInvite2', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/accept-invite`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leave Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupLeave1: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupLeave1', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/leave`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request Admission to Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRequest1: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupRequest1', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/request`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Only group owners can promote members to admin. Can only promote ACCEPTED members.
         * @summary Promote group members to admin
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to promote to admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteToAdmin1: async (groupId: string, userIds?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('promoteToAdmin1', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/promote-admin`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows group owners to request a change in their group type from GROUP to ASSOCIATION or CERTIFICATION. IMPORTANT: Type changes are only allowed for basic groups (GROUP type). Once a group has been upgraded to ASSOCIATION or CERTIFICATION, no further type changes are possible. Only group owners can make these requests.
         * @summary Request a change in group type
         * @param {string} id Group ID
         * @param {RequestGroupTypeChange1RequestStatusEnum} [requestStatus] The type change being requested. Use NONE to cancel existing requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestGroupTypeChange1: async (id: string, requestStatus?: RequestGroupTypeChange1RequestStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestGroupTypeChange1', 'id', id)
            const localVarPath = `/groups/{id}/request-type-change`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (requestStatus !== undefined) {
                localVarQueryParameter['requestStatus'] = requestStatus;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {Group} [group] group to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroup1: async (group?: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {PropertyFilterCriteria} [propertyFilterCriteria] filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroupProperties1: async (groupId: string, propertyFilterCriteria?: PropertyFilterCriteria, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('searchGroupProperties1', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/properties/search`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyFilterCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for users within a specific group matching the specified filter criteria
         * @summary Search users within a specified group
         * @param {string} groupId Group ID
         * @param {UserFilterRequest} userFilterRequest User search filters within the group. Supports filtering by user attributes, location, skills, and social preferences. The resultRequest field controls pagination and sorting. Only one sort order can be specified at a time.
         * @param {boolean} [bypassCache] Bypass cache and fetch fresh data from database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroupUsers1: async (groupId: string, userFilterRequest: UserFilterRequest, bypassCache?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('searchGroupUsers1', 'groupId', groupId)
            // verify required parameter 'userFilterRequest' is not null or undefined
            assertParamExists('searchGroupUsers1', 'userFilterRequest', userFilterRequest)
            const localVarPath = `/groups/{groupId}/users/search`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthToken required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Token", configuration)

            if (bypassCache !== undefined) {
                localVarQueryParameter['bypassCache'] = bypassCache;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Acceptable Status values are:  ACCEPTED, ADMIN, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to update status
         * @param {UpdateGroupMembershipStatus1StatusEnum} [status] New status for the members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMembershipStatus1: async (groupId: string, userIds?: Array<number>, status?: UpdateGroupMembershipStatus1StatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupMembershipStatus1', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/member-status`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveGroup1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveGroup1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.archiveGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateGroup1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateGroup1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deactivateGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Only group owners can demote admins. Can only demote ADMIN members.
         * @summary Demote group admins to regular members
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to demote from admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async demoteFromAdmin1(groupId: string, userIds?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.demoteFromAdmin1(groupId, userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.demoteFromAdmin1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has archived
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findArchivedGroupsByUser1(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findArchivedGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findArchivedGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it. Includes \'userAdmin\' field indicating whether the current user is an admin or owner of the group.
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroup1(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroup1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the group with the specified slug. This endpoint is publicly accessible without authentication. If the user is authenticated and is a member or owner of the group, member count information will be included in the response. Otherwise, member count information will be excluded. Slug lookup is case-insensitive.
         * @summary Return the group with specified slug
         * @param {string} slug group slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupBySlug1(slug: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupBySlug1(slug, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroupBySlug1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupProperties1(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupProperties1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroupProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve groups of specific types (ASSOCIATION, CERTIFICATION) that the user has access to. This endpoint allows filtering for association groups or certificate groups where the user is either an owner or an accepted member. Only active groups are returned.
         * @summary Return groups filtered by group type
         * @param {string} [types] Comma-separated list of group types to filter by. Valid values: ASSOCIATION, CERTIFICATION
         * @param {number} [pageFrom] Starting page number for pagination (0-based)
         * @param {number} [pageTo] Ending page number for pagination (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupsByType1(types?: string, pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupsByType1(types, pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroupsByType1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will return both owned Groups and Groups the user is a member of. Each group includes a \'userAdmin\' field indicating whether the current user is an admin or owner of that group.
         * @summary Return the groups list with specified user id
         * @param {number} [pageFrom] Start page number
         * @param {number} [pageTo] End page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupsByUser1(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the groups list with specified user id that are inactive
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInactiveGroupsByUser1(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInactiveGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findInactiveGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of groups where the current user has been invited but has not yet accepted or declined the invitation. These are groups owned by other users who have sent invitations to the current user.
         * @summary Get groups where the user has pending invitations
         * @param {number} [pageFrom] Starting page number for pagination (0-based)
         * @param {number} [pageTo] Ending page number for pagination (exclusive)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInvitedGroupsByUser1(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInvitedGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findInvitedGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has requested
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findRequestedGroupsByUser1(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findRequestedGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findRequestedGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {string} groupId group id
         * @param {number} [pageFrom] Starting page index (zero-based)
         * @param {number} [pageTo] Ending page index (zero-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupMembers1(groupId: string, pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMemberFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupMembers1(groupId, pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupMembers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request Invitation to Group
         * @param {string} groupId group id
         * @param {Array<number>} [userIds] List of user IDs to invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupInvite(groupId: string, userIds?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupInvite(groupId, userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Accept Group Invitation
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupInvite2(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupInvite2(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupInvite2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Leave Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupLeave1(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupLeave1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupLeave1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request Admission to Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRequest1(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupRequest1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupRequest1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Only group owners can promote members to admin. Can only promote ACCEPTED members.
         * @summary Promote group members to admin
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to promote to admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async promoteToAdmin1(groupId: string, userIds?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.promoteToAdmin1(groupId, userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.promoteToAdmin1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows group owners to request a change in their group type from GROUP to ASSOCIATION or CERTIFICATION. IMPORTANT: Type changes are only allowed for basic groups (GROUP type). Once a group has been upgraded to ASSOCIATION or CERTIFICATION, no further type changes are possible. Only group owners can make these requests.
         * @summary Request a change in group type
         * @param {string} id Group ID
         * @param {RequestGroupTypeChange1RequestStatusEnum} [requestStatus] The type change being requested. Use NONE to cancel existing requests.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestGroupTypeChange1(id: string, requestStatus?: RequestGroupTypeChange1RequestStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestGroupTypeChange1(id, requestStatus, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.requestGroupTypeChange1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {Group} [group] group to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveGroup1(group?: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveGroup1(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.saveGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {PropertyFilterCriteria} [propertyFilterCriteria] filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGroupProperties1(groupId: string, propertyFilterCriteria?: PropertyFilterCriteria, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGroupProperties1(groupId, propertyFilterCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.searchGroupProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Searches for users within a specific group matching the specified filter criteria
         * @summary Search users within a specified group
         * @param {string} groupId Group ID
         * @param {UserFilterRequest} userFilterRequest User search filters within the group. Supports filtering by user attributes, location, skills, and social preferences. The resultRequest field controls pagination and sorting. Only one sort order can be specified at a time.
         * @param {boolean} [bypassCache] Bypass cache and fetch fresh data from database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGroupUsers1(groupId: string, userFilterRequest: UserFilterRequest, bypassCache?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGroupUsers1(groupId, userFilterRequest, bypassCache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.searchGroupUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Acceptable Status values are:  ACCEPTED, ADMIN, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to update status
         * @param {UpdateGroupMembershipStatus1StatusEnum} [status] New status for the members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupMembershipStatus1(groupId: string, userIds?: Array<number>, status?: UpdateGroupMembershipStatus1StatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GroupMember>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupMembershipStatus1(groupId, userIds, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.updateGroupMembershipStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {GroupsApiArchiveGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveGroup1(requestParameters: GroupsApiArchiveGroup1Request, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.archiveGroup1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {GroupsApiDeactivateGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateGroup1(requestParameters: GroupsApiDeactivateGroup1Request, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deactivateGroup1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {GroupsApiDeleteGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup1(requestParameters: GroupsApiDeleteGroup1Request, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteGroup1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Only group owners can demote admins. Can only demote ADMIN members.
         * @summary Demote group admins to regular members
         * @param {GroupsApiDemoteFromAdmin1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        demoteFromAdmin1(requestParameters: GroupsApiDemoteFromAdmin1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupMember>> {
            return localVarFp.demoteFromAdmin1(requestParameters.groupId, requestParameters.userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has archived
         * @param {GroupsApiFindArchivedGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findArchivedGroupsByUser1(requestParameters: GroupsApiFindArchivedGroupsByUser1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<GroupFilterResult> {
            return localVarFp.findArchivedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it. Includes \'userAdmin\' field indicating whether the current user is an admin or owner of the group.
         * @summary Return the group with specified id
         * @param {GroupsApiFindGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup1(requestParameters: GroupsApiFindGroup1Request, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.findGroup1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the group with the specified slug. This endpoint is publicly accessible without authentication. If the user is authenticated and is a member or owner of the group, member count information will be included in the response. Otherwise, member count information will be excluded. Slug lookup is case-insensitive.
         * @summary Return the group with specified slug
         * @param {GroupsApiFindGroupBySlug1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupBySlug1(requestParameters: GroupsApiFindGroupBySlug1Request, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.findGroupBySlug1(requestParameters.slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {GroupsApiFindGroupProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupProperties1(requestParameters: GroupsApiFindGroupProperties1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.findGroupProperties1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve groups of specific types (ASSOCIATION, CERTIFICATION) that the user has access to. This endpoint allows filtering for association groups or certificate groups where the user is either an owner or an accepted member. Only active groups are returned.
         * @summary Return groups filtered by group type
         * @param {GroupsApiFindGroupsByType1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupsByType1(requestParameters: GroupsApiFindGroupsByType1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<GroupFilterResult> {
            return localVarFp.findGroupsByType1(requestParameters.types, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return both owned Groups and Groups the user is a member of. Each group includes a \'userAdmin\' field indicating whether the current user is an admin or owner of that group.
         * @summary Return the groups list with specified user id
         * @param {GroupsApiFindGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupsByUser1(requestParameters: GroupsApiFindGroupsByUser1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<GroupFilterResult> {
            return localVarFp.findGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the groups list with specified user id that are inactive
         * @param {GroupsApiFindInactiveGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInactiveGroupsByUser1(requestParameters: GroupsApiFindInactiveGroupsByUser1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<GroupFilterResult> {
            return localVarFp.findInactiveGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of groups where the current user has been invited but has not yet accepted or declined the invitation. These are groups owned by other users who have sent invitations to the current user.
         * @summary Get groups where the user has pending invitations
         * @param {GroupsApiFindInvitedGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvitedGroupsByUser1(requestParameters: GroupsApiFindInvitedGroupsByUser1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<GroupFilterResult> {
            return localVarFp.findInvitedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the groups list with specified user id that user has requested
         * @param {GroupsApiFindRequestedGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRequestedGroupsByUser1(requestParameters: GroupsApiFindRequestedGroupsByUser1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<GroupFilterResult> {
            return localVarFp.findRequestedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {GroupsApiGetGroupMembers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers1(requestParameters: GroupsApiGetGroupMembers1Request, options?: RawAxiosRequestConfig): AxiosPromise<GroupMemberFilterResult> {
            return localVarFp.getGroupMembers1(requestParameters.groupId, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Invitation to Group
         * @param {GroupsApiGroupInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite(requestParameters: GroupsApiGroupInviteRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupMember>> {
            return localVarFp.groupInvite(requestParameters.groupId, requestParameters.userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Accept Group Invitation
         * @param {GroupsApiGroupInvite2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite2(requestParameters: GroupsApiGroupInvite2Request, options?: RawAxiosRequestConfig): AxiosPromise<GroupMember> {
            return localVarFp.groupInvite2(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Leave Group
         * @param {GroupsApiGroupLeave1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupLeave1(requestParameters: GroupsApiGroupLeave1Request, options?: RawAxiosRequestConfig): AxiosPromise<GroupMember> {
            return localVarFp.groupLeave1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request Admission to Group
         * @param {GroupsApiGroupRequest1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRequest1(requestParameters: GroupsApiGroupRequest1Request, options?: RawAxiosRequestConfig): AxiosPromise<GroupMember> {
            return localVarFp.groupRequest1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Only group owners can promote members to admin. Can only promote ACCEPTED members.
         * @summary Promote group members to admin
         * @param {GroupsApiPromoteToAdmin1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        promoteToAdmin1(requestParameters: GroupsApiPromoteToAdmin1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupMember>> {
            return localVarFp.promoteToAdmin1(requestParameters.groupId, requestParameters.userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows group owners to request a change in their group type from GROUP to ASSOCIATION or CERTIFICATION. IMPORTANT: Type changes are only allowed for basic groups (GROUP type). Once a group has been upgraded to ASSOCIATION or CERTIFICATION, no further type changes are possible. Only group owners can make these requests.
         * @summary Request a change in group type
         * @param {GroupsApiRequestGroupTypeChange1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestGroupTypeChange1(requestParameters: GroupsApiRequestGroupTypeChange1Request, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.requestGroupTypeChange1(requestParameters.id, requestParameters.requestStatus, options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {GroupsApiSaveGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroup1(requestParameters: GroupsApiSaveGroup1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Group> {
            return localVarFp.saveGroup1(requestParameters.group, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {GroupsApiSearchGroupProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroupProperties1(requestParameters: GroupsApiSearchGroupProperties1Request, options?: RawAxiosRequestConfig): AxiosPromise<PropertyFilterResult> {
            return localVarFp.searchGroupProperties1(requestParameters.groupId, requestParameters.propertyFilterCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for users within a specific group matching the specified filter criteria
         * @summary Search users within a specified group
         * @param {GroupsApiSearchGroupUsers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroupUsers1(requestParameters: GroupsApiSearchGroupUsers1Request, options?: RawAxiosRequestConfig): AxiosPromise<UserFilterResult> {
            return localVarFp.searchGroupUsers1(requestParameters.groupId, requestParameters.userFilterRequest, requestParameters.bypassCache, options).then((request) => request(axios, basePath));
        },
        /**
         * Acceptable Status values are:  ACCEPTED, ADMIN, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {GroupsApiUpdateGroupMembershipStatus1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMembershipStatus1(requestParameters: GroupsApiUpdateGroupMembershipStatus1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<GroupMember>> {
            return localVarFp.updateGroupMembershipStatus1(requestParameters.groupId, requestParameters.userIds, requestParameters.status, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for archiveGroup1 operation in GroupsApi.
 * @export
 * @interface GroupsApiArchiveGroup1Request
 */
export interface GroupsApiArchiveGroup1Request {
    /**
     * groupId
     * @type {string}
     * @memberof GroupsApiArchiveGroup1
     */
    readonly id: string
}

/**
 * Request parameters for deactivateGroup1 operation in GroupsApi.
 * @export
 * @interface GroupsApiDeactivateGroup1Request
 */
export interface GroupsApiDeactivateGroup1Request {
    /**
     * groupId
     * @type {string}
     * @memberof GroupsApiDeactivateGroup1
     */
    readonly id: string
}

/**
 * Request parameters for deleteGroup1 operation in GroupsApi.
 * @export
 * @interface GroupsApiDeleteGroup1Request
 */
export interface GroupsApiDeleteGroup1Request {
    /**
     * groupId
     * @type {string}
     * @memberof GroupsApiDeleteGroup1
     */
    readonly id: string
}

/**
 * Request parameters for demoteFromAdmin1 operation in GroupsApi.
 * @export
 * @interface GroupsApiDemoteFromAdmin1Request
 */
export interface GroupsApiDemoteFromAdmin1Request {
    /**
     * groupId
     * @type {string}
     * @memberof GroupsApiDemoteFromAdmin1
     */
    readonly groupId: string

    /**
     * List of user IDs to demote from admin
     * @type {Array<number>}
     * @memberof GroupsApiDemoteFromAdmin1
     */
    readonly userIds?: Array<number>
}

/**
 * Request parameters for findArchivedGroupsByUser1 operation in GroupsApi.
 * @export
 * @interface GroupsApiFindArchivedGroupsByUser1Request
 */
export interface GroupsApiFindArchivedGroupsByUser1Request {
    /**
     * 
     * @type {number}
     * @memberof GroupsApiFindArchivedGroupsByUser1
     */
    readonly pageFrom?: number

    /**
     * 
     * @type {number}
     * @memberof GroupsApiFindArchivedGroupsByUser1
     */
    readonly pageTo?: number
}

/**
 * Request parameters for findGroup1 operation in GroupsApi.
 * @export
 * @interface GroupsApiFindGroup1Request
 */
export interface GroupsApiFindGroup1Request {
    /**
     * group id
     * @type {string}
     * @memberof GroupsApiFindGroup1
     */
    readonly groupId: string
}

/**
 * Request parameters for findGroupBySlug1 operation in GroupsApi.
 * @export
 * @interface GroupsApiFindGroupBySlug1Request
 */
export interface GroupsApiFindGroupBySlug1Request {
    /**
     * group slug
     * @type {string}
     * @memberof GroupsApiFindGroupBySlug1
     */
    readonly slug: string
}

/**
 * Request parameters for findGroupProperties1 operation in GroupsApi.
 * @export
 * @interface GroupsApiFindGroupProperties1Request
 */
export interface GroupsApiFindGroupProperties1Request {
    /**
     * group id
     * @type {string}
     * @memberof GroupsApiFindGroupProperties1
     */
    readonly groupId: string
}

/**
 * Request parameters for findGroupsByType1 operation in GroupsApi.
 * @export
 * @interface GroupsApiFindGroupsByType1Request
 */
export interface GroupsApiFindGroupsByType1Request {
    /**
     * Comma-separated list of group types to filter by. Valid values: ASSOCIATION, CERTIFICATION
     * @type {string}
     * @memberof GroupsApiFindGroupsByType1
     */
    readonly types?: string

    /**
     * Starting page number for pagination (0-based)
     * @type {number}
     * @memberof GroupsApiFindGroupsByType1
     */
    readonly pageFrom?: number

    /**
     * Ending page number for pagination (exclusive)
     * @type {number}
     * @memberof GroupsApiFindGroupsByType1
     */
    readonly pageTo?: number
}

/**
 * Request parameters for findGroupsByUser1 operation in GroupsApi.
 * @export
 * @interface GroupsApiFindGroupsByUser1Request
 */
export interface GroupsApiFindGroupsByUser1Request {
    /**
     * Start page number
     * @type {number}
     * @memberof GroupsApiFindGroupsByUser1
     */
    readonly pageFrom?: number

    /**
     * End page number
     * @type {number}
     * @memberof GroupsApiFindGroupsByUser1
     */
    readonly pageTo?: number
}

/**
 * Request parameters for findInactiveGroupsByUser1 operation in GroupsApi.
 * @export
 * @interface GroupsApiFindInactiveGroupsByUser1Request
 */
export interface GroupsApiFindInactiveGroupsByUser1Request {
    /**
     * 
     * @type {number}
     * @memberof GroupsApiFindInactiveGroupsByUser1
     */
    readonly pageFrom?: number

    /**
     * 
     * @type {number}
     * @memberof GroupsApiFindInactiveGroupsByUser1
     */
    readonly pageTo?: number
}

/**
 * Request parameters for findInvitedGroupsByUser1 operation in GroupsApi.
 * @export
 * @interface GroupsApiFindInvitedGroupsByUser1Request
 */
export interface GroupsApiFindInvitedGroupsByUser1Request {
    /**
     * Starting page number for pagination (0-based)
     * @type {number}
     * @memberof GroupsApiFindInvitedGroupsByUser1
     */
    readonly pageFrom?: number

    /**
     * Ending page number for pagination (exclusive)
     * @type {number}
     * @memberof GroupsApiFindInvitedGroupsByUser1
     */
    readonly pageTo?: number
}

/**
 * Request parameters for findRequestedGroupsByUser1 operation in GroupsApi.
 * @export
 * @interface GroupsApiFindRequestedGroupsByUser1Request
 */
export interface GroupsApiFindRequestedGroupsByUser1Request {
    /**
     * 
     * @type {number}
     * @memberof GroupsApiFindRequestedGroupsByUser1
     */
    readonly pageFrom?: number

    /**
     * 
     * @type {number}
     * @memberof GroupsApiFindRequestedGroupsByUser1
     */
    readonly pageTo?: number
}

/**
 * Request parameters for getGroupMembers1 operation in GroupsApi.
 * @export
 * @interface GroupsApiGetGroupMembers1Request
 */
export interface GroupsApiGetGroupMembers1Request {
    /**
     * group id
     * @type {string}
     * @memberof GroupsApiGetGroupMembers1
     */
    readonly groupId: string

    /**
     * Starting page index (zero-based)
     * @type {number}
     * @memberof GroupsApiGetGroupMembers1
     */
    readonly pageFrom?: number

    /**
     * Ending page index (zero-based)
     * @type {number}
     * @memberof GroupsApiGetGroupMembers1
     */
    readonly pageTo?: number
}

/**
 * Request parameters for groupInvite operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupInviteRequest
 */
export interface GroupsApiGroupInviteRequest {
    /**
     * group id
     * @type {string}
     * @memberof GroupsApiGroupInvite
     */
    readonly groupId: string

    /**
     * List of user IDs to invite
     * @type {Array<number>}
     * @memberof GroupsApiGroupInvite
     */
    readonly userIds?: Array<number>
}

/**
 * Request parameters for groupInvite2 operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupInvite2Request
 */
export interface GroupsApiGroupInvite2Request {
    /**
     * group id
     * @type {string}
     * @memberof GroupsApiGroupInvite2
     */
    readonly groupId: string
}

/**
 * Request parameters for groupLeave1 operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupLeave1Request
 */
export interface GroupsApiGroupLeave1Request {
    /**
     * group id
     * @type {string}
     * @memberof GroupsApiGroupLeave1
     */
    readonly groupId: string
}

/**
 * Request parameters for groupRequest1 operation in GroupsApi.
 * @export
 * @interface GroupsApiGroupRequest1Request
 */
export interface GroupsApiGroupRequest1Request {
    /**
     * group id
     * @type {string}
     * @memberof GroupsApiGroupRequest1
     */
    readonly groupId: string
}

/**
 * Request parameters for promoteToAdmin1 operation in GroupsApi.
 * @export
 * @interface GroupsApiPromoteToAdmin1Request
 */
export interface GroupsApiPromoteToAdmin1Request {
    /**
     * groupId
     * @type {string}
     * @memberof GroupsApiPromoteToAdmin1
     */
    readonly groupId: string

    /**
     * List of user IDs to promote to admin
     * @type {Array<number>}
     * @memberof GroupsApiPromoteToAdmin1
     */
    readonly userIds?: Array<number>
}

/**
 * Request parameters for requestGroupTypeChange1 operation in GroupsApi.
 * @export
 * @interface GroupsApiRequestGroupTypeChange1Request
 */
export interface GroupsApiRequestGroupTypeChange1Request {
    /**
     * Group ID
     * @type {string}
     * @memberof GroupsApiRequestGroupTypeChange1
     */
    readonly id: string

    /**
     * The type change being requested. Use NONE to cancel existing requests.
     * @type {'NONE' | 'REQUESTING_ASSOCIATION' | 'REQUESTING_CERTIFICATION'}
     * @memberof GroupsApiRequestGroupTypeChange1
     */
    readonly requestStatus?: RequestGroupTypeChange1RequestStatusEnum
}

/**
 * Request parameters for saveGroup1 operation in GroupsApi.
 * @export
 * @interface GroupsApiSaveGroup1Request
 */
export interface GroupsApiSaveGroup1Request {
    /**
     * group to persist
     * @type {Group}
     * @memberof GroupsApiSaveGroup1
     */
    readonly group?: Group
}

/**
 * Request parameters for searchGroupProperties1 operation in GroupsApi.
 * @export
 * @interface GroupsApiSearchGroupProperties1Request
 */
export interface GroupsApiSearchGroupProperties1Request {
    /**
     * group id
     * @type {string}
     * @memberof GroupsApiSearchGroupProperties1
     */
    readonly groupId: string

    /**
     * filters
     * @type {PropertyFilterCriteria}
     * @memberof GroupsApiSearchGroupProperties1
     */
    readonly propertyFilterCriteria?: PropertyFilterCriteria
}

/**
 * Request parameters for searchGroupUsers1 operation in GroupsApi.
 * @export
 * @interface GroupsApiSearchGroupUsers1Request
 */
export interface GroupsApiSearchGroupUsers1Request {
    /**
     * Group ID
     * @type {string}
     * @memberof GroupsApiSearchGroupUsers1
     */
    readonly groupId: string

    /**
     * User search filters within the group. Supports filtering by user attributes, location, skills, and social preferences. The resultRequest field controls pagination and sorting. Only one sort order can be specified at a time.
     * @type {UserFilterRequest}
     * @memberof GroupsApiSearchGroupUsers1
     */
    readonly userFilterRequest: UserFilterRequest

    /**
     * Bypass cache and fetch fresh data from database
     * @type {boolean}
     * @memberof GroupsApiSearchGroupUsers1
     */
    readonly bypassCache?: boolean
}

/**
 * Request parameters for updateGroupMembershipStatus1 operation in GroupsApi.
 * @export
 * @interface GroupsApiUpdateGroupMembershipStatus1Request
 */
export interface GroupsApiUpdateGroupMembershipStatus1Request {
    /**
     * groupId
     * @type {string}
     * @memberof GroupsApiUpdateGroupMembershipStatus1
     */
    readonly groupId: string

    /**
     * List of user IDs to update status
     * @type {Array<number>}
     * @memberof GroupsApiUpdateGroupMembershipStatus1
     */
    readonly userIds?: Array<number>

    /**
     * New status for the members
     * @type {'ACCEPTED' | 'ADMIN' | 'REJECTED' | 'REMOVED'}
     * @memberof GroupsApiUpdateGroupMembershipStatus1
     */
    readonly status?: UpdateGroupMembershipStatus1StatusEnum
}

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * This process is reversible
     * @summary Archive the group with id supplied
     * @param {GroupsApiArchiveGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public archiveGroup1(requestParameters: GroupsApiArchiveGroup1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).archiveGroup1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This process is reversible
     * @summary Deactivate the group with id supplied
     * @param {GroupsApiDeactivateGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deactivateGroup1(requestParameters: GroupsApiDeactivateGroup1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deactivateGroup1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This process is not reversible
     * @summary Delete the group with id supplied
     * @param {GroupsApiDeleteGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroup1(requestParameters: GroupsApiDeleteGroup1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroup1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only group owners can demote admins. Can only demote ADMIN members.
     * @summary Demote group admins to regular members
     * @param {GroupsApiDemoteFromAdmin1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public demoteFromAdmin1(requestParameters: GroupsApiDemoteFromAdmin1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).demoteFromAdmin1(requestParameters.groupId, requestParameters.userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the groups list with specified user id that user has archived
     * @param {GroupsApiFindArchivedGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findArchivedGroupsByUser1(requestParameters: GroupsApiFindArchivedGroupsByUser1Request = {}, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findArchivedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it. Includes \'userAdmin\' field indicating whether the current user is an admin or owner of the group.
     * @summary Return the group with specified id
     * @param {GroupsApiFindGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findGroup1(requestParameters: GroupsApiFindGroup1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findGroup1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the group with the specified slug. This endpoint is publicly accessible without authentication. If the user is authenticated and is a member or owner of the group, member count information will be included in the response. Otherwise, member count information will be excluded. Slug lookup is case-insensitive.
     * @summary Return the group with specified slug
     * @param {GroupsApiFindGroupBySlug1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findGroupBySlug1(requestParameters: GroupsApiFindGroupBySlug1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findGroupBySlug1(requestParameters.slug, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {GroupsApiFindGroupProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findGroupProperties1(requestParameters: GroupsApiFindGroupProperties1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findGroupProperties1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve groups of specific types (ASSOCIATION, CERTIFICATION) that the user has access to. This endpoint allows filtering for association groups or certificate groups where the user is either an owner or an accepted member. Only active groups are returned.
     * @summary Return groups filtered by group type
     * @param {GroupsApiFindGroupsByType1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findGroupsByType1(requestParameters: GroupsApiFindGroupsByType1Request = {}, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findGroupsByType1(requestParameters.types, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This will return both owned Groups and Groups the user is a member of. Each group includes a \'userAdmin\' field indicating whether the current user is an admin or owner of that group.
     * @summary Return the groups list with specified user id
     * @param {GroupsApiFindGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findGroupsByUser1(requestParameters: GroupsApiFindGroupsByUser1Request = {}, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the groups list with specified user id that are inactive
     * @param {GroupsApiFindInactiveGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findInactiveGroupsByUser1(requestParameters: GroupsApiFindInactiveGroupsByUser1Request = {}, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findInactiveGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of groups where the current user has been invited but has not yet accepted or declined the invitation. These are groups owned by other users who have sent invitations to the current user.
     * @summary Get groups where the user has pending invitations
     * @param {GroupsApiFindInvitedGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findInvitedGroupsByUser1(requestParameters: GroupsApiFindInvitedGroupsByUser1Request = {}, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findInvitedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the groups list with specified user id that user has requested
     * @param {GroupsApiFindRequestedGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public findRequestedGroupsByUser1(requestParameters: GroupsApiFindRequestedGroupsByUser1Request = {}, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).findRequestedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For Group Owners, this list will return removed, left, invited and requested members as well
     * @summary Show all members of Group
     * @param {GroupsApiGetGroupMembers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupMembers1(requestParameters: GroupsApiGetGroupMembers1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupMembers1(requestParameters.groupId, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Invitation to Group
     * @param {GroupsApiGroupInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupInvite(requestParameters: GroupsApiGroupInviteRequest, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupInvite(requestParameters.groupId, requestParameters.userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Accept Group Invitation
     * @param {GroupsApiGroupInvite2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupInvite2(requestParameters: GroupsApiGroupInvite2Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupInvite2(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Leave Group
     * @param {GroupsApiGroupLeave1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupLeave1(requestParameters: GroupsApiGroupLeave1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupLeave1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request Admission to Group
     * @param {GroupsApiGroupRequest1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupRequest1(requestParameters: GroupsApiGroupRequest1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupRequest1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Only group owners can promote members to admin. Can only promote ACCEPTED members.
     * @summary Promote group members to admin
     * @param {GroupsApiPromoteToAdmin1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public promoteToAdmin1(requestParameters: GroupsApiPromoteToAdmin1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).promoteToAdmin1(requestParameters.groupId, requestParameters.userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows group owners to request a change in their group type from GROUP to ASSOCIATION or CERTIFICATION. IMPORTANT: Type changes are only allowed for basic groups (GROUP type). Once a group has been upgraded to ASSOCIATION or CERTIFICATION, no further type changes are possible. Only group owners can make these requests.
     * @summary Request a change in group type
     * @param {GroupsApiRequestGroupTypeChange1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public requestGroupTypeChange1(requestParameters: GroupsApiRequestGroupTypeChange1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).requestGroupTypeChange1(requestParameters.id, requestParameters.requestStatus, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Consider that only user can saveNew its groups
     * @summary Create or update the group supplied
     * @param {GroupsApiSaveGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public saveGroup1(requestParameters: GroupsApiSaveGroup1Request = {}, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).saveGroup1(requestParameters.group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {GroupsApiSearchGroupProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public searchGroupProperties1(requestParameters: GroupsApiSearchGroupProperties1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).searchGroupProperties1(requestParameters.groupId, requestParameters.propertyFilterCriteria, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for users within a specific group matching the specified filter criteria
     * @summary Search users within a specified group
     * @param {GroupsApiSearchGroupUsers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public searchGroupUsers1(requestParameters: GroupsApiSearchGroupUsers1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).searchGroupUsers1(requestParameters.groupId, requestParameters.userFilterRequest, requestParameters.bypassCache, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Acceptable Status values are:  ACCEPTED, ADMIN, REJECTED, REMOVED
     * @summary Update the group member status from groupId supplied
     * @param {GroupsApiUpdateGroupMembershipStatus1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupMembershipStatus1(requestParameters: GroupsApiUpdateGroupMembershipStatus1Request, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupMembershipStatus1(requestParameters.groupId, requestParameters.userIds, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RequestGroupTypeChange1RequestStatusEnum = {
    None: 'NONE',
    RequestingAssociation: 'REQUESTING_ASSOCIATION',
    RequestingCertification: 'REQUESTING_CERTIFICATION'
} as const;
export type RequestGroupTypeChange1RequestStatusEnum = typeof RequestGroupTypeChange1RequestStatusEnum[keyof typeof RequestGroupTypeChange1RequestStatusEnum];
/**
 * @export
 */
export const UpdateGroupMembershipStatus1StatusEnum = {
    Accepted: 'ACCEPTED',
    Admin: 'ADMIN',
    Rejected: 'REJECTED',
    Removed: 'REMOVED'
} as const;
export type UpdateGroupMembershipStatus1StatusEnum = typeof UpdateGroupMembershipStatus1StatusEnum[keyof typeof UpdateGroupMembershipStatus1StatusEnum];


/**
 * LanguagesApi - axios parameter creator
 * @export
 */
export const LanguagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {string} [xForwardedFor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages1: async (xForwardedFor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            if (xForwardedFor != null) {
                localVarHeaderParameter['X-Forwarded-For'] = String(xForwardedFor);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguagesApi - functional programming interface
 * @export
 */
export const LanguagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LanguagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {string} [xForwardedFor] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllLanguages1(xForwardedFor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Language>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllLanguages1(xForwardedFor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguagesApi.getAllLanguages1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LanguagesApi - factory interface
 * @export
 */
export const LanguagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LanguagesApiFp(configuration)
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {LanguagesApiGetAllLanguages1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages1(requestParameters: LanguagesApiGetAllLanguages1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<Language>> {
            return localVarFp.getAllLanguages1(requestParameters.xForwardedFor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getAllLanguages1 operation in LanguagesApi.
 * @export
 * @interface LanguagesApiGetAllLanguages1Request
 */
export interface LanguagesApiGetAllLanguages1Request {
    /**
     * 
     * @type {string}
     * @memberof LanguagesApiGetAllLanguages1
     */
    readonly xForwardedFor?: string
}

/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
export class LanguagesApi extends BaseAPI {
    /**
     * Returns a list of all supported languages in the system
     * @summary Get all available languages
     * @param {LanguagesApiGetAllLanguages1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    public getAllLanguages1(requestParameters: LanguagesApiGetAllLanguages1Request = {}, options?: RawAxiosRequestConfig) {
        return LanguagesApiFp(this.configuration).getAllLanguages1(requestParameters.xForwardedFor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocalesApi - axios parameter creator
 * @export
 */
export const LocalesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {string} pnemonic 
         * @param {string} [securityKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (pnemonic: string, securityKey?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pnemonic' is not null or undefined
            assertParamExists('delete1', 'pnemonic', pnemonic)
            const localVarPath = `/locales/{pnemonic}`
                .replace(`{${"pnemonic"}}`, encodeURIComponent(String(pnemonic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            if (securityKey != null) {
                localVarHeaderParameter['security-key'] = String(securityKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/locales`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {string} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages1: async (lang?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/locales/translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocalesApi - functional programming interface
 * @export
 */
export const LocalesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocalesApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {string} pnemonic 
         * @param {string} [securityKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(pnemonic: string, securityKey?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(pnemonic, securityKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalesApi.delete1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LocaleSet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalesApi.find1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {string} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLanguages1(lang?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLanguages1(lang, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalesApi.getLanguages1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocalesApi - factory interface
 * @export
 */
export const LocalesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocalesApiFp(configuration)
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {LocalesApiDelete1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(requestParameters: LocalesApiDelete1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.delete1(requestParameters.pnemonic, requestParameters.securityKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1(options?: RawAxiosRequestConfig): AxiosPromise<Array<LocaleSet>> {
            return localVarFp.find1(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {LocalesApiGetLanguages1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages1(requestParameters: LocalesApiGetLanguages1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getLanguages1(requestParameters.lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for delete1 operation in LocalesApi.
 * @export
 * @interface LocalesApiDelete1Request
 */
export interface LocalesApiDelete1Request {
    /**
     * 
     * @type {string}
     * @memberof LocalesApiDelete1
     */
    readonly pnemonic: string

    /**
     * 
     * @type {string}
     * @memberof LocalesApiDelete1
     */
    readonly securityKey?: string
}

/**
 * Request parameters for getLanguages1 operation in LocalesApi.
 * @export
 * @interface LocalesApiGetLanguages1Request
 */
export interface LocalesApiGetLanguages1Request {
    /**
     * 
     * @type {string}
     * @memberof LocalesApiGetLanguages1
     */
    readonly lang?: string
}

/**
 * LocalesApi - object-oriented interface
 * @export
 * @class LocalesApi
 * @extends {BaseAPI}
 */
export class LocalesApi extends BaseAPI {
    /**
     * Removes a locale entry identified by its pnemonic code along with all its translations
     * @summary Delete a locale entry with all translations related
     * @param {LocalesApiDelete1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    public delete1(requestParameters: LocalesApiDelete1Request, options?: RawAxiosRequestConfig) {
        return LocalesApiFp(this.configuration).delete1(requestParameters.pnemonic, requestParameters.securityKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the complete list of available locales in the system
     * @summary Returns all language list locale entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    public find1(options?: RawAxiosRequestConfig) {
        return LocalesApiFp(this.configuration).find1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the locale translations in the specified language
     * @summary Returns locale language list
     * @param {LocalesApiGetLanguages1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    public getLanguages1(requestParameters: LocalesApiGetLanguages1Request = {}, options?: RawAxiosRequestConfig) {
        return LocalesApiFp(this.configuration).getLanguages1(requestParameters.lang, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LocationCacheApi - axios parameter creator
 * @export
 */
export const LocationCacheApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns detailed statistics about all location caches including hit rates, entry counts, and memory usage
         * @summary Get location cache statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCacheStatistics1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location/cache/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates all location caches. Use with caution - this will clear all cached location data.
         * @summary Invalidate all location caches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateAllCaches1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/location/cache/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates the geocoding cache entry for a specific address and country
         * @summary Invalidate geocoding cache
         * @param {string} address The formatted address
         * @param {string} countryCode The country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateGeocodingCache1: async (address: string, countryCode: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('invalidateGeocodingCache1', 'address', address)
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('invalidateGeocodingCache1', 'countryCode', countryCode)
            const localVarPath = `/location/cache/geocoding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates the places search cache entry for specific search text
         * @summary Invalidate places search cache
         * @param {string} text Search text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatePlacesSearchCache1: async (text: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'text' is not null or undefined
            assertParamExists('invalidatePlacesSearchCache1', 'text', text)
            const localVarPath = `/location/cache/places-search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Invalidates the reverse geocoding cache entry for specific coordinates
         * @summary Invalidate reverse geocoding cache
         * @param {number} latitude Latitude
         * @param {number} longitude Longitude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateReverseGeocodingCache1: async (latitude: number, longitude: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('invalidateReverseGeocodingCache1', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('invalidateReverseGeocodingCache1', 'longitude', longitude)
            const localVarPath = `/location/cache/reverse-geocoding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocationCacheApi - functional programming interface
 * @export
 */
export const LocationCacheApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocationCacheApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns detailed statistics about all location caches including hit rates, entry counts, and memory usage
         * @summary Get location cache statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCacheStatistics1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCacheStatistics1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationCacheApi.getCacheStatistics1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invalidates all location caches. Use with caution - this will clear all cached location data.
         * @summary Invalidate all location caches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidateAllCaches1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invalidateAllCaches1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationCacheApi.invalidateAllCaches1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invalidates the geocoding cache entry for a specific address and country
         * @summary Invalidate geocoding cache
         * @param {string} address The formatted address
         * @param {string} countryCode The country code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidateGeocodingCache1(address: string, countryCode: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invalidateGeocodingCache1(address, countryCode, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationCacheApi.invalidateGeocodingCache1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invalidates the places search cache entry for specific search text
         * @summary Invalidate places search cache
         * @param {string} text Search text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidatePlacesSearchCache1(text: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invalidatePlacesSearchCache1(text, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationCacheApi.invalidatePlacesSearchCache1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Invalidates the reverse geocoding cache entry for specific coordinates
         * @summary Invalidate reverse geocoding cache
         * @param {number} latitude Latitude
         * @param {number} longitude Longitude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async invalidateReverseGeocodingCache1(latitude: number, longitude: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.invalidateReverseGeocodingCache1(latitude, longitude, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocationCacheApi.invalidateReverseGeocodingCache1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LocationCacheApi - factory interface
 * @export
 */
export const LocationCacheApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocationCacheApiFp(configuration)
    return {
        /**
         * Returns detailed statistics about all location caches including hit rates, entry counts, and memory usage
         * @summary Get location cache statistics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCacheStatistics1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getCacheStatistics1(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates all location caches. Use with caution - this will clear all cached location data.
         * @summary Invalidate all location caches
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateAllCaches1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.invalidateAllCaches1(options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates the geocoding cache entry for a specific address and country
         * @summary Invalidate geocoding cache
         * @param {LocationCacheApiInvalidateGeocodingCache1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateGeocodingCache1(requestParameters: LocationCacheApiInvalidateGeocodingCache1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.invalidateGeocodingCache1(requestParameters.address, requestParameters.countryCode, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates the places search cache entry for specific search text
         * @summary Invalidate places search cache
         * @param {LocationCacheApiInvalidatePlacesSearchCache1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatePlacesSearchCache1(requestParameters: LocationCacheApiInvalidatePlacesSearchCache1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.invalidatePlacesSearchCache1(requestParameters.text, options).then((request) => request(axios, basePath));
        },
        /**
         * Invalidates the reverse geocoding cache entry for specific coordinates
         * @summary Invalidate reverse geocoding cache
         * @param {LocationCacheApiInvalidateReverseGeocodingCache1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateReverseGeocodingCache1(requestParameters: LocationCacheApiInvalidateReverseGeocodingCache1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.invalidateReverseGeocodingCache1(requestParameters.latitude, requestParameters.longitude, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for invalidateGeocodingCache1 operation in LocationCacheApi.
 * @export
 * @interface LocationCacheApiInvalidateGeocodingCache1Request
 */
export interface LocationCacheApiInvalidateGeocodingCache1Request {
    /**
     * The formatted address
     * @type {string}
     * @memberof LocationCacheApiInvalidateGeocodingCache1
     */
    readonly address: string

    /**
     * The country code
     * @type {string}
     * @memberof LocationCacheApiInvalidateGeocodingCache1
     */
    readonly countryCode: string
}

/**
 * Request parameters for invalidatePlacesSearchCache1 operation in LocationCacheApi.
 * @export
 * @interface LocationCacheApiInvalidatePlacesSearchCache1Request
 */
export interface LocationCacheApiInvalidatePlacesSearchCache1Request {
    /**
     * Search text
     * @type {string}
     * @memberof LocationCacheApiInvalidatePlacesSearchCache1
     */
    readonly text: string
}

/**
 * Request parameters for invalidateReverseGeocodingCache1 operation in LocationCacheApi.
 * @export
 * @interface LocationCacheApiInvalidateReverseGeocodingCache1Request
 */
export interface LocationCacheApiInvalidateReverseGeocodingCache1Request {
    /**
     * Latitude
     * @type {number}
     * @memberof LocationCacheApiInvalidateReverseGeocodingCache1
     */
    readonly latitude: number

    /**
     * Longitude
     * @type {number}
     * @memberof LocationCacheApiInvalidateReverseGeocodingCache1
     */
    readonly longitude: number
}

/**
 * LocationCacheApi - object-oriented interface
 * @export
 * @class LocationCacheApi
 * @extends {BaseAPI}
 */
export class LocationCacheApi extends BaseAPI {
    /**
     * Returns detailed statistics about all location caches including hit rates, entry counts, and memory usage
     * @summary Get location cache statistics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationCacheApi
     */
    public getCacheStatistics1(options?: RawAxiosRequestConfig) {
        return LocationCacheApiFp(this.configuration).getCacheStatistics1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates all location caches. Use with caution - this will clear all cached location data.
     * @summary Invalidate all location caches
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationCacheApi
     */
    public invalidateAllCaches1(options?: RawAxiosRequestConfig) {
        return LocationCacheApiFp(this.configuration).invalidateAllCaches1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates the geocoding cache entry for a specific address and country
     * @summary Invalidate geocoding cache
     * @param {LocationCacheApiInvalidateGeocodingCache1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationCacheApi
     */
    public invalidateGeocodingCache1(requestParameters: LocationCacheApiInvalidateGeocodingCache1Request, options?: RawAxiosRequestConfig) {
        return LocationCacheApiFp(this.configuration).invalidateGeocodingCache1(requestParameters.address, requestParameters.countryCode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates the places search cache entry for specific search text
     * @summary Invalidate places search cache
     * @param {LocationCacheApiInvalidatePlacesSearchCache1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationCacheApi
     */
    public invalidatePlacesSearchCache1(requestParameters: LocationCacheApiInvalidatePlacesSearchCache1Request, options?: RawAxiosRequestConfig) {
        return LocationCacheApiFp(this.configuration).invalidatePlacesSearchCache1(requestParameters.text, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Invalidates the reverse geocoding cache entry for specific coordinates
     * @summary Invalidate reverse geocoding cache
     * @param {LocationCacheApiInvalidateReverseGeocodingCache1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocationCacheApi
     */
    public invalidateReverseGeocodingCache1(requestParameters: LocationCacheApiInvalidateReverseGeocodingCache1Request, options?: RawAxiosRequestConfig) {
        return LocationCacheApiFp(this.configuration).invalidateReverseGeocodingCache1(requestParameters.latitude, requestParameters.longitude, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PasswordRecoveryApi - axios parameter creator
 * @export
 */
export const PasswordRecoveryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {string} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail1: async (origin?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password_recovery/send_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryRequest} [passwordRecoveryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword1: async (passwordRecoveryRequest?: PasswordRecoveryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password_recovery/update_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordRecoveryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/password_recovery/validate_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PasswordRecoveryApi - functional programming interface
 * @export
 */
export const PasswordRecoveryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PasswordRecoveryApiAxiosParamCreator(configuration)
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {string} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmail1(origin?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmail1(origin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordRecoveryApi.sendEmail1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryRequest} [passwordRecoveryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePassword1(passwordRecoveryRequest?: PasswordRecoveryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword1(passwordRecoveryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordRecoveryApi.updatePassword1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateToken1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordRecoveryRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateToken1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordRecoveryApi.validateToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PasswordRecoveryApi - factory interface
 * @export
 */
export const PasswordRecoveryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PasswordRecoveryApiFp(configuration)
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {PasswordRecoveryApiSendEmail1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail1(requestParameters: PasswordRecoveryApiSendEmail1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendEmail1(requestParameters.origin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryApiUpdatePassword1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword1(requestParameters: PasswordRecoveryApiUpdatePassword1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updatePassword1(requestParameters.passwordRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken1(options?: RawAxiosRequestConfig): AxiosPromise<PasswordRecoveryRequest> {
            return localVarFp.validateToken1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for sendEmail1 operation in PasswordRecoveryApi.
 * @export
 * @interface PasswordRecoveryApiSendEmail1Request
 */
export interface PasswordRecoveryApiSendEmail1Request {
    /**
     * 
     * @type {string}
     * @memberof PasswordRecoveryApiSendEmail1
     */
    readonly origin?: string
}

/**
 * Request parameters for updatePassword1 operation in PasswordRecoveryApi.
 * @export
 * @interface PasswordRecoveryApiUpdatePassword1Request
 */
export interface PasswordRecoveryApiUpdatePassword1Request {
    /**
     * 
     * @type {PasswordRecoveryRequest}
     * @memberof PasswordRecoveryApiUpdatePassword1
     */
    readonly passwordRecoveryRequest?: PasswordRecoveryRequest
}

/**
 * PasswordRecoveryApi - object-oriented interface
 * @export
 * @class PasswordRecoveryApi
 * @extends {BaseAPI}
 */
export class PasswordRecoveryApi extends BaseAPI {
    /**
     * In this email it will be contained all process information to change password and recover access
     * @summary Send an email to user that has forgotted his/her password
     * @param {PasswordRecoveryApiSendEmail1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    public sendEmail1(requestParameters: PasswordRecoveryApiSendEmail1Request = {}, options?: RawAxiosRequestConfig) {
        return PasswordRecoveryApiFp(this.configuration).sendEmail1(requestParameters.origin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update the password user, finishing the recovery password process
     * @param {PasswordRecoveryApiUpdatePassword1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    public updatePassword1(requestParameters: PasswordRecoveryApiUpdatePassword1Request = {}, options?: RawAxiosRequestConfig) {
        return PasswordRecoveryApiFp(this.configuration).updatePassword1(requestParameters.passwordRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Validate that password recovery token supplied was valid and current
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    public validateToken1(options?: RawAxiosRequestConfig) {
        return PasswordRecoveryApiFp(this.configuration).validateToken1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PhonePrefixesApi - axios parameter creator
 * @export
 */
export const PhonePrefixesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/country-phone-prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PhonePrefixesApi - functional programming interface
 * @export
 */
export const PhonePrefixesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PhonePrefixesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CountryPhonePrefix>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhonePrefixesApi.get2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PhonePrefixesApi - factory interface
 * @export
 */
export const PhonePrefixesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PhonePrefixesApiFp(configuration)
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2(options?: RawAxiosRequestConfig): AxiosPromise<Array<CountryPhonePrefix>> {
            return localVarFp.get2(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PhonePrefixesApi - object-oriented interface
 * @export
 * @class PhonePrefixesApi
 * @extends {BaseAPI}
 */
export class PhonePrefixesApi extends BaseAPI {
    /**
     * Retrieves a list of all available country phone prefixes with their details
     * @summary Returns all country-phone-prefixes list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhonePrefixesApi
     */
    public get2(options?: RawAxiosRequestConfig) {
        return PhonePrefixesApiFp(this.configuration).get2(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertiesApi - axios parameter creator
 * @export
 */
export const PropertiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Publication state update
         * @param {string} propertyId Property ID
         * @param {PropertyPublicationStateRequest} propertyPublicationStateRequest Request body containing the publication state to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus2: async (propertyId: string, propertyPublicationStateRequest: PropertyPublicationStateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('changePublicationStatus2', 'propertyId', propertyId)
            // verify required parameter 'propertyPublicationStateRequest' is not null or undefined
            assertParamExists('changePublicationStatus2', 'propertyPublicationStateRequest', propertyPublicationStateRequest)
            const localVarPath = `/properties/{propertyId}/publication-state`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyPublicationStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {string} id Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProperty1', 'id', id)
            const localVarPath = `/properties/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch random list of properties related to a given property
         * @param {string} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties: async (propertyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('fetchRandomProperties', 'propertyId', propertyId)
            const localVarPath = `/properties/{propertyId}/related-properties`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/fetch-random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search properties with specified filters. Use the /property_filters endpoint before to get the available filters.
         * @param {PropertyFilterCriteria} propertyFilterCriteria Property filter criteria
         * @param {boolean} [bypassCache] Bypass cache and fetch fresh data from database
         * @param {boolean} [includeNotAvailableProperties] Include properties that are not available anymore (e.g., sold, rented, removed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperties1: async (propertyFilterCriteria: PropertyFilterCriteria, bypassCache?: boolean, includeNotAvailableProperties?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyFilterCriteria' is not null or undefined
            assertParamExists('findProperties1', 'propertyFilterCriteria', propertyFilterCriteria)
            const localVarPath = `/properties/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (bypassCache !== undefined) {
                localVarQueryParameter['bypassCache'] = bypassCache;
            }

            if (includeNotAvailableProperties !== undefined) {
                localVarQueryParameter['includeNotAvailableProperties'] = includeNotAvailableProperties;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyFilterCriteria, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {string} range location range
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPropertiesByLocationRange1: async (range: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'range' is not null or undefined
            assertParamExists('findPropertiesByLocationRange1', 'range', range)
            const localVarPath = `/properties/by_location_range/{range}`
                .replace(`{${"range"}}`, encodeURIComponent(String(range)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} propertyId Property ID
         * @param {string} [password] Password for protected properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperty1: async (propertyId: string, password?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('findProperty1', 'propertyId', propertyId)
            const localVarPath = `/properties/{propertyId}`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id. The property user includes subscription plan information.
         * @summary Return the property with specified id
         * @param {string} id property id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertyOldUrl1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findPropertyOldUrl1', 'id', id)
            const localVarPath = `/properties/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftsProperties1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns recently created properties excluding password-protected and draft properties
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {string} [email] Email to filter properties by user
         * @param {number} [minutes] Minutes to look back (default 60)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProperties1: async (email?: string, minutes?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (minutes !== undefined) {
                localVarQueryParameter['minutes'] = minutes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuredProperties1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/password-protected`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {string} id Property ID to generate preview for
         * @param {string} [lang] Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
         * @param {string} [acceptLanguage] Browser\&#39;s accepted language header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty2: async (id: string, lang?: string, acceptLanguage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('previewProperty2', 'id', id)
            const localVarPath = `/properties/previews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {Property} property Property to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProperty1: async (property: Property, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'property' is not null or undefined
            assertParamExists('saveProperty1', 'property', property)
            const localVarPath = `/properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WeeklyAlertRange} [weeklyAlertRange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert2: async (weeklyAlertRange?: WeeklyAlertRange, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/weekly-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=UTF-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(weeklyAlertRange, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGroupAlert1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/properties/weekly-group-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertiesApi - functional programming interface
 * @export
 */
export const PropertiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Publication state update
         * @param {string} propertyId Property ID
         * @param {PropertyPublicationStateRequest} propertyPublicationStateRequest Request body containing the publication state to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePublicationStatus2(propertyId: string, propertyPublicationStateRequest: PropertyPublicationStateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePublicationStatus2(propertyId, propertyPublicationStateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.changePublicationStatus2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {string} id Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProperty1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProperty1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.deleteProperty1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch random list of properties related to a given property
         * @param {string} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomProperties(propertyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomProperties(propertyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.fetchRandomProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomProperties2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomProperties2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.fetchRandomProperties2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Search properties with specified filters. Use the /property_filters endpoint before to get the available filters.
         * @param {PropertyFilterCriteria} propertyFilterCriteria Property filter criteria
         * @param {boolean} [bypassCache] Bypass cache and fetch fresh data from database
         * @param {boolean} [includeNotAvailableProperties] Include properties that are not available anymore (e.g., sold, rented, removed)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProperties1(propertyFilterCriteria: PropertyFilterCriteria, bypassCache?: boolean, includeNotAvailableProperties?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProperties1(propertyFilterCriteria, bypassCache, includeNotAvailableProperties, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {string} range location range
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findPropertiesByLocationRange1(range: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertiesByLocationRange1(range, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findPropertiesByLocationRange1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} propertyId Property ID
         * @param {string} [password] Password for protected properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProperty1(propertyId: string, password?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProperty1(propertyId, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findProperty1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id. The property user includes subscription plan information.
         * @summary Return the property with specified id
         * @param {string} id property id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPropertyOldUrl1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertyOldUrl1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findPropertyOldUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDraftsProperties1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDraftsProperties1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getDraftsProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns recently created properties excluding password-protected and draft properties
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {string} [email] Email to filter properties by user
         * @param {number} [minutes] Minutes to look back (default 60)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentProperties1(email?: string, minutes?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentProperties1(email, minutes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getRecentProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecuredProperties1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Property>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecuredProperties1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getSecuredProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {string} id Property ID to generate preview for
         * @param {string} [lang] Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
         * @param {string} [acceptLanguage] Browser\&#39;s accepted language header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewProperty2(id: string, lang?: string, acceptLanguage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewProperty2(id, lang, acceptLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.previewProperty2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {Property} property Property to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveProperty1(property: Property, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveProperty1(property, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.saveProperty1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {WeeklyAlertRange} [weeklyAlertRange] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendAlert2(weeklyAlertRange?: WeeklyAlertRange, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendAlert2(weeklyAlertRange, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.sendAlert2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendGroupAlert1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendGroupAlert1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.sendGroupAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertiesApi - factory interface
 * @export
 */
export const PropertiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertiesApiFp(configuration)
    return {
        /**
         * 
         * @summary Publication state update
         * @param {PropertiesApiChangePublicationStatus2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus2(requestParameters: PropertiesApiChangePublicationStatus2Request, options?: RawAxiosRequestConfig): AxiosPromise<Property> {
            return localVarFp.changePublicationStatus2(requestParameters.propertyId, requestParameters.propertyPublicationStateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {PropertiesApiDeleteProperty1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty1(requestParameters: PropertiesApiDeleteProperty1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.deleteProperty1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch random list of properties related to a given property
         * @param {PropertiesApiFetchRandomPropertiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties(requestParameters: PropertiesApiFetchRandomPropertiesRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.fetchRandomProperties(requestParameters.propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties2(options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.fetchRandomProperties2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search properties with specified filters. Use the /property_filters endpoint before to get the available filters.
         * @param {PropertiesApiFindProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperties1(requestParameters: PropertiesApiFindProperties1Request, options?: RawAxiosRequestConfig): AxiosPromise<PropertyFilterResult> {
            return localVarFp.findProperties1(requestParameters.propertyFilterCriteria, requestParameters.bypassCache, requestParameters.includeNotAvailableProperties, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {PropertiesApiFindPropertiesByLocationRange1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPropertiesByLocationRange1(requestParameters: PropertiesApiFindPropertiesByLocationRange1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.findPropertiesByLocationRange1(requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {PropertiesApiFindProperty1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperty1(requestParameters: PropertiesApiFindProperty1Request, options?: RawAxiosRequestConfig): AxiosPromise<Property> {
            return localVarFp.findProperty1(requestParameters.propertyId, requestParameters.password, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id. The property user includes subscription plan information.
         * @summary Return the property with specified id
         * @param {PropertiesApiFindPropertyOldUrl1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertyOldUrl1(requestParameters: PropertiesApiFindPropertyOldUrl1Request, options?: RawAxiosRequestConfig): AxiosPromise<Property> {
            return localVarFp.findPropertyOldUrl1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftsProperties1(options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.getDraftsProperties1(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns recently created properties excluding password-protected and draft properties
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {PropertiesApiGetRecentProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProperties1(requestParameters: PropertiesApiGetRecentProperties1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.getRecentProperties1(requestParameters.email, requestParameters.minutes, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuredProperties1(options?: RawAxiosRequestConfig): AxiosPromise<Array<Property>> {
            return localVarFp.getSecuredProperties1(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {PropertiesApiPreviewProperty2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty2(requestParameters: PropertiesApiPreviewProperty2Request, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.previewProperty2(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {PropertiesApiSaveProperty1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProperty1(requestParameters: PropertiesApiSaveProperty1Request, options?: RawAxiosRequestConfig): AxiosPromise<Property> {
            return localVarFp.saveProperty1(requestParameters.property, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PropertiesApiSendAlert2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert2(requestParameters: PropertiesApiSendAlert2Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.sendAlert2(requestParameters.weeklyAlertRange, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGroupAlert1(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.sendGroupAlert1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changePublicationStatus2 operation in PropertiesApi.
 * @export
 * @interface PropertiesApiChangePublicationStatus2Request
 */
export interface PropertiesApiChangePublicationStatus2Request {
    /**
     * Property ID
     * @type {string}
     * @memberof PropertiesApiChangePublicationStatus2
     */
    readonly propertyId: string

    /**
     * Request body containing the publication state to set
     * @type {PropertyPublicationStateRequest}
     * @memberof PropertiesApiChangePublicationStatus2
     */
    readonly propertyPublicationStateRequest: PropertyPublicationStateRequest
}

/**
 * Request parameters for deleteProperty1 operation in PropertiesApi.
 * @export
 * @interface PropertiesApiDeleteProperty1Request
 */
export interface PropertiesApiDeleteProperty1Request {
    /**
     * Property ID
     * @type {string}
     * @memberof PropertiesApiDeleteProperty1
     */
    readonly id: string
}

/**
 * Request parameters for fetchRandomProperties operation in PropertiesApi.
 * @export
 * @interface PropertiesApiFetchRandomPropertiesRequest
 */
export interface PropertiesApiFetchRandomPropertiesRequest {
    /**
     * Property ID
     * @type {string}
     * @memberof PropertiesApiFetchRandomProperties
     */
    readonly propertyId: string
}

/**
 * Request parameters for findProperties1 operation in PropertiesApi.
 * @export
 * @interface PropertiesApiFindProperties1Request
 */
export interface PropertiesApiFindProperties1Request {
    /**
     * Property filter criteria
     * @type {PropertyFilterCriteria}
     * @memberof PropertiesApiFindProperties1
     */
    readonly propertyFilterCriteria: PropertyFilterCriteria

    /**
     * Bypass cache and fetch fresh data from database
     * @type {boolean}
     * @memberof PropertiesApiFindProperties1
     */
    readonly bypassCache?: boolean

    /**
     * Include properties that are not available anymore (e.g., sold, rented, removed)
     * @type {boolean}
     * @memberof PropertiesApiFindProperties1
     */
    readonly includeNotAvailableProperties?: boolean
}

/**
 * Request parameters for findPropertiesByLocationRange1 operation in PropertiesApi.
 * @export
 * @interface PropertiesApiFindPropertiesByLocationRange1Request
 */
export interface PropertiesApiFindPropertiesByLocationRange1Request {
    /**
     * location range
     * @type {string}
     * @memberof PropertiesApiFindPropertiesByLocationRange1
     */
    readonly range: string
}

/**
 * Request parameters for findProperty1 operation in PropertiesApi.
 * @export
 * @interface PropertiesApiFindProperty1Request
 */
export interface PropertiesApiFindProperty1Request {
    /**
     * Property ID
     * @type {string}
     * @memberof PropertiesApiFindProperty1
     */
    readonly propertyId: string

    /**
     * Password for protected properties
     * @type {string}
     * @memberof PropertiesApiFindProperty1
     */
    readonly password?: string
}

/**
 * Request parameters for findPropertyOldUrl1 operation in PropertiesApi.
 * @export
 * @interface PropertiesApiFindPropertyOldUrl1Request
 */
export interface PropertiesApiFindPropertyOldUrl1Request {
    /**
     * property id
     * @type {string}
     * @memberof PropertiesApiFindPropertyOldUrl1
     */
    readonly id: string
}

/**
 * Request parameters for getRecentProperties1 operation in PropertiesApi.
 * @export
 * @interface PropertiesApiGetRecentProperties1Request
 */
export interface PropertiesApiGetRecentProperties1Request {
    /**
     * Email to filter properties by user
     * @type {string}
     * @memberof PropertiesApiGetRecentProperties1
     */
    readonly email?: string

    /**
     * Minutes to look back (default 60)
     * @type {number}
     * @memberof PropertiesApiGetRecentProperties1
     */
    readonly minutes?: number
}

/**
 * Request parameters for previewProperty2 operation in PropertiesApi.
 * @export
 * @interface PropertiesApiPreviewProperty2Request
 */
export interface PropertiesApiPreviewProperty2Request {
    /**
     * Property ID to generate preview for
     * @type {string}
     * @memberof PropertiesApiPreviewProperty2
     */
    readonly id: string

    /**
     * Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
     * @type {string}
     * @memberof PropertiesApiPreviewProperty2
     */
    readonly lang?: string

    /**
     * Browser\&#39;s accepted language header
     * @type {string}
     * @memberof PropertiesApiPreviewProperty2
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for saveProperty1 operation in PropertiesApi.
 * @export
 * @interface PropertiesApiSaveProperty1Request
 */
export interface PropertiesApiSaveProperty1Request {
    /**
     * Property to persist
     * @type {Property}
     * @memberof PropertiesApiSaveProperty1
     */
    readonly property: Property
}

/**
 * Request parameters for sendAlert2 operation in PropertiesApi.
 * @export
 * @interface PropertiesApiSendAlert2Request
 */
export interface PropertiesApiSendAlert2Request {
    /**
     * 
     * @type {WeeklyAlertRange}
     * @memberof PropertiesApiSendAlert2
     */
    readonly weeklyAlertRange?: WeeklyAlertRange
}

/**
 * PropertiesApi - object-oriented interface
 * @export
 * @class PropertiesApi
 * @extends {BaseAPI}
 */
export class PropertiesApi extends BaseAPI {
    /**
     * 
     * @summary Publication state update
     * @param {PropertiesApiChangePublicationStatus2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public changePublicationStatus2(requestParameters: PropertiesApiChangePublicationStatus2Request, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).changePublicationStatus2(requestParameters.propertyId, requestParameters.propertyPublicationStateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This process is not reversible
     * @summary Delete the property with id supplied
     * @param {PropertiesApiDeleteProperty1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public deleteProperty1(requestParameters: PropertiesApiDeleteProperty1Request, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).deleteProperty1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch random list of properties related to a given property
     * @param {PropertiesApiFetchRandomPropertiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public fetchRandomProperties(requestParameters: PropertiesApiFetchRandomPropertiesRequest, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).fetchRandomProperties(requestParameters.propertyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a randomized list of properties with the specified count limit
     * @summary Fetch random list of properties, with basic data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public fetchRandomProperties2(options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).fetchRandomProperties2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search properties with specified filters. Use the /property_filters endpoint before to get the available filters.
     * @param {PropertiesApiFindProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public findProperties1(requestParameters: PropertiesApiFindProperties1Request, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).findProperties1(requestParameters.propertyFilterCriteria, requestParameters.bypassCache, requestParameters.includeNotAvailableProperties, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the property list with specified user id
     * @param {PropertiesApiFindPropertiesByLocationRange1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public findPropertiesByLocationRange1(requestParameters: PropertiesApiFindPropertiesByLocationRange1Request, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).findPropertiesByLocationRange1(requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter the properties existing in system with specified id. Returns empty if none property match the id
     * @summary Return the property with specified id
     * @param {PropertiesApiFindProperty1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public findProperty1(requestParameters: PropertiesApiFindProperty1Request, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).findProperty1(requestParameters.propertyId, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Filter the properties existing in system with specified id. Returns empty if none property match the id. The property user includes subscription plan information.
     * @summary Return the property with specified id
     * @param {PropertiesApiFindPropertyOldUrl1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public findPropertyOldUrl1(requestParameters: PropertiesApiFindPropertyOldUrl1Request, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).findPropertyOldUrl1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Password Protected Property for Signed in User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public getDraftsProperties1(options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).getDraftsProperties1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns recently created properties excluding password-protected and draft properties
     * @summary Get recently created properties within specified minutes (default 60)
     * @param {PropertiesApiGetRecentProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public getRecentProperties1(requestParameters: PropertiesApiGetRecentProperties1Request = {}, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).getRecentProperties1(requestParameters.email, requestParameters.minutes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Password Protected Property for Signed in User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public getSecuredProperties1(options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).getSecuredProperties1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns HTML preview for sharing a property on social media or messaging apps
     * @summary Get HTML preview for a property
     * @param {PropertiesApiPreviewProperty2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public previewProperty2(requestParameters: PropertiesApiPreviewProperty2Request, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).previewProperty2(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Consider that only user can saveNew its properties
     * @summary Create or update the property supplied
     * @param {PropertiesApiSaveProperty1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public saveProperty1(requestParameters: PropertiesApiSaveProperty1Request, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).saveProperty1(requestParameters.property, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PropertiesApiSendAlert2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public sendAlert2(requestParameters: PropertiesApiSendAlert2Request = {}, options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).sendAlert2(requestParameters.weeklyAlertRange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    public sendGroupAlert1(options?: RawAxiosRequestConfig) {
        return PropertiesApiFp(this.configuration).sendGroupAlert1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyBulkDownloadApi - axios parameter creator
 * @export
 */
export const PropertyBulkDownloadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerKyeroExport1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-bulk-download/trigger-kyero-export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type (e.g., kyero, idealista)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xml1: async (userId: string, xmlFormat: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('xml1', 'userId', userId)
            // verify required parameter 'xmlFormat' is not null or undefined
            assertParamExists('xml1', 'xmlFormat', xmlFormat)
            const localVarPath = `/property-bulk-download/{userId}/{xmlFormat}.xml`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"xmlFormat"}}`, encodeURIComponent(String(xmlFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        xmlRedirect1: async (userId: string, xmlFormat: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('xmlRedirect1', 'userId', userId)
            // verify required parameter 'xmlFormat' is not null or undefined
            assertParamExists('xmlRedirect1', 'xmlFormat', xmlFormat)
            const localVarPath = `/property-bulk-download/{userId}/{xmlFormat}.xml.redirect`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"xmlFormat"}}`, encodeURIComponent(String(xmlFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyBulkDownloadApi - functional programming interface
 * @export
 */
export const PropertyBulkDownloadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyBulkDownloadApiAxiosParamCreator(configuration)
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerKyeroExport1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerKyeroExport1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkDownloadApi.triggerKyeroExport1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type (e.g., kyero, idealista)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async xml1(userId: string, xmlFormat: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.xml1(userId, xmlFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkDownloadApi.xml1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async xmlRedirect1(userId: string, xmlFormat: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.xmlRedirect1(userId, xmlFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkDownloadApi.xmlRedirect1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyBulkDownloadApi - factory interface
 * @export
 */
export const PropertyBulkDownloadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyBulkDownloadApiFp(configuration)
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerKyeroExport1(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.triggerKyeroExport1(options).then((request) => request(axios, basePath));
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {PropertyBulkDownloadApiXml1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xml1(requestParameters: PropertyBulkDownloadApiXml1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.xml1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {PropertyBulkDownloadApiXmlRedirect1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        xmlRedirect1(requestParameters: PropertyBulkDownloadApiXmlRedirect1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.xmlRedirect1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for xml1 operation in PropertyBulkDownloadApi.
 * @export
 * @interface PropertyBulkDownloadApiXml1Request
 */
export interface PropertyBulkDownloadApiXml1Request {
    /**
     * User ID for the property owner
     * @type {string}
     * @memberof PropertyBulkDownloadApiXml1
     */
    readonly userId: string

    /**
     * XML format type (e.g., kyero, idealista)
     * @type {string}
     * @memberof PropertyBulkDownloadApiXml1
     */
    readonly xmlFormat: string
}

/**
 * Request parameters for xmlRedirect1 operation in PropertyBulkDownloadApi.
 * @export
 * @interface PropertyBulkDownloadApiXmlRedirect1Request
 */
export interface PropertyBulkDownloadApiXmlRedirect1Request {
    /**
     * User ID for the property owner
     * @type {string}
     * @memberof PropertyBulkDownloadApiXmlRedirect1
     */
    readonly userId: string

    /**
     * XML format type
     * @type {string}
     * @memberof PropertyBulkDownloadApiXmlRedirect1
     */
    readonly xmlFormat: string
}

/**
 * PropertyBulkDownloadApi - object-oriented interface
 * @export
 * @class PropertyBulkDownloadApi
 * @extends {BaseAPI}
 */
export class PropertyBulkDownloadApi extends BaseAPI {
    /**
     * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
     * @summary Manually trigger Kyero exports to S3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    public triggerKyeroExport1(options?: RawAxiosRequestConfig) {
        return PropertyBulkDownloadApiFp(this.configuration).triggerKyeroExport1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates and returns property data in XML format for a specific user and format type.
     * @summary Get property XML for specific user
     * @param {PropertyBulkDownloadApiXml1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    public xml1(requestParameters: PropertyBulkDownloadApiXml1Request, options?: RawAxiosRequestConfig) {
        return PropertyBulkDownloadApiFp(this.configuration).xml1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
     * @summary Redirect to XML file (Deprecated)
     * @param {PropertyBulkDownloadApiXmlRedirect1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    public xmlRedirect1(requestParameters: PropertyBulkDownloadApiXmlRedirect1Request, options?: RawAxiosRequestConfig) {
        return PropertyBulkDownloadApiFp(this.configuration).xmlRedirect1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyBulkUploadsApi - axios parameter creator
 * @export
 */
export const PropertyBulkUploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormats1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-bulk-uploads/formats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {string} [body] Properties XML content in Kyero format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties2: async (body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-bulk-uploads/in-body`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroPropertiesFromUrl1: async (xmlUrl?: XmlUrl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-bulk-uploads/in-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(xmlUrl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {UploadProperties1FormatEnum} format Format identifier
         * @param {string} [body] Properties XML content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProperties1: async (format: UploadProperties1FormatEnum, body?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('uploadProperties1', 'format', format)
            const localVarPath = `/property-bulk-uploads/{format}/in-body`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/xml';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {UploadPropertiesFromUrl1FormatEnum} format Format identifier
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPropertiesFromUrl1: async (format: UploadPropertiesFromUrl1FormatEnum, xmlUrl?: XmlUrl, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('uploadPropertiesFromUrl1', 'format', format)
            const localVarPath = `/property-bulk-uploads/{format}/in-url`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(xmlUrl, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyBulkUploadsApi - functional programming interface
 * @export
 */
export const PropertyBulkUploadsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyBulkUploadsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormats1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormats1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.getFormats1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {string} [body] Properties XML content in Kyero format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroProperties2(body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroProperties2(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadKyeroProperties2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroPropertiesFromUrl1(xmlUrl?: XmlUrl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroPropertiesFromUrl1(xmlUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadKyeroPropertiesFromUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {UploadProperties1FormatEnum} format Format identifier
         * @param {string} [body] Properties XML content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProperties1(format: UploadProperties1FormatEnum, body?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProperties1(format, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {UploadPropertiesFromUrl1FormatEnum} format Format identifier
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPropertiesFromUrl1(format: UploadPropertiesFromUrl1FormatEnum, xmlUrl?: XmlUrl, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPropertiesFromUrl1(format, xmlUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadPropertiesFromUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyBulkUploadsApi - factory interface
 * @export
 */
export const PropertyBulkUploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyBulkUploadsApiFp(configuration)
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormats1(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getFormats1(options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {PropertyBulkUploadsApiUploadKyeroProperties2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties2(requestParameters: PropertyBulkUploadsApiUploadKyeroProperties2Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadKyeroProperties2(requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroPropertiesFromUrl1(requestParameters: PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadKyeroPropertiesFromUrl1(requestParameters.xmlUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {PropertyBulkUploadsApiUploadProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProperties1(requestParameters: PropertyBulkUploadsApiUploadProperties1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadProperties1(requestParameters.format, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {PropertyBulkUploadsApiUploadPropertiesFromUrl1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPropertiesFromUrl1(requestParameters: PropertyBulkUploadsApiUploadPropertiesFromUrl1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.uploadPropertiesFromUrl1(requestParameters.format, requestParameters.xmlUrl, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for uploadKyeroProperties2 operation in PropertyBulkUploadsApi.
 * @export
 * @interface PropertyBulkUploadsApiUploadKyeroProperties2Request
 */
export interface PropertyBulkUploadsApiUploadKyeroProperties2Request {
    /**
     * Properties XML content in Kyero format
     * @type {string}
     * @memberof PropertyBulkUploadsApiUploadKyeroProperties2
     */
    readonly body?: string
}

/**
 * Request parameters for uploadKyeroPropertiesFromUrl1 operation in PropertyBulkUploadsApi.
 * @export
 * @interface PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1Request
 */
export interface PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1Request {
    /**
     * XML URL object
     * @type {XmlUrl}
     * @memberof PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1
     */
    readonly xmlUrl?: XmlUrl
}

/**
 * Request parameters for uploadProperties1 operation in PropertyBulkUploadsApi.
 * @export
 * @interface PropertyBulkUploadsApiUploadProperties1Request
 */
export interface PropertyBulkUploadsApiUploadProperties1Request {
    /**
     * Format identifier
     * @type {'kyero' | 'wasico' | 'xml2u' | 'hallocasa'}
     * @memberof PropertyBulkUploadsApiUploadProperties1
     */
    readonly format: UploadProperties1FormatEnum

    /**
     * Properties XML content
     * @type {string}
     * @memberof PropertyBulkUploadsApiUploadProperties1
     */
    readonly body?: string
}

/**
 * Request parameters for uploadPropertiesFromUrl1 operation in PropertyBulkUploadsApi.
 * @export
 * @interface PropertyBulkUploadsApiUploadPropertiesFromUrl1Request
 */
export interface PropertyBulkUploadsApiUploadPropertiesFromUrl1Request {
    /**
     * Format identifier
     * @type {'kyero' | 'wasico' | 'xml2u' | 'hallocasa'}
     * @memberof PropertyBulkUploadsApiUploadPropertiesFromUrl1
     */
    readonly format: UploadPropertiesFromUrl1FormatEnum

    /**
     * XML URL object
     * @type {XmlUrl}
     * @memberof PropertyBulkUploadsApiUploadPropertiesFromUrl1
     */
    readonly xmlUrl?: XmlUrl
}

/**
 * PropertyBulkUploadsApi - object-oriented interface
 * @export
 * @class PropertyBulkUploadsApi
 * @extends {BaseAPI}
 */
export class PropertyBulkUploadsApi extends BaseAPI {
    /**
     * Get the list of supported file formats for bulk upload
     * @summary Get available formats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    public getFormats1(options?: RawAxiosRequestConfig) {
        return PropertyBulkUploadsApiFp(this.configuration).getFormats1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload properties using Kyero format with XML content in the request body
     * @summary Upload Kyero properties with XML in request body
     * @param {PropertyBulkUploadsApiUploadKyeroProperties2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    public uploadKyeroProperties2(requestParameters: PropertyBulkUploadsApiUploadKyeroProperties2Request = {}, options?: RawAxiosRequestConfig) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadKyeroProperties2(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload properties in Kyero format by providing a URL to an XML file
     * @summary Upload Kyero properties from URL
     * @param {PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    public uploadKyeroPropertiesFromUrl1(requestParameters: PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1Request = {}, options?: RawAxiosRequestConfig) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadKyeroPropertiesFromUrl1(requestParameters.xmlUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload properties with XML content in the request body using the specified format
     * @summary Upload properties in specified format with XML in request body
     * @param {PropertyBulkUploadsApiUploadProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    public uploadProperties1(requestParameters: PropertyBulkUploadsApiUploadProperties1Request, options?: RawAxiosRequestConfig) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadProperties1(requestParameters.format, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload properties in the specified format by providing a URL to an XML file
     * @summary Upload properties in specified format from URL
     * @param {PropertyBulkUploadsApiUploadPropertiesFromUrl1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    public uploadPropertiesFromUrl1(requestParameters: PropertyBulkUploadsApiUploadPropertiesFromUrl1Request, options?: RawAxiosRequestConfig) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadPropertiesFromUrl1(requestParameters.format, requestParameters.xmlUrl, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UploadProperties1FormatEnum = {
    Kyero: 'kyero',
    Wasico: 'wasico',
    Xml2u: 'xml2u',
    Hallocasa: 'hallocasa'
} as const;
export type UploadProperties1FormatEnum = typeof UploadProperties1FormatEnum[keyof typeof UploadProperties1FormatEnum];
/**
 * @export
 */
export const UploadPropertiesFromUrl1FormatEnum = {
    Kyero: 'kyero',
    Wasico: 'wasico',
    Xml2u: 'xml2u',
    Hallocasa: 'hallocasa'
} as const;
export type UploadPropertiesFromUrl1FormatEnum = typeof UploadPropertiesFromUrl1FormatEnum[keyof typeof UploadPropertiesFromUrl1FormatEnum];


/**
 * PropertyFieldsApi - axios parameter creator
 * @export
 */
export const PropertyFieldsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a filtered list of property fields based on the provided property key criteria. This endpoint returns the specific property fields that should be displayed when users select a combination of property type, proposal type, location, and country.  **Important:** All property key parameters (type, proposal, location, country) are required for proper filtering. Incomplete criteria will result in a 400 Bad Request response.  The returned fields are contextually relevant to the specified property characteristics and help users complete property listings with appropriate field options. 
         * @summary Filter property fields by property key criteria
         * @param {PropertyKey} propertyKey Property key criteria for filtering fields. Must include: - **type**: Property type (e.g., \&#39;apartment\&#39;, \&#39;house\&#39;, \&#39;commercial\&#39;) - **proposal**: Proposal type (e.g., \&#39;sale\&#39;, \&#39;rent\&#39;, \&#39;both\&#39;) - **location**: Geographic location identifier - **country**: Country code or identifier  All fields are required for proper filtering functionality. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters2: async (propertyKey: PropertyKey, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyKey' is not null or undefined
            assertParamExists('getPropertyFilters2', 'propertyKey', propertyKey)
            const localVarPath = `/property-fields/filter-by-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyKey, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyFieldsApi - functional programming interface
 * @export
 */
export const PropertyFieldsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyFieldsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a filtered list of property fields based on the provided property key criteria. This endpoint returns the specific property fields that should be displayed when users select a combination of property type, proposal type, location, and country.  **Important:** All property key parameters (type, proposal, location, country) are required for proper filtering. Incomplete criteria will result in a 400 Bad Request response.  The returned fields are contextually relevant to the specified property characteristics and help users complete property listings with appropriate field options. 
         * @summary Filter property fields by property key criteria
         * @param {PropertyKey} propertyKey Property key criteria for filtering fields. Must include: - **type**: Property type (e.g., \&#39;apartment\&#39;, \&#39;house\&#39;, \&#39;commercial\&#39;) - **proposal**: Proposal type (e.g., \&#39;sale\&#39;, \&#39;rent\&#39;, \&#39;both\&#39;) - **location**: Geographic location identifier - **country**: Country code or identifier  All fields are required for proper filtering functionality. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFilters2(propertyKey: PropertyKey, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFilters2(propertyKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyFieldsApi.getPropertyFilters2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyFieldsApi - factory interface
 * @export
 */
export const PropertyFieldsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyFieldsApiFp(configuration)
    return {
        /**
         * Retrieves a filtered list of property fields based on the provided property key criteria. This endpoint returns the specific property fields that should be displayed when users select a combination of property type, proposal type, location, and country.  **Important:** All property key parameters (type, proposal, location, country) are required for proper filtering. Incomplete criteria will result in a 400 Bad Request response.  The returned fields are contextually relevant to the specified property characteristics and help users complete property listings with appropriate field options. 
         * @summary Filter property fields by property key criteria
         * @param {PropertyFieldsApiGetPropertyFilters2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters2(requestParameters: PropertyFieldsApiGetPropertyFilters2Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<PropertyField>> {
            return localVarFp.getPropertyFilters2(requestParameters.propertyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPropertyFilters2 operation in PropertyFieldsApi.
 * @export
 * @interface PropertyFieldsApiGetPropertyFilters2Request
 */
export interface PropertyFieldsApiGetPropertyFilters2Request {
    /**
     * Property key criteria for filtering fields. Must include: - **type**: Property type (e.g., \&#39;apartment\&#39;, \&#39;house\&#39;, \&#39;commercial\&#39;) - **proposal**: Proposal type (e.g., \&#39;sale\&#39;, \&#39;rent\&#39;, \&#39;both\&#39;) - **location**: Geographic location identifier - **country**: Country code or identifier  All fields are required for proper filtering functionality. 
     * @type {PropertyKey}
     * @memberof PropertyFieldsApiGetPropertyFilters2
     */
    readonly propertyKey: PropertyKey
}

/**
 * PropertyFieldsApi - object-oriented interface
 * @export
 * @class PropertyFieldsApi
 * @extends {BaseAPI}
 */
export class PropertyFieldsApi extends BaseAPI {
    /**
     * Retrieves a filtered list of property fields based on the provided property key criteria. This endpoint returns the specific property fields that should be displayed when users select a combination of property type, proposal type, location, and country.  **Important:** All property key parameters (type, proposal, location, country) are required for proper filtering. Incomplete criteria will result in a 400 Bad Request response.  The returned fields are contextually relevant to the specified property characteristics and help users complete property listings with appropriate field options. 
     * @summary Filter property fields by property key criteria
     * @param {PropertyFieldsApiGetPropertyFilters2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFieldsApi
     */
    public getPropertyFilters2(requestParameters: PropertyFieldsApiGetPropertyFilters2Request, options?: RawAxiosRequestConfig) {
        return PropertyFieldsApiFp(this.configuration).getPropertyFilters2(requestParameters.propertyKey, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyFiltersApi - axios parameter creator
 * @export
 */
export const PropertyFiltersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {number} filterId ID of the filter to get options for
         * @param {Array<PropertyFilterSubmission>} propertyFilterSubmission List of property filter submissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFieldOptions1: async (filterId: number, propertyFilterSubmission: Array<PropertyFilterSubmission>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('getPropertyFieldOptions1', 'filterId', filterId)
            // verify required parameter 'propertyFilterSubmission' is not null or undefined
            assertParamExists('getPropertyFieldOptions1', 'propertyFilterSubmission', propertyFilterSubmission)
            const localVarPath = `/property_filters/options/{filter_id}`
                .replace(`{${"filter_id"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyFilterSubmission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {Array<number>} [filterNatureId] Filter nature IDs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters: async (filterNatureId?: Array<number>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (filterNatureId) {
                localVarQueryParameter['filter_nature_id'] = filterNatureId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyFiltersApi - functional programming interface
 * @export
 */
export const PropertyFiltersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyFiltersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {number} filterId ID of the filter to get options for
         * @param {Array<PropertyFilterSubmission>} propertyFilterSubmission List of property filter submissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFieldOptions1(filterId: number, propertyFilterSubmission: Array<PropertyFilterSubmission>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFieldOptions1(filterId, propertyFilterSubmission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyFiltersApi.getPropertyFieldOptions1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {Array<number>} [filterNatureId] Filter nature IDs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFilters(filterNatureId?: Array<number>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyFilter>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFilters(filterNatureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyFiltersApi.getPropertyFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyFiltersApi - factory interface
 * @export
 */
export const PropertyFiltersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyFiltersApiFp(configuration)
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {PropertyFiltersApiGetPropertyFieldOptions1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFieldOptions1(requestParameters: PropertyFiltersApiGetPropertyFieldOptions1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPropertyFieldOptions1(requestParameters.filterId, requestParameters.propertyFilterSubmission, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {PropertyFiltersApiGetPropertyFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters(requestParameters: PropertyFiltersApiGetPropertyFiltersRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<PropertyFilter>> {
            return localVarFp.getPropertyFilters(requestParameters.filterNatureId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPropertyFieldOptions1 operation in PropertyFiltersApi.
 * @export
 * @interface PropertyFiltersApiGetPropertyFieldOptions1Request
 */
export interface PropertyFiltersApiGetPropertyFieldOptions1Request {
    /**
     * ID of the filter to get options for
     * @type {number}
     * @memberof PropertyFiltersApiGetPropertyFieldOptions1
     */
    readonly filterId: number

    /**
     * List of property filter submissions
     * @type {Array<PropertyFilterSubmission>}
     * @memberof PropertyFiltersApiGetPropertyFieldOptions1
     */
    readonly propertyFilterSubmission: Array<PropertyFilterSubmission>
}

/**
 * Request parameters for getPropertyFilters operation in PropertyFiltersApi.
 * @export
 * @interface PropertyFiltersApiGetPropertyFiltersRequest
 */
export interface PropertyFiltersApiGetPropertyFiltersRequest {
    /**
     * Filter nature IDs to filter by
     * @type {Array<number>}
     * @memberof PropertyFiltersApiGetPropertyFilters
     */
    readonly filterNatureId?: Array<number>
}

/**
 * PropertyFiltersApi - object-oriented interface
 * @export
 * @class PropertyFiltersApi
 * @extends {BaseAPI}
 */
export class PropertyFiltersApi extends BaseAPI {
    /**
     * Retrieves options for a specific property filter based on submitted filters
     * @summary Get property field options
     * @param {PropertyFiltersApiGetPropertyFieldOptions1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFiltersApi
     */
    public getPropertyFieldOptions1(requestParameters: PropertyFiltersApiGetPropertyFieldOptions1Request, options?: RawAxiosRequestConfig) {
        return PropertyFiltersApiFp(this.configuration).getPropertyFieldOptions1(requestParameters.filterId, requestParameters.propertyFilterSubmission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of property filters, optionally filtered by filter nature IDs
     * @summary Get property filters
     * @param {PropertyFiltersApiGetPropertyFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFiltersApi
     */
    public getPropertyFilters(requestParameters: PropertyFiltersApiGetPropertyFiltersRequest = {}, options?: RawAxiosRequestConfig) {
        return PropertyFiltersApiFp(this.configuration).getPropertyFilters(requestParameters.filterNatureId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyLocationsApi - axios parameter creator
 * @export
 */
export const PropertyLocationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyLocationsApi - functional programming interface
 * @export
 */
export const PropertyLocationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyLocationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCountries(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyLocation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCountries(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyLocationsApi.getAllCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyLocationsApi - factory interface
 * @export
 */
export const PropertyLocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyLocationsApiFp(configuration)
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries(options?: RawAxiosRequestConfig): AxiosPromise<Array<PropertyLocation>> {
            return localVarFp.getAllCountries(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyLocationsApi - object-oriented interface
 * @export
 * @class PropertyLocationsApi
 * @extends {BaseAPI}
 */
export class PropertyLocationsApi extends BaseAPI {
    /**
     * Retrieves a list of all available property locations
     * @summary Method to find all the property locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyLocationsApi
     */
    public getAllCountries(options?: RawAxiosRequestConfig) {
        return PropertyLocationsApiFp(this.configuration).getAllCountries(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyProposalsApi - axios parameter creator
 * @export
 */
export const PropertyProposalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyProposals1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyProposalsApi - functional programming interface
 * @export
 */
export const PropertyProposalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyProposalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPropertyProposals1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyProposal>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPropertyProposals1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyProposalsApi.getAllPropertyProposals1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyProposalsApi - factory interface
 * @export
 */
export const PropertyProposalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyProposalsApiFp(configuration)
    return {
        /**
         * 
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyProposals1(options?: RawAxiosRequestConfig): AxiosPromise<Array<PropertyProposal>> {
            return localVarFp.getAllPropertyProposals1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyProposalsApi - object-oriented interface
 * @export
 * @class PropertyProposalsApi
 * @extends {BaseAPI}
 */
export class PropertyProposalsApi extends BaseAPI {
    /**
     * 
     * @summary Method to find all the property proposals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyProposalsApi
     */
    public getAllPropertyProposals1(options?: RawAxiosRequestConfig) {
        return PropertyProposalsApiFp(this.configuration).getAllPropertyProposals1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PropertyTypesApi - axios parameter creator
 * @export
 */
export const PropertyTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyTypes1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/property-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyTypesApi - functional programming interface
 * @export
 */
export const PropertyTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PropertyTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPropertyTypes1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PropertyType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPropertyTypes1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyTypesApi.getAllPropertyTypes1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PropertyTypesApi - factory interface
 * @export
 */
export const PropertyTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PropertyTypesApiFp(configuration)
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyTypes1(options?: RawAxiosRequestConfig): AxiosPromise<Array<PropertyType>> {
            return localVarFp.getAllPropertyTypes1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PropertyTypesApi - object-oriented interface
 * @export
 * @class PropertyTypesApi
 * @extends {BaseAPI}
 */
export class PropertyTypesApi extends BaseAPI {
    /**
     * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
     * @summary Get all property types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypesApi
     */
    public getAllPropertyTypes1(options?: RawAxiosRequestConfig) {
        return PropertyTypesApiFp(this.configuration).getAllPropertyTypes1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use a refresh token to obtain a new access token. The refresh token must be valid and not expired.
         * @summary Refresh access token
         * @param {string} grantType Must be \\\&#39;refresh_token\\\&#39;
         * @param {string} refreshToken The refresh token
         * @param {string} clientId Client application identifier
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken1: async (grantType: string, refreshToken: string, clientId: string, clientSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantType' is not null or undefined
            assertParamExists('refreshToken1', 'grantType', grantType)
            // verify required parameter 'refreshToken' is not null or undefined
            assertParamExists('refreshToken1', 'refreshToken', refreshToken)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('refreshToken1', 'clientId', clientId)
            const localVarPath = `/security/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (refreshToken !== undefined) { 
                localVarFormParams.set('refresh_token', refreshToken as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {string} clientId Client application identifier
         * @param {string} code Authorization code received from /auth endpoint
         * @param {string} email User email address
         * @param {string} password User password
         * @param {string} [grantType] OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken1: async (clientId: string, code: string, email: string, password: string, grantType?: string, clientSecret?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('requestToken1', 'clientId', clientId)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('requestToken1', 'code', code)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('requestToken1', 'email', email)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('requestToken1', 'password', password)
            const localVarPath = `/security/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (code !== undefined) { 
                localVarFormParams.set('code', code as any);
            }
    
            if (email !== undefined) { 
                localVarFormParams.set('email', email as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an access token or refresh token
         * @summary Revoke a token
         * @param {string} token The token to revoke
         * @param {string} clientId Client application identifier
         * @param {string} [tokenTypeHint] Hint about the type of token being revoked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken1: async (token: string, clientId: string, tokenTypeHint?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('revokeToken1', 'token', token)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('revokeToken1', 'clientId', clientId)
            const localVarPath = `/security/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


            if (token !== undefined) { 
                localVarFormParams.set('token', token as any);
            }
    
            if (tokenTypeHint !== undefined) { 
                localVarFormParams.set('token_type_hint', tokenTypeHint as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration)
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.authorize1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Use a refresh token to obtain a new access token. The refresh token must be valid and not expired.
         * @summary Refresh access token
         * @param {string} grantType Must be \\\&#39;refresh_token\\\&#39;
         * @param {string} refreshToken The refresh token
         * @param {string} clientId Client application identifier
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken1(grantType: string, refreshToken: string, clientId: string, clientSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken1(grantType, refreshToken, clientId, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.refreshToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {string} clientId Client application identifier
         * @param {string} code Authorization code received from /auth endpoint
         * @param {string} email User email address
         * @param {string} password User password
         * @param {string} [grantType] OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestToken1(clientId: string, code: string, email: string, password: string, grantType?: string, clientSecret?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestToken1(clientId, code, email, password, grantType, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.requestToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke an access token or refresh token
         * @summary Revoke a token
         * @param {string} token The token to revoke
         * @param {string} clientId Client application identifier
         * @param {string} [tokenTypeHint] Hint about the type of token being revoked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeToken1(token: string, clientId: string, tokenTypeHint?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeToken1(token, clientId, tokenTypeHint, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.revokeToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityApiFp(configuration)
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authorize1(options).then((request) => request(axios, basePath));
        },
        /**
         * Use a refresh token to obtain a new access token. The refresh token must be valid and not expired.
         * @summary Refresh access token
         * @param {SecurityApiRefreshToken1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken1(requestParameters: SecurityApiRefreshToken1Request, options?: RawAxiosRequestConfig): AxiosPromise<AuthInfoDto> {
            return localVarFp.refreshToken1(requestParameters.grantType, requestParameters.refreshToken, requestParameters.clientId, requestParameters.clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {SecurityApiRequestToken1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken1(requestParameters: SecurityApiRequestToken1Request, options?: RawAxiosRequestConfig): AxiosPromise<AuthInfoDto> {
            return localVarFp.requestToken1(requestParameters.clientId, requestParameters.code, requestParameters.email, requestParameters.password, requestParameters.grantType, requestParameters.clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an access token or refresh token
         * @summary Revoke a token
         * @param {SecurityApiRevokeToken1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeToken1(requestParameters: SecurityApiRevokeToken1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.revokeToken1(requestParameters.token, requestParameters.clientId, requestParameters.tokenTypeHint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for refreshToken1 operation in SecurityApi.
 * @export
 * @interface SecurityApiRefreshToken1Request
 */
export interface SecurityApiRefreshToken1Request {
    /**
     * Must be \\\&#39;refresh_token\\\&#39;
     * @type {string}
     * @memberof SecurityApiRefreshToken1
     */
    readonly grantType: string

    /**
     * The refresh token
     * @type {string}
     * @memberof SecurityApiRefreshToken1
     */
    readonly refreshToken: string

    /**
     * Client application identifier
     * @type {string}
     * @memberof SecurityApiRefreshToken1
     */
    readonly clientId: string

    /**
     * Client application secret
     * @type {string}
     * @memberof SecurityApiRefreshToken1
     */
    readonly clientSecret?: string
}

/**
 * Request parameters for requestToken1 operation in SecurityApi.
 * @export
 * @interface SecurityApiRequestToken1Request
 */
export interface SecurityApiRequestToken1Request {
    /**
     * Client application identifier
     * @type {string}
     * @memberof SecurityApiRequestToken1
     */
    readonly clientId: string

    /**
     * Authorization code received from /auth endpoint
     * @type {string}
     * @memberof SecurityApiRequestToken1
     */
    readonly code: string

    /**
     * User email address
     * @type {string}
     * @memberof SecurityApiRequestToken1
     */
    readonly email: string

    /**
     * User password
     * @type {string}
     * @memberof SecurityApiRequestToken1
     */
    readonly password: string

    /**
     * OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
     * @type {string}
     * @memberof SecurityApiRequestToken1
     */
    readonly grantType?: string

    /**
     * Client application secret
     * @type {string}
     * @memberof SecurityApiRequestToken1
     */
    readonly clientSecret?: string
}

/**
 * Request parameters for revokeToken1 operation in SecurityApi.
 * @export
 * @interface SecurityApiRevokeToken1Request
 */
export interface SecurityApiRevokeToken1Request {
    /**
     * The token to revoke
     * @type {string}
     * @memberof SecurityApiRevokeToken1
     */
    readonly token: string

    /**
     * Client application identifier
     * @type {string}
     * @memberof SecurityApiRevokeToken1
     */
    readonly clientId: string

    /**
     * Hint about the type of token being revoked
     * @type {string}
     * @memberof SecurityApiRevokeToken1
     */
    readonly tokenTypeHint?: string
}

/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * Generates an authorization code to be used with the token endpoint
     * @summary Authorize client application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public authorize1(options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).authorize1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use a refresh token to obtain a new access token. The refresh token must be valid and not expired.
     * @summary Refresh access token
     * @param {SecurityApiRefreshToken1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public refreshToken1(requestParameters: SecurityApiRefreshToken1Request, options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).refreshToken1(requestParameters.grantType, requestParameters.refreshToken, requestParameters.clientId, requestParameters.clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
     * @summary Exchange authorization code for access token
     * @param {SecurityApiRequestToken1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public requestToken1(requestParameters: SecurityApiRequestToken1Request, options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).requestToken1(requestParameters.clientId, requestParameters.code, requestParameters.email, requestParameters.password, requestParameters.grantType, requestParameters.clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an access token or refresh token
     * @summary Revoke a token
     * @param {SecurityApiRevokeToken1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    public revokeToken1(requestParameters: SecurityApiRevokeToken1Request, options?: RawAxiosRequestConfig) {
        return SecurityApiFp(this.configuration).revokeToken1(requestParameters.token, requestParameters.clientId, requestParameters.tokenTypeHint, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SkillsApi - axios parameter creator
 * @export
 */
export const SkillsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/skills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SkillsApi - functional programming interface
 * @export
 */
export const SkillsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SkillsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSkills2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Skill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSkills2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.retrieveUserSkills2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SkillsApi - factory interface
 * @export
 */
export const SkillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SkillsApiFp(configuration)
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills2(options?: RawAxiosRequestConfig): AxiosPromise<Array<Skill>> {
            return localVarFp.retrieveUserSkills2(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
export class SkillsApi extends BaseAPI {
    /**
     * Returns a list of all available user skills in the system
     * @summary Retrieve all user skills
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    public retrieveUserSkills2(options?: RawAxiosRequestConfig) {
        return SkillsApiFp(this.configuration).retrieveUserSkills2(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeIdentityWebhooksApi - axios parameter creator
 * @export
 */
export const StripeIdentityWebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Called by Stripe when identity verification is canceled or marked as invalid
         * @summary Handle verification canceled webhook
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleVerificationCanceled1: async (stripeEvent?: StripeEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe-identity-webhooks/verification-canceled`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripeEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Called by Stripe when verification needs additional review or is flagged
         * @summary Handle verification requires input webhook
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleVerificationRequiresInput1: async (stripeEvent?: StripeEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe-identity-webhooks/verification-requires-input`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripeEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Called by Stripe when identity verification is successfully completed
         * @summary Handle verification verified webhook
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleVerificationVerified1: async (stripeEvent?: StripeEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe-identity-webhooks/verification-verified`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripeEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeIdentityWebhooksApi - functional programming interface
 * @export
 */
export const StripeIdentityWebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeIdentityWebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * Called by Stripe when identity verification is canceled or marked as invalid
         * @summary Handle verification canceled webhook
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleVerificationCanceled1(stripeEvent?: StripeEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleVerificationCanceled1(stripeEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeIdentityWebhooksApi.handleVerificationCanceled1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Called by Stripe when verification needs additional review or is flagged
         * @summary Handle verification requires input webhook
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleVerificationRequiresInput1(stripeEvent?: StripeEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleVerificationRequiresInput1(stripeEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeIdentityWebhooksApi.handleVerificationRequiresInput1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Called by Stripe when identity verification is successfully completed
         * @summary Handle verification verified webhook
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async handleVerificationVerified1(stripeEvent?: StripeEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.handleVerificationVerified1(stripeEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeIdentityWebhooksApi.handleVerificationVerified1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StripeIdentityWebhooksApi - factory interface
 * @export
 */
export const StripeIdentityWebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeIdentityWebhooksApiFp(configuration)
    return {
        /**
         * Called by Stripe when identity verification is canceled or marked as invalid
         * @summary Handle verification canceled webhook
         * @param {StripeIdentityWebhooksApiHandleVerificationCanceled1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleVerificationCanceled1(requestParameters: StripeIdentityWebhooksApiHandleVerificationCanceled1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.handleVerificationCanceled1(requestParameters.stripeEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * Called by Stripe when verification needs additional review or is flagged
         * @summary Handle verification requires input webhook
         * @param {StripeIdentityWebhooksApiHandleVerificationRequiresInput1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleVerificationRequiresInput1(requestParameters: StripeIdentityWebhooksApiHandleVerificationRequiresInput1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.handleVerificationRequiresInput1(requestParameters.stripeEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * Called by Stripe when identity verification is successfully completed
         * @summary Handle verification verified webhook
         * @param {StripeIdentityWebhooksApiHandleVerificationVerified1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleVerificationVerified1(requestParameters: StripeIdentityWebhooksApiHandleVerificationVerified1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.handleVerificationVerified1(requestParameters.stripeEvent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for handleVerificationCanceled1 operation in StripeIdentityWebhooksApi.
 * @export
 * @interface StripeIdentityWebhooksApiHandleVerificationCanceled1Request
 */
export interface StripeIdentityWebhooksApiHandleVerificationCanceled1Request {
    /**
     * 
     * @type {StripeEvent}
     * @memberof StripeIdentityWebhooksApiHandleVerificationCanceled1
     */
    readonly stripeEvent?: StripeEvent
}

/**
 * Request parameters for handleVerificationRequiresInput1 operation in StripeIdentityWebhooksApi.
 * @export
 * @interface StripeIdentityWebhooksApiHandleVerificationRequiresInput1Request
 */
export interface StripeIdentityWebhooksApiHandleVerificationRequiresInput1Request {
    /**
     * 
     * @type {StripeEvent}
     * @memberof StripeIdentityWebhooksApiHandleVerificationRequiresInput1
     */
    readonly stripeEvent?: StripeEvent
}

/**
 * Request parameters for handleVerificationVerified1 operation in StripeIdentityWebhooksApi.
 * @export
 * @interface StripeIdentityWebhooksApiHandleVerificationVerified1Request
 */
export interface StripeIdentityWebhooksApiHandleVerificationVerified1Request {
    /**
     * 
     * @type {StripeEvent}
     * @memberof StripeIdentityWebhooksApiHandleVerificationVerified1
     */
    readonly stripeEvent?: StripeEvent
}

/**
 * StripeIdentityWebhooksApi - object-oriented interface
 * @export
 * @class StripeIdentityWebhooksApi
 * @extends {BaseAPI}
 */
export class StripeIdentityWebhooksApi extends BaseAPI {
    /**
     * Called by Stripe when identity verification is canceled or marked as invalid
     * @summary Handle verification canceled webhook
     * @param {StripeIdentityWebhooksApiHandleVerificationCanceled1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeIdentityWebhooksApi
     */
    public handleVerificationCanceled1(requestParameters: StripeIdentityWebhooksApiHandleVerificationCanceled1Request = {}, options?: RawAxiosRequestConfig) {
        return StripeIdentityWebhooksApiFp(this.configuration).handleVerificationCanceled1(requestParameters.stripeEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Called by Stripe when verification needs additional review or is flagged
     * @summary Handle verification requires input webhook
     * @param {StripeIdentityWebhooksApiHandleVerificationRequiresInput1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeIdentityWebhooksApi
     */
    public handleVerificationRequiresInput1(requestParameters: StripeIdentityWebhooksApiHandleVerificationRequiresInput1Request = {}, options?: RawAxiosRequestConfig) {
        return StripeIdentityWebhooksApiFp(this.configuration).handleVerificationRequiresInput1(requestParameters.stripeEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Called by Stripe when identity verification is successfully completed
     * @summary Handle verification verified webhook
     * @param {StripeIdentityWebhooksApiHandleVerificationVerified1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeIdentityWebhooksApi
     */
    public handleVerificationVerified1(requestParameters: StripeIdentityWebhooksApiHandleVerificationVerified1Request = {}, options?: RawAxiosRequestConfig) {
        return StripeIdentityWebhooksApiFp(this.configuration).handleVerificationVerified1(requestParameters.stripeEvent, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StripeWebhooksApi - axios parameter creator
 * @export
 */
export const StripeWebhooksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Notify subscription deleted
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionDeleted1: async (stripeEvent?: StripeEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe-webhooks/subscription-deleted`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripeEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Notify subscription paused
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionPaused1: async (stripeEvent?: StripeEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe-webhooks/subscription-paused`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripeEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Notify trial will end
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrialWillEnd1: async (stripeEvent?: StripeEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe-webhooks/trial-will-end`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripeEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Notify user subscription change
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSubscriptionChange1: async (stripeEvent?: StripeEvent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe-webhooks/user-subscription-update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stripeEvent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeWebhooksApi - functional programming interface
 * @export
 */
export const StripeWebhooksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeWebhooksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Notify subscription deleted
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSubscriptionDeleted1(stripeEvent?: StripeEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSubscriptionDeleted1(stripeEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeWebhooksApi.postSubscriptionDeleted1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Notify subscription paused
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postSubscriptionPaused1(stripeEvent?: StripeEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postSubscriptionPaused1(stripeEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeWebhooksApi.postSubscriptionPaused1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Notify trial will end
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTrialWillEnd1(stripeEvent?: StripeEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTrialWillEnd1(stripeEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeWebhooksApi.postTrialWillEnd1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Notify user subscription change
         * @param {StripeEvent} [stripeEvent] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserSubscriptionChange1(stripeEvent?: StripeEvent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserSubscriptionChange1(stripeEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeWebhooksApi.postUserSubscriptionChange1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StripeWebhooksApi - factory interface
 * @export
 */
export const StripeWebhooksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeWebhooksApiFp(configuration)
    return {
        /**
         * 
         * @summary Notify subscription deleted
         * @param {StripeWebhooksApiPostSubscriptionDeleted1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionDeleted1(requestParameters: StripeWebhooksApiPostSubscriptionDeleted1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postSubscriptionDeleted1(requestParameters.stripeEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Notify subscription paused
         * @param {StripeWebhooksApiPostSubscriptionPaused1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postSubscriptionPaused1(requestParameters: StripeWebhooksApiPostSubscriptionPaused1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postSubscriptionPaused1(requestParameters.stripeEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Notify trial will end
         * @param {StripeWebhooksApiPostTrialWillEnd1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTrialWillEnd1(requestParameters: StripeWebhooksApiPostTrialWillEnd1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postTrialWillEnd1(requestParameters.stripeEvent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Notify user subscription change
         * @param {StripeWebhooksApiPostUserSubscriptionChange1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSubscriptionChange1(requestParameters: StripeWebhooksApiPostUserSubscriptionChange1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postUserSubscriptionChange1(requestParameters.stripeEvent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for postSubscriptionDeleted1 operation in StripeWebhooksApi.
 * @export
 * @interface StripeWebhooksApiPostSubscriptionDeleted1Request
 */
export interface StripeWebhooksApiPostSubscriptionDeleted1Request {
    /**
     * 
     * @type {StripeEvent}
     * @memberof StripeWebhooksApiPostSubscriptionDeleted1
     */
    readonly stripeEvent?: StripeEvent
}

/**
 * Request parameters for postSubscriptionPaused1 operation in StripeWebhooksApi.
 * @export
 * @interface StripeWebhooksApiPostSubscriptionPaused1Request
 */
export interface StripeWebhooksApiPostSubscriptionPaused1Request {
    /**
     * 
     * @type {StripeEvent}
     * @memberof StripeWebhooksApiPostSubscriptionPaused1
     */
    readonly stripeEvent?: StripeEvent
}

/**
 * Request parameters for postTrialWillEnd1 operation in StripeWebhooksApi.
 * @export
 * @interface StripeWebhooksApiPostTrialWillEnd1Request
 */
export interface StripeWebhooksApiPostTrialWillEnd1Request {
    /**
     * 
     * @type {StripeEvent}
     * @memberof StripeWebhooksApiPostTrialWillEnd1
     */
    readonly stripeEvent?: StripeEvent
}

/**
 * Request parameters for postUserSubscriptionChange1 operation in StripeWebhooksApi.
 * @export
 * @interface StripeWebhooksApiPostUserSubscriptionChange1Request
 */
export interface StripeWebhooksApiPostUserSubscriptionChange1Request {
    /**
     * 
     * @type {StripeEvent}
     * @memberof StripeWebhooksApiPostUserSubscriptionChange1
     */
    readonly stripeEvent?: StripeEvent
}

/**
 * StripeWebhooksApi - object-oriented interface
 * @export
 * @class StripeWebhooksApi
 * @extends {BaseAPI}
 */
export class StripeWebhooksApi extends BaseAPI {
    /**
     * 
     * @summary Notify subscription deleted
     * @param {StripeWebhooksApiPostSubscriptionDeleted1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeWebhooksApi
     */
    public postSubscriptionDeleted1(requestParameters: StripeWebhooksApiPostSubscriptionDeleted1Request = {}, options?: RawAxiosRequestConfig) {
        return StripeWebhooksApiFp(this.configuration).postSubscriptionDeleted1(requestParameters.stripeEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Notify subscription paused
     * @param {StripeWebhooksApiPostSubscriptionPaused1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeWebhooksApi
     */
    public postSubscriptionPaused1(requestParameters: StripeWebhooksApiPostSubscriptionPaused1Request = {}, options?: RawAxiosRequestConfig) {
        return StripeWebhooksApiFp(this.configuration).postSubscriptionPaused1(requestParameters.stripeEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Notify trial will end
     * @param {StripeWebhooksApiPostTrialWillEnd1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeWebhooksApi
     */
    public postTrialWillEnd1(requestParameters: StripeWebhooksApiPostTrialWillEnd1Request = {}, options?: RawAxiosRequestConfig) {
        return StripeWebhooksApiFp(this.configuration).postTrialWillEnd1(requestParameters.stripeEvent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Notify user subscription change
     * @param {StripeWebhooksApiPostUserSubscriptionChange1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeWebhooksApi
     */
    public postUserSubscriptionChange1(requestParameters: StripeWebhooksApiPostUserSubscriptionChange1Request = {}, options?: RawAxiosRequestConfig) {
        return StripeWebhooksApiFp(this.configuration).postUserSubscriptionChange1(requestParameters.stripeEvent, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('get', 'userId', userId)
            const localVarPath = `/users/{userId}/subscriptions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveFeatures1: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getActiveFeatures1', 'userId', userId)
            const localVarPath = `/users/{userId}/subscriptions/active/features`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the active and available subscription plans
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll1: async (expand?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscription-plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSubscriptionDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveFeatures1(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionPlanFeatureDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveFeatures1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.getActiveFeatures1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the active and available subscription plans
         * @param {Array<string>} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll1(expand?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll1(expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.getAll1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * 
         * @param {SubscriptionsApiGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(requestParameters: SubscriptionsApiGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserSubscriptionDto> {
            return localVarFp.get(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubscriptionsApiGetActiveFeatures1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveFeatures1(requestParameters: SubscriptionsApiGetActiveFeatures1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SubscriptionPlanFeatureDto>> {
            return localVarFp.getActiveFeatures1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the active and available subscription plans
         * @param {SubscriptionsApiGetAll1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll1(requestParameters: SubscriptionsApiGetAll1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.getAll1(requestParameters.expand, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for get operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiGetRequest
 */
export interface SubscriptionsApiGetRequest {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsApiGet
     */
    readonly userId: number
}

/**
 * Request parameters for getActiveFeatures1 operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiGetActiveFeatures1Request
 */
export interface SubscriptionsApiGetActiveFeatures1Request {
    /**
     * 
     * @type {number}
     * @memberof SubscriptionsApiGetActiveFeatures1
     */
    readonly userId: number
}

/**
 * Request parameters for getAll1 operation in SubscriptionsApi.
 * @export
 * @interface SubscriptionsApiGetAll1Request
 */
export interface SubscriptionsApiGetAll1Request {
    /**
     * 
     * @type {Array<string>}
     * @memberof SubscriptionsApiGetAll1
     */
    readonly expand?: Array<string>
}

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * 
     * @param {SubscriptionsApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public get(requestParameters: SubscriptionsApiGetRequest, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).get(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubscriptionsApiGetActiveFeatures1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getActiveFeatures1(requestParameters: SubscriptionsApiGetActiveFeatures1Request, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getActiveFeatures1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the active and available subscription plans
     * @param {SubscriptionsApiGetAll1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getAll1(requestParameters: SubscriptionsApiGetAll1Request = {}, options?: RawAxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getAll1(requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestimonialApi - axios parameter creator
 * @export
 */
export const TestimonialApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Publication state update
         * @param {string} testimonialId Testimonial Id
         * @param {boolean} publicationState Publication State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus: async (testimonialId: string, publicationState: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testimonialId' is not null or undefined
            assertParamExists('changePublicationStatus', 'testimonialId', testimonialId)
            // verify required parameter 'publicationState' is not null or undefined
            assertParamExists('changePublicationStatus', 'publicationState', publicationState)
            const localVarPath = `/testimonial/{testimonialId}/publication-state/{publicationState}`
                .replace(`{${"testimonialId"}}`, encodeURIComponent(String(testimonialId)))
                .replace(`{${"publicationState"}}`, encodeURIComponent(String(publicationState)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch User Posted list of testimonials
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPublishedTestimonials1: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testimonial/published`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Fetch User Received list of testimonials
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchReceivedTestimonials1: async (pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testimonial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {string} testimonialId testimonial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonial1: async (testimonialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testimonialId' is not null or undefined
            assertParamExists('findTestimonial1', 'testimonialId', testimonialId)
            const localVarPath = `/testimonial/{testimonialId}`
                .replace(`{${"testimonialId"}}`, encodeURIComponent(String(testimonialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequests1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testimonial/requested`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequestsReceived1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testimonial/request-received`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {Testimonial} testimonial Testimonial to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTestimonial1: async (testimonial: Testimonial, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testimonial' is not null or undefined
            assertParamExists('saveTestimonial1', 'testimonial', testimonial)
            const localVarPath = `/testimonial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(testimonial, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestimonialApi - functional programming interface
 * @export
 */
export const TestimonialApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestimonialApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Publication state update
         * @param {string} testimonialId Testimonial Id
         * @param {boolean} publicationState Publication State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePublicationStatus(testimonialId: string, publicationState: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Testimonial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePublicationStatus(testimonialId, publicationState, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.changePublicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch User Posted list of testimonials
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchPublishedTestimonials1(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonialFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchPublishedTestimonials1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.fetchPublishedTestimonials1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Fetch User Received list of testimonials
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchReceivedTestimonials1(pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonialFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchReceivedTestimonials1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.fetchReceivedTestimonials1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {string} testimonialId testimonial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonial1(testimonialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Testimonial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonial1(testimonialId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.findTestimonial1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialRequests1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Testimonial>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialRequests1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.findTestimonialRequests1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialRequestsReceived1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Testimonial>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialRequestsReceived1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.findTestimonialRequestsReceived1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {Testimonial} testimonial Testimonial to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTestimonial1(testimonial: Testimonial, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Testimonial>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTestimonial1(testimonial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.saveTestimonial1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestimonialApi - factory interface
 * @export
 */
export const TestimonialApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestimonialApiFp(configuration)
    return {
        /**
         * 
         * @summary Publication state update
         * @param {TestimonialApiChangePublicationStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus(requestParameters: TestimonialApiChangePublicationStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<Testimonial> {
            return localVarFp.changePublicationStatus(requestParameters.testimonialId, requestParameters.publicationState, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch User Posted list of testimonials
         * @param {TestimonialApiFetchPublishedTestimonials1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPublishedTestimonials1(requestParameters: TestimonialApiFetchPublishedTestimonials1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<TestimonialFilterResult> {
            return localVarFp.fetchPublishedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Fetch User Received list of testimonials
         * @param {TestimonialApiFetchReceivedTestimonials1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchReceivedTestimonials1(requestParameters: TestimonialApiFetchReceivedTestimonials1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<TestimonialFilterResult> {
            return localVarFp.fetchReceivedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {TestimonialApiFindTestimonial1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonial1(requestParameters: TestimonialApiFindTestimonial1Request, options?: RawAxiosRequestConfig): AxiosPromise<Testimonial> {
            return localVarFp.findTestimonial1(requestParameters.testimonialId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequests1(options?: RawAxiosRequestConfig): AxiosPromise<Array<Testimonial>> {
            return localVarFp.findTestimonialRequests1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequestsReceived1(options?: RawAxiosRequestConfig): AxiosPromise<Array<Testimonial>> {
            return localVarFp.findTestimonialRequestsReceived1(options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {TestimonialApiSaveTestimonial1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTestimonial1(requestParameters: TestimonialApiSaveTestimonial1Request, options?: RawAxiosRequestConfig): AxiosPromise<Testimonial> {
            return localVarFp.saveTestimonial1(requestParameters.testimonial, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for changePublicationStatus operation in TestimonialApi.
 * @export
 * @interface TestimonialApiChangePublicationStatusRequest
 */
export interface TestimonialApiChangePublicationStatusRequest {
    /**
     * Testimonial Id
     * @type {string}
     * @memberof TestimonialApiChangePublicationStatus
     */
    readonly testimonialId: string

    /**
     * Publication State
     * @type {boolean}
     * @memberof TestimonialApiChangePublicationStatus
     */
    readonly publicationState: boolean
}

/**
 * Request parameters for fetchPublishedTestimonials1 operation in TestimonialApi.
 * @export
 * @interface TestimonialApiFetchPublishedTestimonials1Request
 */
export interface TestimonialApiFetchPublishedTestimonials1Request {
    /**
     * 
     * @type {number}
     * @memberof TestimonialApiFetchPublishedTestimonials1
     */
    readonly pageFrom?: number

    /**
     * 
     * @type {number}
     * @memberof TestimonialApiFetchPublishedTestimonials1
     */
    readonly pageTo?: number
}

/**
 * Request parameters for fetchReceivedTestimonials1 operation in TestimonialApi.
 * @export
 * @interface TestimonialApiFetchReceivedTestimonials1Request
 */
export interface TestimonialApiFetchReceivedTestimonials1Request {
    /**
     * 
     * @type {number}
     * @memberof TestimonialApiFetchReceivedTestimonials1
     */
    readonly pageFrom?: number

    /**
     * 
     * @type {number}
     * @memberof TestimonialApiFetchReceivedTestimonials1
     */
    readonly pageTo?: number
}

/**
 * Request parameters for findTestimonial1 operation in TestimonialApi.
 * @export
 * @interface TestimonialApiFindTestimonial1Request
 */
export interface TestimonialApiFindTestimonial1Request {
    /**
     * testimonial id
     * @type {string}
     * @memberof TestimonialApiFindTestimonial1
     */
    readonly testimonialId: string
}

/**
 * Request parameters for saveTestimonial1 operation in TestimonialApi.
 * @export
 * @interface TestimonialApiSaveTestimonial1Request
 */
export interface TestimonialApiSaveTestimonial1Request {
    /**
     * Testimonial to persist
     * @type {Testimonial}
     * @memberof TestimonialApiSaveTestimonial1
     */
    readonly testimonial: Testimonial
}

/**
 * TestimonialApi - object-oriented interface
 * @export
 * @class TestimonialApi
 * @extends {BaseAPI}
 */
export class TestimonialApi extends BaseAPI {
    /**
     * 
     * @summary Publication state update
     * @param {TestimonialApiChangePublicationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public changePublicationStatus(requestParameters: TestimonialApiChangePublicationStatusRequest, options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).changePublicationStatus(requestParameters.testimonialId, requestParameters.publicationState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch User Posted list of testimonials
     * @param {TestimonialApiFetchPublishedTestimonials1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public fetchPublishedTestimonials1(requestParameters: TestimonialApiFetchPublishedTestimonials1Request = {}, options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).fetchPublishedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Fetch User Received list of testimonials
     * @param {TestimonialApiFetchReceivedTestimonials1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public fetchReceivedTestimonials1(requestParameters: TestimonialApiFetchReceivedTestimonials1Request = {}, options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).fetchReceivedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the testimonial with specified id, it needs to be published
     * @param {TestimonialApiFindTestimonial1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public findTestimonial1(requestParameters: TestimonialApiFindTestimonial1Request, options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).findTestimonial1(requestParameters.testimonialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the testimonial Requests a user Created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public findTestimonialRequests1(options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).findTestimonialRequests1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the testimonial Requests a user Received
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public findTestimonialRequestsReceived1(options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).findTestimonialRequestsReceived1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Consider that only user can save new testimonials
     * @summary Create or update the Testimonial supplied
     * @param {TestimonialApiSaveTestimonial1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    public saveTestimonial1(requestParameters: TestimonialApiSaveTestimonial1Request, options?: RawAxiosRequestConfig) {
        return TestimonialApiFp(this.configuration).saveTestimonial1(requestParameters.testimonial, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TextTranslationsApi - axios parameter creator
 * @export
 */
export const TextTranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {string} [targetLang] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateText1: async (targetLang?: string, text?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/text-translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (targetLang !== undefined) {
                localVarQueryParameter['targetLang'] = targetLang;
            }

            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTranslationsApi - functional programming interface
 * @export
 */
export const TextTranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextTranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {string} [targetLang] 
         * @param {string} [text] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translateText1(targetLang?: string, text?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextTranslation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translateText1(targetLang, text, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextTranslationsApi.translateText1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TextTranslationsApi - factory interface
 * @export
 */
export const TextTranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextTranslationsApiFp(configuration)
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {TextTranslationsApiTranslateText1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateText1(requestParameters: TextTranslationsApiTranslateText1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<TextTranslation> {
            return localVarFp.translateText1(requestParameters.targetLang, requestParameters.text, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for translateText1 operation in TextTranslationsApi.
 * @export
 * @interface TextTranslationsApiTranslateText1Request
 */
export interface TextTranslationsApiTranslateText1Request {
    /**
     * 
     * @type {string}
     * @memberof TextTranslationsApiTranslateText1
     */
    readonly targetLang?: string

    /**
     * 
     * @type {string}
     * @memberof TextTranslationsApiTranslateText1
     */
    readonly text?: string
}

/**
 * TextTranslationsApi - object-oriented interface
 * @export
 * @class TextTranslationsApi
 * @extends {BaseAPI}
 */
export class TextTranslationsApi extends BaseAPI {
    /**
     * Translate the provided text to the specified target language
     * @summary Get text translation to a target language
     * @param {TextTranslationsApiTranslateText1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTranslationsApi
     */
    public translateText1(requestParameters: TextTranslationsApiTranslateText1Request = {}, options?: RawAxiosRequestConfig) {
        return TextTranslationsApiFp(this.configuration).translateText1(requestParameters.targetLang, requestParameters.text, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserTypesApi - axios parameter creator
 * @export
 */
export const UserTypesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTypes1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserTypesApi - functional programming interface
 * @export
 */
export const UserTypesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserTypesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTypes1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTypes1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTypesApi.getUserTypes1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserTypesApi - factory interface
 * @export
 */
export const UserTypesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserTypesApiFp(configuration)
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTypes1(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserType>> {
            return localVarFp.getUserTypes1(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserTypesApi - object-oriented interface
 * @export
 * @class UserTypesApi
 * @extends {BaseAPI}
 */
export class UserTypesApi extends BaseAPI {
    /**
     * Returns all available user types in the system
     * @summary Get user types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTypesApi
     */
    public getUserTypes1(options?: RawAxiosRequestConfig) {
        return UserTypesApiFp(this.configuration).getUserTypes1(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/activate-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {number} userId ID of the user to add skills to
         * @param {Array<UserSkill>} userSkill List of skills to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserSkills1: async (userId: number, userSkill: Array<UserSkill>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserSkills1', 'userId', userId)
            // verify required parameter 'userSkill' is not null or undefined
            assertParamExists('addUserSkills1', 'userSkill', userSkill)
            const localVarPath = `/users/{userId}/skills`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userSkill, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Checks the status of a Stripe Identity verification session and marks user as verified if successful
         * @summary Check identity verification status
         * @param {number} userId 
         * @param {IdentityVerificationCheckRequest} identityVerificationCheckRequest Identity verification check details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIdentityVerification1: async (userId: number, identityVerificationCheckRequest: IdentityVerificationCheckRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('checkIdentityVerification1', 'userId', userId)
            // verify required parameter 'identityVerificationCheckRequest' is not null or undefined
            assertParamExists('checkIdentityVerification1', 'identityVerificationCheckRequest', identityVerificationCheckRequest)
            const localVarPath = `/users/{userId}/identity-verification-check`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(identityVerificationCheckRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {number} userId 
         * @param {PhoneCodeCheckResource} phoneCodeCheckResource Phone code verification details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPhoneVerificationCodeCommand1: async (userId: number, phoneCodeCheckResource: PhoneCodeCheckResource, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('checkPhoneVerificationCodeCommand1', 'userId', userId)
            // verify required parameter 'phoneCodeCheckResource' is not null or undefined
            assertParamExists('checkPhoneVerificationCodeCommand1', 'phoneCodeCheckResource', phoneCodeCheckResource)
            const localVarPath = `/users/{userId}/phone-code-check`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(phoneCodeCheckResource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {number} userId ID of the user whose skill is being endorsed
         * @param {number} skillId ID of the skill being endorsed
         * @param {SkillEndorsement} skillEndorsement Endorsement details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endorseUserSkill1: async (userId: number, skillId: number, skillEndorsement: SkillEndorsement, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('endorseUserSkill1', 'userId', userId)
            // verify required parameter 'skillId' is not null or undefined
            assertParamExists('endorseUserSkill1', 'skillId', skillId)
            // verify required parameter 'skillEndorsement' is not null or undefined
            assertParamExists('endorseUserSkill1', 'skillEndorsement', skillEndorsement)
            const localVarPath = `/users/{userId}/skills/{skillId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"skillId"}}`, encodeURIComponent(String(skillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(skillEndorsement, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {UserListRequest} userListRequest User list request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomUsers1: async (userListRequest: UserListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userListRequest' is not null or undefined
            assertParamExists('fetchRandomUsers1', 'userListRequest', userListRequest)
            const localVarPath = `/users/fetch-random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {string} [propertyPublicationState] 
         * @param {string} [xmlId] 
         * @param {string} [aPIVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertiesByUser1: async (id: string, pageFrom?: number, pageTo?: number, propertyPublicationState?: string, xmlId?: string, aPIVersion?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findPropertiesByUser1', 'id', id)
            const localVarPath = `/users/{id}/properties`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }

            if (propertyPublicationState !== undefined) {
                localVarQueryParameter['propertyPublicationState'] = propertyPublicationState;
            }

            if (xmlId !== undefined) {
                localVarQueryParameter['xmlId'] = xmlId;
            }


    
            if (aPIVersion != null) {
                localVarHeaderParameter['API-Version'] = String(aPIVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Return the testimonials list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialsByUser1: async (id: string, pageFrom?: number, pageTo?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findTestimonialsByUser1', 'id', id)
            const localVarPath = `/users/{id}/testimonials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }

            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserById1: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findUserById1', 'userId', userId)
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {string} [profileName] User\&#39;s profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByProfileName1: async (profileName?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (profileName !== undefined) {
                localVarQueryParameter['profileName'] = profileName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections1: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findUserConnections1', 'userId', userId)
            const localVarPath = `/users/{userId}/connections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {string} userIds Comma-separated list of user IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByIds1: async (userIds: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIds' is not null or undefined
            assertParamExists('findUsersByIds1', 'userIds', userIds)
            const localVarPath = `/users/list/{userIds}`
                .replace(`{${"userIds"}}`, encodeURIComponent(String(userIds)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {GetSubscribedUsers1SubscriptionPlanNameEnum} subscriptionPlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedUsers1: async (subscriptionPlanName: GetSubscribedUsers1SubscriptionPlanNameEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionPlanName' is not null or undefined
            assertParamExists('getSubscribedUsers1', 'subscriptionPlanName', subscriptionPlanName)
            const localVarPath = `/users/subscribed-users/{subscriptionPlanName}`
                .replace(`{${"subscriptionPlanName"}}`, encodeURIComponent(String(subscriptionPlanName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {number} [id] 
         * @param {string} [lang] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty: async (id?: number, lang?: string, acceptLanguage?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/previews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {SkilledUser} skilledUser User registration data
         * @param {string} [origin] 
         * @param {boolean} [skipEmailValidation] Skip email validation step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register1: async (skilledUser: SkilledUser, origin?: string, skipEmailValidation?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skilledUser' is not null or undefined
            assertParamExists('register1', 'skilledUser', skilledUser)
            const localVarPath = `/users/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)

            if (skipEmailValidation !== undefined) {
                localVarQueryParameter['skipEmailValidation'] = skipEmailValidation;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(skilledUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {string} [origin] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestActivationLink1: async (origin?: string, email?: string, password?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/activation_link_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


            if (email !== undefined) { 
                localVarFormParams.set('email', email as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request testimonial from specified user id
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTestimonialFromUser1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestTestimonialFromUser1', 'id', id)
            const localVarPath = `/users/{id}/request-testimonial`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {number} userId ID of the user whose skill endorsements to retrieve
         * @param {number} skillId ID of the skill to retrieve endorsements for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSkillEndorsements1: async (userId: number, skillId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveSkillEndorsements1', 'userId', userId)
            // verify required parameter 'skillId' is not null or undefined
            assertParamExists('retrieveSkillEndorsements1', 'skillId', skillId)
            const localVarPath = `/users/{userId}/skills/{skillId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"skillId"}}`, encodeURIComponent(String(skillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {number} userId ID of the user to retrieve skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveUserSkills', 'userId', userId)
            const localVarPath = `/users/{userId}/skills`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {SkilledUser} skilledUser User data to save
         * @param {string} [oAuthToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save1: async (skilledUser: SkilledUser, oAuthToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'skilledUser' is not null or undefined
            assertParamExists('save1', 'skilledUser', skilledUser)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (oAuthToken != null) {
                localVarHeaderParameter['O-Auth-Token'] = String(oAuthToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(skilledUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LogEntry} [logEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLog1: async (logEntry?: LogEntry, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for users matching the specified filter criteria. When authenticated (O-Auth-Token header provided), includes connection degrees (1st, 2nd, 3rd+) to other users.
         * @summary Search users with specified filters
         * @param {UserFilterRequest} userFilterRequest User search filters
         * @param {string} [oAuthToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers1: async (userFilterRequest: UserFilterRequest, oAuthToken?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userFilterRequest' is not null or undefined
            assertParamExists('searchUsers1', 'userFilterRequest', userFilterRequest)
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (oAuthToken != null) {
                localVarHeaderParameter['O-Auth-Token'] = String(oAuthToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an email verification link to the authenticated user\'s email address
         * @summary Send email verification to logged-in user
         * @param {string} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailVerification1: async (origin?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/send-email-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayedSusbscribersAlert1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/weekly-payed-subscribers-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {number} userId 
         * @param {PhoneCodeRequestResource} phoneCodeRequestResource Phone code request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPhoneVerificationCodeCommand1: async (userId: number, phoneCodeRequestResource: PhoneCodeRequestResource, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sendPhoneVerificationCodeCommand1', 'userId', userId)
            // verify required parameter 'phoneCodeRequestResource' is not null or undefined
            assertParamExists('sendPhoneVerificationCodeCommand1', 'phoneCodeRequestResource', phoneCodeRequestResource)
            const localVarPath = `/users/{userId}/phone-code-request`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(phoneCodeRequestResource, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates Stripe Identity verification and returns a verification URL and session ID
         * @summary Start identity verification for user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startIdentityVerification1: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('startIdentityVerification1', 'userId', userId)
            const localVarPath = `/users/{userId}/identity-verification-start`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration)

            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUser1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUser1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.activateUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {number} userId ID of the user to add skills to
         * @param {Array<UserSkill>} userSkill List of skills to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserSkills1(userId: number, userSkill: Array<UserSkill>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserSkills1(userId, userSkill, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.addUserSkills1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Checks the status of a Stripe Identity verification session and marks user as verified if successful
         * @summary Check identity verification status
         * @param {number} userId 
         * @param {IdentityVerificationCheckRequest} identityVerificationCheckRequest Identity verification check details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkIdentityVerification1(userId: number, identityVerificationCheckRequest: IdentityVerificationCheckRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkIdentityVerification1(userId, identityVerificationCheckRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.checkIdentityVerification1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {number} userId 
         * @param {PhoneCodeCheckResource} phoneCodeCheckResource Phone code verification details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPhoneVerificationCodeCommand1(userId: number, phoneCodeCheckResource: PhoneCodeCheckResource, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhoneCodeCheckResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPhoneVerificationCodeCommand1(userId, phoneCodeCheckResource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.checkPhoneVerificationCodeCommand1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {number} userId ID of the user whose skill is being endorsed
         * @param {number} skillId ID of the skill being endorsed
         * @param {SkillEndorsement} skillEndorsement Endorsement details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endorseUserSkill1(userId: number, skillId: number, skillEndorsement: SkillEndorsement, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkillEndorsement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endorseUserSkill1(userId, skillId, skillEndorsement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.endorseUserSkill1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {UserListRequest} userListRequest User list request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomUsers1(userListRequest: UserListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkilledUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomUsers1(userListRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.fetchRandomUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {string} [propertyPublicationState] 
         * @param {string} [xmlId] 
         * @param {string} [aPIVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPropertiesByUser1(id: string, pageFrom?: number, pageTo?: number, propertyPublicationState?: string, xmlId?: string, aPIVersion?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertiesByUser1(id, pageFrom, pageTo, propertyPublicationState, xmlId, aPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findPropertiesByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Return the testimonials list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom] 
         * @param {number} [pageTo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialsByUser1(id: string, pageFrom?: number, pageTo?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonialFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialsByUser1(id, pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findTestimonialsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserById1(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkilledUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserById1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findUserById1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {string} [profileName] User\&#39;s profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserByProfileName1(profileName?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SkilledUser>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserByProfileName1(profileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findUserByProfileName1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserConnections1(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkilledUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserConnections1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findUserConnections1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {string} userIds Comma-separated list of user IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUsersByIds1(userIds: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkilledUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsersByIds1(userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findUsersByIds1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {GetSubscribedUsers1SubscriptionPlanNameEnum} subscriptionPlanName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscribedUsers1(subscriptionPlanName: GetSubscribedUsers1SubscriptionPlanNameEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscribedUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscribedUsers1(subscriptionPlanName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getSubscribedUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {number} [id] 
         * @param {string} [lang] 
         * @param {string} [acceptLanguage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewProperty(id?: number, lang?: string, acceptLanguage?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewProperty(id, lang, acceptLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.previewProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {SkilledUser} skilledUser User registration data
         * @param {string} [origin] 
         * @param {boolean} [skipEmailValidation] Skip email validation step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register1(skilledUser: SkilledUser, origin?: string, skipEmailValidation?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register1(skilledUser, origin, skipEmailValidation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.register1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {string} [origin] 
         * @param {string} [email] 
         * @param {string} [password] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestActivationLink1(origin?: string, email?: string, password?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestActivationLink1(origin, email, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.requestActivationLink1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Request testimonial from specified user id
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTestimonialFromUser1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestimonialRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTestimonialFromUser1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.requestTestimonialFromUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {number} userId ID of the user whose skill endorsements to retrieve
         * @param {number} skillId ID of the skill to retrieve endorsements for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSkillEndorsements1(userId: number, skillId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SkillEndorsement>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSkillEndorsements1(userId, skillId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.retrieveSkillEndorsements1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {number} userId ID of the user to retrieve skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSkills(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSkill>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSkills(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.retrieveUserSkills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {SkilledUser} skilledUser User data to save
         * @param {string} [oAuthToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save1(skilledUser: SkilledUser, oAuthToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save1(skilledUser, oAuthToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.save1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {LogEntry} [logEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveLog1(logEntry?: LogEntry, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveLog1(logEntry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.saveLog1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Searches for users matching the specified filter criteria. When authenticated (O-Auth-Token header provided), includes connection degrees (1st, 2nd, 3rd+) to other users.
         * @summary Search users with specified filters
         * @param {UserFilterRequest} userFilterRequest User search filters
         * @param {string} [oAuthToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers1(userFilterRequest: UserFilterRequest, oAuthToken?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFilterResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers1(userFilterRequest, oAuthToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.searchUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an email verification link to the authenticated user\'s email address
         * @summary Send email verification to logged-in user
         * @param {string} [origin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmailVerification1(origin?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmailVerification1(origin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.sendEmailVerification1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPayedSusbscribersAlert1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPayedSusbscribersAlert1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.sendPayedSusbscribersAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {number} userId 
         * @param {PhoneCodeRequestResource} phoneCodeRequestResource Phone code request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPhoneVerificationCodeCommand1(userId: number, phoneCodeRequestResource: PhoneCodeRequestResource, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PhoneCodeRequestResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPhoneVerificationCodeCommand1(userId, phoneCodeRequestResource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.sendPhoneVerificationCodeCommand1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiates Stripe Identity verification and returns a verification URL and session ID
         * @summary Start identity verification for user
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startIdentityVerification1(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IdentityVerificationStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startIdentityVerification1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.startIdentityVerification1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser1(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.activateUser1(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {UsersApiAddUserSkills1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserSkills1(requestParameters: UsersApiAddUserSkills1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.addUserSkills1(requestParameters.userId, requestParameters.userSkill, options).then((request) => request(axios, basePath));
        },
        /**
         * Checks the status of a Stripe Identity verification session and marks user as verified if successful
         * @summary Check identity verification status
         * @param {UsersApiCheckIdentityVerification1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkIdentityVerification1(requestParameters: UsersApiCheckIdentityVerification1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.checkIdentityVerification1(requestParameters.userId, requestParameters.identityVerificationCheckRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {UsersApiCheckPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPhoneVerificationCodeCommand1(requestParameters: UsersApiCheckPhoneVerificationCodeCommand1Request, options?: RawAxiosRequestConfig): AxiosPromise<PhoneCodeCheckResource> {
            return localVarFp.checkPhoneVerificationCodeCommand1(requestParameters.userId, requestParameters.phoneCodeCheckResource, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {UsersApiEndorseUserSkill1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endorseUserSkill1(requestParameters: UsersApiEndorseUserSkill1Request, options?: RawAxiosRequestConfig): AxiosPromise<SkillEndorsement> {
            return localVarFp.endorseUserSkill1(requestParameters.userId, requestParameters.skillId, requestParameters.skillEndorsement, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {UsersApiFetchRandomUsers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomUsers1(requestParameters: UsersApiFetchRandomUsers1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SkilledUser>> {
            return localVarFp.fetchRandomUsers1(requestParameters.userListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the property list with specified user id
         * @param {UsersApiFindPropertiesByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertiesByUser1(requestParameters: UsersApiFindPropertiesByUser1Request, options?: RawAxiosRequestConfig): AxiosPromise<PropertyFilterResult> {
            return localVarFp.findPropertiesByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, requestParameters.propertyPublicationState, requestParameters.xmlId, requestParameters.aPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Return the testimonials list with specified user id
         * @param {UsersApiFindTestimonialsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialsByUser1(requestParameters: UsersApiFindTestimonialsByUser1Request, options?: RawAxiosRequestConfig): AxiosPromise<TestimonialFilterResult> {
            return localVarFp.findTestimonialsByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {UsersApiFindUserById1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserById1(requestParameters: UsersApiFindUserById1Request, options?: RawAxiosRequestConfig): AxiosPromise<SkilledUser> {
            return localVarFp.findUserById1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {UsersApiFindUserByProfileName1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByProfileName1(requestParameters: UsersApiFindUserByProfileName1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<SkilledUser> {
            return localVarFp.findUserByProfileName1(requestParameters.profileName, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {UsersApiFindUserConnections1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections1(requestParameters: UsersApiFindUserConnections1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SkilledUser>> {
            return localVarFp.findUserConnections1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {UsersApiFindUsersByIds1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByIds1(requestParameters: UsersApiFindUsersByIds1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SkilledUser>> {
            return localVarFp.findUsersByIds1(requestParameters.userIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {UsersApiGetSubscribedUsers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedUsers1(requestParameters: UsersApiGetSubscribedUsers1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SubscribedUser>> {
            return localVarFp.getSubscribedUsers1(requestParameters.subscriptionPlanName, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {UsersApiPreviewPropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty(requestParameters: UsersApiPreviewPropertyRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.previewProperty(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {UsersApiRegister1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register1(requestParameters: UsersApiRegister1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.register1(requestParameters.skilledUser, requestParameters.origin, requestParameters.skipEmailValidation, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {UsersApiRequestActivationLink1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestActivationLink1(requestParameters: UsersApiRequestActivationLink1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.requestActivationLink1(requestParameters.origin, requestParameters.email, requestParameters.password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request testimonial from specified user id
         * @param {UsersApiRequestTestimonialFromUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTestimonialFromUser1(requestParameters: UsersApiRequestTestimonialFromUser1Request, options?: RawAxiosRequestConfig): AxiosPromise<TestimonialRequest> {
            return localVarFp.requestTestimonialFromUser1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {UsersApiRetrieveSkillEndorsements1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSkillEndorsements1(requestParameters: UsersApiRetrieveSkillEndorsements1Request, options?: RawAxiosRequestConfig): AxiosPromise<Array<SkillEndorsement>> {
            return localVarFp.retrieveSkillEndorsements1(requestParameters.userId, requestParameters.skillId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {UsersApiRetrieveUserSkillsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills(requestParameters: UsersApiRetrieveUserSkillsRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserSkill>> {
            return localVarFp.retrieveUserSkills(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {UsersApiSave1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save1(requestParameters: UsersApiSave1Request, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.save1(requestParameters.skilledUser, requestParameters.oAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UsersApiSaveLog1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLog1(requestParameters: UsersApiSaveLog1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.saveLog1(requestParameters.logEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for users matching the specified filter criteria. When authenticated (O-Auth-Token header provided), includes connection degrees (1st, 2nd, 3rd+) to other users.
         * @summary Search users with specified filters
         * @param {UsersApiSearchUsers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers1(requestParameters: UsersApiSearchUsers1Request, options?: RawAxiosRequestConfig): AxiosPromise<UserFilterResult> {
            return localVarFp.searchUsers1(requestParameters.userFilterRequest, requestParameters.oAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an email verification link to the authenticated user\'s email address
         * @summary Send email verification to logged-in user
         * @param {UsersApiSendEmailVerification1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailVerification1(requestParameters: UsersApiSendEmailVerification1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendEmailVerification1(requestParameters.origin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayedSusbscribersAlert1(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendPayedSusbscribersAlert1(options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {UsersApiSendPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPhoneVerificationCodeCommand1(requestParameters: UsersApiSendPhoneVerificationCodeCommand1Request, options?: RawAxiosRequestConfig): AxiosPromise<PhoneCodeRequestResource> {
            return localVarFp.sendPhoneVerificationCodeCommand1(requestParameters.userId, requestParameters.phoneCodeRequestResource, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates Stripe Identity verification and returns a verification URL and session ID
         * @summary Start identity verification for user
         * @param {UsersApiStartIdentityVerification1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startIdentityVerification1(requestParameters: UsersApiStartIdentityVerification1Request, options?: RawAxiosRequestConfig): AxiosPromise<IdentityVerificationStartResponse> {
            return localVarFp.startIdentityVerification1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addUserSkills1 operation in UsersApi.
 * @export
 * @interface UsersApiAddUserSkills1Request
 */
export interface UsersApiAddUserSkills1Request {
    /**
     * ID of the user to add skills to
     * @type {number}
     * @memberof UsersApiAddUserSkills1
     */
    readonly userId: number

    /**
     * List of skills to add
     * @type {Array<UserSkill>}
     * @memberof UsersApiAddUserSkills1
     */
    readonly userSkill: Array<UserSkill>
}

/**
 * Request parameters for checkIdentityVerification1 operation in UsersApi.
 * @export
 * @interface UsersApiCheckIdentityVerification1Request
 */
export interface UsersApiCheckIdentityVerification1Request {
    /**
     * 
     * @type {number}
     * @memberof UsersApiCheckIdentityVerification1
     */
    readonly userId: number

    /**
     * Identity verification check details
     * @type {IdentityVerificationCheckRequest}
     * @memberof UsersApiCheckIdentityVerification1
     */
    readonly identityVerificationCheckRequest: IdentityVerificationCheckRequest
}

/**
 * Request parameters for checkPhoneVerificationCodeCommand1 operation in UsersApi.
 * @export
 * @interface UsersApiCheckPhoneVerificationCodeCommand1Request
 */
export interface UsersApiCheckPhoneVerificationCodeCommand1Request {
    /**
     * 
     * @type {number}
     * @memberof UsersApiCheckPhoneVerificationCodeCommand1
     */
    readonly userId: number

    /**
     * Phone code verification details
     * @type {PhoneCodeCheckResource}
     * @memberof UsersApiCheckPhoneVerificationCodeCommand1
     */
    readonly phoneCodeCheckResource: PhoneCodeCheckResource
}

/**
 * Request parameters for endorseUserSkill1 operation in UsersApi.
 * @export
 * @interface UsersApiEndorseUserSkill1Request
 */
export interface UsersApiEndorseUserSkill1Request {
    /**
     * ID of the user whose skill is being endorsed
     * @type {number}
     * @memberof UsersApiEndorseUserSkill1
     */
    readonly userId: number

    /**
     * ID of the skill being endorsed
     * @type {number}
     * @memberof UsersApiEndorseUserSkill1
     */
    readonly skillId: number

    /**
     * Endorsement details
     * @type {SkillEndorsement}
     * @memberof UsersApiEndorseUserSkill1
     */
    readonly skillEndorsement: SkillEndorsement
}

/**
 * Request parameters for fetchRandomUsers1 operation in UsersApi.
 * @export
 * @interface UsersApiFetchRandomUsers1Request
 */
export interface UsersApiFetchRandomUsers1Request {
    /**
     * User list request parameters
     * @type {UserListRequest}
     * @memberof UsersApiFetchRandomUsers1
     */
    readonly userListRequest: UserListRequest
}

/**
 * Request parameters for findPropertiesByUser1 operation in UsersApi.
 * @export
 * @interface UsersApiFindPropertiesByUser1Request
 */
export interface UsersApiFindPropertiesByUser1Request {
    /**
     * user id
     * @type {string}
     * @memberof UsersApiFindPropertiesByUser1
     */
    readonly id: string

    /**
     * 
     * @type {number}
     * @memberof UsersApiFindPropertiesByUser1
     */
    readonly pageFrom?: number

    /**
     * 
     * @type {number}
     * @memberof UsersApiFindPropertiesByUser1
     */
    readonly pageTo?: number

    /**
     * 
     * @type {string}
     * @memberof UsersApiFindPropertiesByUser1
     */
    readonly propertyPublicationState?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiFindPropertiesByUser1
     */
    readonly xmlId?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiFindPropertiesByUser1
     */
    readonly aPIVersion?: string
}

/**
 * Request parameters for findTestimonialsByUser1 operation in UsersApi.
 * @export
 * @interface UsersApiFindTestimonialsByUser1Request
 */
export interface UsersApiFindTestimonialsByUser1Request {
    /**
     * user id
     * @type {string}
     * @memberof UsersApiFindTestimonialsByUser1
     */
    readonly id: string

    /**
     * 
     * @type {number}
     * @memberof UsersApiFindTestimonialsByUser1
     */
    readonly pageFrom?: number

    /**
     * 
     * @type {number}
     * @memberof UsersApiFindTestimonialsByUser1
     */
    readonly pageTo?: number
}

/**
 * Request parameters for findUserById1 operation in UsersApi.
 * @export
 * @interface UsersApiFindUserById1Request
 */
export interface UsersApiFindUserById1Request {
    /**
     * user id
     * @type {number}
     * @memberof UsersApiFindUserById1
     */
    readonly userId: number
}

/**
 * Request parameters for findUserByProfileName1 operation in UsersApi.
 * @export
 * @interface UsersApiFindUserByProfileName1Request
 */
export interface UsersApiFindUserByProfileName1Request {
    /**
     * User\&#39;s profile name
     * @type {string}
     * @memberof UsersApiFindUserByProfileName1
     */
    readonly profileName?: string
}

/**
 * Request parameters for findUserConnections1 operation in UsersApi.
 * @export
 * @interface UsersApiFindUserConnections1Request
 */
export interface UsersApiFindUserConnections1Request {
    /**
     * 
     * @type {number}
     * @memberof UsersApiFindUserConnections1
     */
    readonly userId: number
}

/**
 * Request parameters for findUsersByIds1 operation in UsersApi.
 * @export
 * @interface UsersApiFindUsersByIds1Request
 */
export interface UsersApiFindUsersByIds1Request {
    /**
     * Comma-separated list of user IDs
     * @type {string}
     * @memberof UsersApiFindUsersByIds1
     */
    readonly userIds: string
}

/**
 * Request parameters for getSubscribedUsers1 operation in UsersApi.
 * @export
 * @interface UsersApiGetSubscribedUsers1Request
 */
export interface UsersApiGetSubscribedUsers1Request {
    /**
     * 
     * @type {'Free' | 'Professional' | 'Business' | 'Brokerage'}
     * @memberof UsersApiGetSubscribedUsers1
     */
    readonly subscriptionPlanName: GetSubscribedUsers1SubscriptionPlanNameEnum
}

/**
 * Request parameters for previewProperty operation in UsersApi.
 * @export
 * @interface UsersApiPreviewPropertyRequest
 */
export interface UsersApiPreviewPropertyRequest {
    /**
     * 
     * @type {number}
     * @memberof UsersApiPreviewProperty
     */
    readonly id?: number

    /**
     * 
     * @type {string}
     * @memberof UsersApiPreviewProperty
     */
    readonly lang?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiPreviewProperty
     */
    readonly acceptLanguage?: string
}

/**
 * Request parameters for register1 operation in UsersApi.
 * @export
 * @interface UsersApiRegister1Request
 */
export interface UsersApiRegister1Request {
    /**
     * User registration data
     * @type {SkilledUser}
     * @memberof UsersApiRegister1
     */
    readonly skilledUser: SkilledUser

    /**
     * 
     * @type {string}
     * @memberof UsersApiRegister1
     */
    readonly origin?: string

    /**
     * Skip email validation step
     * @type {boolean}
     * @memberof UsersApiRegister1
     */
    readonly skipEmailValidation?: boolean
}

/**
 * Request parameters for requestActivationLink1 operation in UsersApi.
 * @export
 * @interface UsersApiRequestActivationLink1Request
 */
export interface UsersApiRequestActivationLink1Request {
    /**
     * 
     * @type {string}
     * @memberof UsersApiRequestActivationLink1
     */
    readonly origin?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiRequestActivationLink1
     */
    readonly email?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiRequestActivationLink1
     */
    readonly password?: string
}

/**
 * Request parameters for requestTestimonialFromUser1 operation in UsersApi.
 * @export
 * @interface UsersApiRequestTestimonialFromUser1Request
 */
export interface UsersApiRequestTestimonialFromUser1Request {
    /**
     * user id
     * @type {string}
     * @memberof UsersApiRequestTestimonialFromUser1
     */
    readonly id: string
}

/**
 * Request parameters for retrieveSkillEndorsements1 operation in UsersApi.
 * @export
 * @interface UsersApiRetrieveSkillEndorsements1Request
 */
export interface UsersApiRetrieveSkillEndorsements1Request {
    /**
     * ID of the user whose skill endorsements to retrieve
     * @type {number}
     * @memberof UsersApiRetrieveSkillEndorsements1
     */
    readonly userId: number

    /**
     * ID of the skill to retrieve endorsements for
     * @type {number}
     * @memberof UsersApiRetrieveSkillEndorsements1
     */
    readonly skillId: number
}

/**
 * Request parameters for retrieveUserSkills operation in UsersApi.
 * @export
 * @interface UsersApiRetrieveUserSkillsRequest
 */
export interface UsersApiRetrieveUserSkillsRequest {
    /**
     * ID of the user to retrieve skills for
     * @type {number}
     * @memberof UsersApiRetrieveUserSkills
     */
    readonly userId: number
}

/**
 * Request parameters for save1 operation in UsersApi.
 * @export
 * @interface UsersApiSave1Request
 */
export interface UsersApiSave1Request {
    /**
     * User data to save
     * @type {SkilledUser}
     * @memberof UsersApiSave1
     */
    readonly skilledUser: SkilledUser

    /**
     * 
     * @type {string}
     * @memberof UsersApiSave1
     */
    readonly oAuthToken?: string
}

/**
 * Request parameters for saveLog1 operation in UsersApi.
 * @export
 * @interface UsersApiSaveLog1Request
 */
export interface UsersApiSaveLog1Request {
    /**
     * 
     * @type {LogEntry}
     * @memberof UsersApiSaveLog1
     */
    readonly logEntry?: LogEntry
}

/**
 * Request parameters for searchUsers1 operation in UsersApi.
 * @export
 * @interface UsersApiSearchUsers1Request
 */
export interface UsersApiSearchUsers1Request {
    /**
     * User search filters
     * @type {UserFilterRequest}
     * @memberof UsersApiSearchUsers1
     */
    readonly userFilterRequest: UserFilterRequest

    /**
     * 
     * @type {string}
     * @memberof UsersApiSearchUsers1
     */
    readonly oAuthToken?: string
}

/**
 * Request parameters for sendEmailVerification1 operation in UsersApi.
 * @export
 * @interface UsersApiSendEmailVerification1Request
 */
export interface UsersApiSendEmailVerification1Request {
    /**
     * 
     * @type {string}
     * @memberof UsersApiSendEmailVerification1
     */
    readonly origin?: string
}

/**
 * Request parameters for sendPhoneVerificationCodeCommand1 operation in UsersApi.
 * @export
 * @interface UsersApiSendPhoneVerificationCodeCommand1Request
 */
export interface UsersApiSendPhoneVerificationCodeCommand1Request {
    /**
     * 
     * @type {number}
     * @memberof UsersApiSendPhoneVerificationCodeCommand1
     */
    readonly userId: number

    /**
     * Phone code request details
     * @type {PhoneCodeRequestResource}
     * @memberof UsersApiSendPhoneVerificationCodeCommand1
     */
    readonly phoneCodeRequestResource: PhoneCodeRequestResource
}

/**
 * Request parameters for startIdentityVerification1 operation in UsersApi.
 * @export
 * @interface UsersApiStartIdentityVerification1Request
 */
export interface UsersApiStartIdentityVerification1Request {
    /**
     * 
     * @type {number}
     * @memberof UsersApiStartIdentityVerification1
     */
    readonly userId: number
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Activates a user account using the activation key sent to their email
     * @summary Activate the account of specified user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public activateUser1(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).activateUser1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint is not supported. Use save user profile to update skills instead.
     * @summary Add user skills
     * @param {UsersApiAddUserSkills1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public addUserSkills1(requestParameters: UsersApiAddUserSkills1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).addUserSkills1(requestParameters.userId, requestParameters.userSkill, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Checks the status of a Stripe Identity verification session and marks user as verified if successful
     * @summary Check identity verification status
     * @param {UsersApiCheckIdentityVerification1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkIdentityVerification1(requestParameters: UsersApiCheckIdentityVerification1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkIdentityVerification1(requestParameters.userId, requestParameters.identityVerificationCheckRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verifies the code that was sent to the user\'s phone
     * @summary Verify the phone code sent to user
     * @param {UsersApiCheckPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public checkPhoneVerificationCodeCommand1(requestParameters: UsersApiCheckPhoneVerificationCodeCommand1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).checkPhoneVerificationCodeCommand1(requestParameters.userId, requestParameters.phoneCodeCheckResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to endorse another user\'s skill
     * @summary Endorse a user skill
     * @param {UsersApiEndorseUserSkill1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public endorseUserSkill1(requestParameters: UsersApiEndorseUserSkill1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).endorseUserSkill1(requestParameters.userId, requestParameters.skillId, requestParameters.skillEndorsement, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a random selection of users based on specified criteria
     * @summary Fetch random list of users, with basic data
     * @param {UsersApiFetchRandomUsers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public fetchRandomUsers1(requestParameters: UsersApiFetchRandomUsers1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).fetchRandomUsers1(requestParameters.userListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the property list with specified user id
     * @param {UsersApiFindPropertiesByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findPropertiesByUser1(requestParameters: UsersApiFindPropertiesByUser1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findPropertiesByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, requestParameters.propertyPublicationState, requestParameters.xmlId, requestParameters.aPIVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Return the testimonials list with specified user id
     * @param {UsersApiFindTestimonialsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findTestimonialsByUser1(requestParameters: UsersApiFindTestimonialsByUser1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findTestimonialsByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets detailed user information by user ID
     * @summary Fetch user detail according to its id
     * @param {UsersApiFindUserById1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUserById1(requestParameters: UsersApiFindUserById1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUserById1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets user information by their unique profile name
     * @summary Fetch user detail according to its profile name
     * @param {UsersApiFindUserByProfileName1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUserByProfileName1(requestParameters: UsersApiFindUserByProfileName1Request = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUserByProfileName1(requestParameters.profileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of connections for a specific user
     * @summary Get a user connections
     * @param {UsersApiFindUserConnections1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUserConnections1(requestParameters: UsersApiFindUserConnections1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUserConnections1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets detailed information for multiple users by their IDs
     * @summary Fetch multiple user detail according to its ids
     * @param {UsersApiFindUsersByIds1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUsersByIds1(requestParameters: UsersApiFindUsersByIds1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUsersByIds1(requestParameters.userIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all users who have subscribed to the specified subscription plan
     * @summary Gets the users subscribed to a subscription plan name like Professional
     * @param {UsersApiGetSubscribedUsers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getSubscribedUsers1(requestParameters: UsersApiGetSubscribedUsers1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getSubscribedUsers1(requestParameters.subscriptionPlanName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Generates an HTML preview of a user profile for sharing purposes
     * @summary Get HTML preview of a user profile
     * @param {UsersApiPreviewPropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public previewProperty(requestParameters: UsersApiPreviewPropertyRequest = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).previewProperty(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new user account in the system
     * @summary Register new user in the system
     * @param {UsersApiRegister1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public register1(requestParameters: UsersApiRegister1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).register1(requestParameters.skilledUser, requestParameters.origin, requestParameters.skipEmailValidation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an activation link to the user\'s email for account verification
     * @summary Request activation link
     * @param {UsersApiRequestActivationLink1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public requestActivationLink1(requestParameters: UsersApiRequestActivationLink1Request = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).requestActivationLink1(requestParameters.origin, requestParameters.email, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request testimonial from specified user id
     * @param {UsersApiRequestTestimonialFromUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public requestTestimonialFromUser1(requestParameters: UsersApiRequestTestimonialFromUser1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).requestTestimonialFromUser1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all endorsements for a specific user skill
     * @summary Retrieve skill endorsements
     * @param {UsersApiRetrieveSkillEndorsements1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public retrieveSkillEndorsements1(requestParameters: UsersApiRetrieveSkillEndorsements1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).retrieveSkillEndorsements1(requestParameters.userId, requestParameters.skillId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all skills associated with a user
     * @summary Retrieve user skills
     * @param {UsersApiRetrieveUserSkillsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public retrieveUserSkills(requestParameters: UsersApiRetrieveUserSkillsRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).retrieveUserSkills(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates user profile information in the system
     * @summary Save the data of user in the system
     * @param {UsersApiSave1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public save1(requestParameters: UsersApiSave1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).save1(requestParameters.skilledUser, requestParameters.oAuthToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiSaveLog1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public saveLog1(requestParameters: UsersApiSaveLog1Request = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).saveLog1(requestParameters.logEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Searches for users matching the specified filter criteria. When authenticated (O-Auth-Token header provided), includes connection degrees (1st, 2nd, 3rd+) to other users.
     * @summary Search users with specified filters
     * @param {UsersApiSearchUsers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public searchUsers1(requestParameters: UsersApiSearchUsers1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).searchUsers1(requestParameters.userFilterRequest, requestParameters.oAuthToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an email verification link to the authenticated user\'s email address
     * @summary Send email verification to logged-in user
     * @param {UsersApiSendEmailVerification1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public sendEmailVerification1(requestParameters: UsersApiSendEmailVerification1Request = {}, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).sendEmailVerification1(requestParameters.origin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public sendPayedSusbscribersAlert1(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).sendPayedSusbscribersAlert1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends a verification code to the user\'s phone number for verification purposes
     * @summary Send a code to the previously saved phone number of the user
     * @param {UsersApiSendPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public sendPhoneVerificationCodeCommand1(requestParameters: UsersApiSendPhoneVerificationCodeCommand1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).sendPhoneVerificationCodeCommand1(requestParameters.userId, requestParameters.phoneCodeRequestResource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates Stripe Identity verification and returns a verification URL and session ID
     * @summary Start identity verification for user
     * @param {UsersApiStartIdentityVerification1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public startIdentityVerification1(requestParameters: UsersApiStartIdentityVerification1Request, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).startIdentityVerification1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetSubscribedUsers1SubscriptionPlanNameEnum = {
    Free: 'Free',
    Professional: 'Professional',
    Business: 'Business',
    Brokerage: 'Brokerage'
} as const;
export type GetSubscribedUsers1SubscriptionPlanNameEnum = typeof GetSubscribedUsers1SubscriptionPlanNameEnum[keyof typeof GetSubscribedUsers1SubscriptionPlanNameEnum];


