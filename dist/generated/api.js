"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Hallocasa API
 * Hallocasa API Documentation
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChatTicketsApiFactory = exports.ChatTicketsApiFp = exports.ChatTicketsApiAxiosParamCreator = exports.BrokeragesApi = exports.BrokeragesApiFactory = exports.BrokeragesApiFp = exports.BrokeragesApiAxiosParamCreator = exports.AttachmentsApi = exports.AttachmentsApiFactory = exports.AttachmentsApiFp = exports.AttachmentsApiAxiosParamCreator = exports.AllowancesApi = exports.AllowancesApiFactory = exports.AllowancesApiFp = exports.AllowancesApiAxiosParamCreator = exports.AlertsApi = exports.AlertsApiFactory = exports.AlertsApiFp = exports.AlertsApiAxiosParamCreator = exports.UserSubscriptionDtoStatusEnum = exports.UserSubscriptionDtoRenewalTypeEnum = exports.SubscriptionPriceDtoRenewalTypeEnum = exports.PropertyFieldHcListerOptionEnum = exports.PropertyFieldData3TypeEnum = exports.PropertyFieldData2TypeEnum = exports.PropertyFieldData1TypeEnum = exports.PropertyFieldTextTypeEnum = exports.PropertyPublicationStateEnum = exports.NotificationTypeEnum = exports.HcFilterTypeEntryRangeFieldPresentationEnum = exports.HcFilterTypeEntryFilterTypeNatureEnum = exports.HcFilterTypeRangeFieldPresentationEnum = exports.HcFilterTypeFilterTypeNatureEnum = exports.HcFilterEntryFilterWorkerOptionEnum = exports.HcFilterEntryChoiceEnum = exports.HcFilterConditionMaxOperandEnum = exports.HcFilterConditionMinOperandEnum = exports.HcFilterHcListerOptionEnum = exports.HcFilterFilterWorkerOptionEnum = exports.HcFilterChoiceEnum = exports.GroupMemberGroupMemberStatusEnum = exports.GroupGroupStatusEnum = exports.FilterShowingStepSequenceAfterEnum = exports.FilterShowingStepSequenceBeforeEnum = exports.FavoriteResourceTypeEnum = exports.DropdownOptionGroupTranslationManagementEnum = exports.ConversationSummaryChatAllowanceTypeEnum = exports.CheckoutSessionDtoStatusEnum = exports.ChatAllowanceChatAllowanceTypeEnum = exports.AlertUserAlertTypeEnum = void 0;
exports.LocalesApi = exports.LocalesApiFactory = exports.LocalesApiFp = exports.LocalesApiAxiosParamCreator = exports.LanguagesApi = exports.LanguagesApiFactory = exports.LanguagesApiFp = exports.LanguagesApiAxiosParamCreator = exports.UpdateGroupMembershipStatus1StatusEnum = exports.GroupsApi = exports.GroupsApiFactory = exports.GroupsApiFp = exports.GroupsApiAxiosParamCreator = exports.GeoLocationApi = exports.GeoLocationApiFactory = exports.GeoLocationApiFp = exports.GeoLocationApiAxiosParamCreator = exports.FavoritesApi = exports.FavoritesApiFactory = exports.FavoritesApiFp = exports.FavoritesApiAxiosParamCreator = exports.FacebookPropertiesApi = exports.FacebookPropertiesApiFactory = exports.FacebookPropertiesApiFp = exports.FacebookPropertiesApiAxiosParamCreator = exports.ExchangeRatesApi = exports.ExchangeRatesApiFactory = exports.ExchangeRatesApiFp = exports.ExchangeRatesApiAxiosParamCreator = exports.EndorsementsApi = exports.EndorsementsApiFactory = exports.EndorsementsApiFp = exports.EndorsementsApiAxiosParamCreator = exports.CustomerSessionsApi = exports.CustomerSessionsApiFactory = exports.CustomerSessionsApiFp = exports.CustomerSessionsApiAxiosParamCreator = exports.CurrencyManagementApi = exports.CurrencyManagementApiFactory = exports.CurrencyManagementApiFp = exports.CurrencyManagementApiAxiosParamCreator = exports.CountriesApi = exports.CountriesApiFactory = exports.CountriesApiFp = exports.CountriesApiAxiosParamCreator = exports.CheckoutSessionsApi = exports.CheckoutSessionsApiFactory = exports.CheckoutSessionsApiFp = exports.CheckoutSessionsApiAxiosParamCreator = exports.ChatTicketsApi = void 0;
exports.SecurityApiFactory = exports.SecurityApiFp = exports.SecurityApiAxiosParamCreator = exports.PropertyTypesApi = exports.PropertyTypesApiFactory = exports.PropertyTypesApiFp = exports.PropertyTypesApiAxiosParamCreator = exports.PropertyProposalsApi = exports.PropertyProposalsApiFactory = exports.PropertyProposalsApiFp = exports.PropertyProposalsApiAxiosParamCreator = exports.PropertyLocationsApi = exports.PropertyLocationsApiFactory = exports.PropertyLocationsApiFp = exports.PropertyLocationsApiAxiosParamCreator = exports.PropertyFiltersApi = exports.PropertyFiltersApiFactory = exports.PropertyFiltersApiFp = exports.PropertyFiltersApiAxiosParamCreator = exports.PropertyFieldApi = exports.PropertyFieldApiFactory = exports.PropertyFieldApiFp = exports.PropertyFieldApiAxiosParamCreator = exports.UploadPropertiesFromUrl1FormatEnum = exports.UploadProperties1FormatEnum = exports.PropertyBulkUploadsApi = exports.PropertyBulkUploadsApiFactory = exports.PropertyBulkUploadsApiFp = exports.PropertyBulkUploadsApiAxiosParamCreator = exports.PropertyBulkDownloadApi = exports.PropertyBulkDownloadApiFactory = exports.PropertyBulkDownloadApiFp = exports.PropertyBulkDownloadApiAxiosParamCreator = exports.PropertiesApi = exports.PropertiesApiFactory = exports.PropertiesApiFp = exports.PropertiesApiAxiosParamCreator = exports.PhonePrefixesApi = exports.PhonePrefixesApiFactory = exports.PhonePrefixesApiFp = exports.PhonePrefixesApiAxiosParamCreator = exports.PasswordRecoveryApi = exports.PasswordRecoveryApiFactory = exports.PasswordRecoveryApiFp = exports.PasswordRecoveryApiAxiosParamCreator = exports.GetByUserWithResult1TypeEnum = exports.MessagesApi = exports.MessagesApiFactory = exports.MessagesApiFp = exports.MessagesApiAxiosParamCreator = void 0;
exports.UsersApi = exports.UsersApiFactory = exports.UsersApiFp = exports.UsersApiAxiosParamCreator = exports.UserTypesApi = exports.UserTypesApiFactory = exports.UserTypesApiFp = exports.UserTypesApiAxiosParamCreator = exports.UserSummaryApi = exports.UserSummaryApiFactory = exports.UserSummaryApiFp = exports.UserSummaryApiAxiosParamCreator = exports.UserContractsApi = exports.UserContractsApiFactory = exports.UserContractsApiFp = exports.UserContractsApiAxiosParamCreator = exports.UserConnectionsApi = exports.UserConnectionsApiFactory = exports.UserConnectionsApiFp = exports.UserConnectionsApiAxiosParamCreator = exports.TextTranslationsApi = exports.TextTranslationsApiFactory = exports.TextTranslationsApiFp = exports.TextTranslationsApiAxiosParamCreator = exports.TestimonialApi = exports.TestimonialApiFactory = exports.TestimonialApiFp = exports.TestimonialApiAxiosParamCreator = exports.SubscriptionsApi = exports.SubscriptionsApiFactory = exports.SubscriptionsApiFp = exports.SubscriptionsApiAxiosParamCreator = exports.StripeWebhooksApi = exports.StripeWebhooksApiFactory = exports.StripeWebhooksApiFp = exports.StripeWebhooksApiAxiosParamCreator = exports.SkillsApi = exports.SkillsApiFactory = exports.SkillsApiFp = exports.SkillsApiAxiosParamCreator = exports.SecurityApi = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.AlertUserAlertTypeEnum = {
    Property: 'PROPERTY'
};
exports.ChatAllowanceChatAllowanceTypeEnum = {
    Rejected: 'REJECTED',
    Accepted: 'ACCEPTED',
    Pending: 'PENDING',
    Blocked: 'BLOCKED',
    Silenced: 'SILENCED'
};
exports.CheckoutSessionDtoStatusEnum = {
    InProcess: 'IN_PROCESS',
    Success: 'SUCCESS',
    Canceled: 'CANCELED',
    Failed: 'FAILED'
};
exports.ConversationSummaryChatAllowanceTypeEnum = {
    Rejected: 'REJECTED',
    Accepted: 'ACCEPTED',
    Pending: 'PENDING',
    Blocked: 'BLOCKED',
    Silenced: 'SILENCED'
};
exports.DropdownOptionGroupTranslationManagementEnum = {
    Total: 'TOTAL',
    Partial: 'PARTIAL',
    None: 'NONE'
};
exports.FavoriteResourceTypeEnum = {
    Property: 'PROPERTY'
};
exports.FilterShowingStepSequenceBeforeEnum = {
    InitGroup: 'INIT_GROUP',
    EndGroup: 'END_GROUP',
    And: 'AND',
    Or: 'OR'
};
exports.FilterShowingStepSequenceAfterEnum = {
    InitGroup: 'INIT_GROUP',
    EndGroup: 'END_GROUP',
    And: 'AND',
    Or: 'OR'
};
exports.GroupGroupStatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED',
    Deleted: 'DELETED'
};
exports.GroupMemberGroupMemberStatusEnum = {
    Invited: 'INVITED',
    Requested: 'REQUESTED',
    Accepted: 'ACCEPTED',
    Rejected: 'REJECTED',
    Removed: 'REMOVED',
    Left: 'LEFT'
};
exports.HcFilterChoiceEnum = {
    Show: 'SHOW',
    Hide: 'HIDE'
};
exports.HcFilterFilterWorkerOptionEnum = {
    PropertyLocationKey: 'PROPERTY_LOCATION_KEY',
    CountryKey: 'COUNTRY_KEY',
    PropertyProposalKey: 'PROPERTY_PROPOSAL_KEY',
    Range: 'RANGE',
    Dropdown: 'DROPDOWN',
    Boolean: 'BOOLEAN',
    CurrencyRange: 'CURRENCY_RANGE',
    Roi: 'ROI',
    FreeText: 'FREE_TEXT',
    Id: 'ID',
    PublicationState: 'PUBLICATION_STATE',
    PublicationDate: 'PUBLICATION_DATE',
    GeolocationArea: 'GEOLOCATION_AREA',
    Groups: 'GROUPS',
    UserId: 'USER_ID',
    XmlId: 'XML_ID'
};
exports.HcFilterHcListerOptionEnum = {
    PropertyType: 'PROPERTY_TYPE'
};
exports.HcFilterConditionMinOperandEnum = {
    Gt: 'GT',
    Get: 'GET',
    Eq: 'EQ',
    Lt: 'LT',
    Let: 'LET'
};
exports.HcFilterConditionMaxOperandEnum = {
    Gt: 'GT',
    Get: 'GET',
    Eq: 'EQ',
    Lt: 'LT',
    Let: 'LET'
};
exports.HcFilterEntryChoiceEnum = {
    Show: 'SHOW',
    Hide: 'HIDE'
};
exports.HcFilterEntryFilterWorkerOptionEnum = {
    PropertyLocationKey: 'PROPERTY_LOCATION_KEY',
    CountryKey: 'COUNTRY_KEY',
    PropertyProposalKey: 'PROPERTY_PROPOSAL_KEY',
    Range: 'RANGE',
    Dropdown: 'DROPDOWN',
    Boolean: 'BOOLEAN',
    CurrencyRange: 'CURRENCY_RANGE',
    Roi: 'ROI',
    FreeText: 'FREE_TEXT',
    Id: 'ID',
    PublicationState: 'PUBLICATION_STATE',
    PublicationDate: 'PUBLICATION_DATE',
    GeolocationArea: 'GEOLOCATION_AREA',
    Groups: 'GROUPS',
    UserId: 'USER_ID',
    XmlId: 'XML_ID'
};
exports.HcFilterTypeFilterTypeNatureEnum = {
    Dropdown: 'DROPDOWN',
    Yesno: 'YESNO',
    Range: 'RANGE',
    Text: 'TEXT',
    AreaRange: 'AREA_RANGE'
};
exports.HcFilterTypeRangeFieldPresentationEnum = {
    Integer: 'INTEGER',
    Double: 'DOUBLE',
    Currency: 'CURRENCY',
    Date: 'DATE'
};
exports.HcFilterTypeEntryFilterTypeNatureEnum = {
    Dropdown: 'DROPDOWN',
    Yesno: 'YESNO',
    Range: 'RANGE',
    Text: 'TEXT',
    AreaRange: 'AREA_RANGE'
};
exports.HcFilterTypeEntryRangeFieldPresentationEnum = {
    Integer: 'INTEGER',
    Double: 'DOUBLE',
    Currency: 'CURRENCY',
    Date: 'DATE'
};
exports.NotificationTypeEnum = {
    ToBrokerAlertCreated: 'TO_BROKER__ALERT_CREATED',
    ToUserWeeklyProperties: 'TO_USER__WEEKLY_PROPERTIES',
    ToUserWeeklyPayedSubscribers: 'TO_USER__WEEKLY_PAYED_SUBSCRIBERS',
    ToUserCustomizedAlert: 'TO_USER__CUSTOMIZED_ALERT',
    ToUserWeeklyGroupProperties: 'TO_USER__WEEKLY_GROUP_PROPERTIES',
    ToUserNewsletterNewSubscriber: 'TO_USER__NEWSLETTER_NEW_SUBSCRIBER',
    ToUserNewsletterConfirmation: 'TO_USER__NEWSLETTER_CONFIRMATION',
    ToUserNewsletterListing: 'TO_USER__NEWSLETTER_LISTING'
};
exports.PropertyPublicationStateEnum = {
    Available: 'AVAILABLE',
    Rented: 'RENTED',
    Sold: 'SOLD',
    Draft: 'DRAFT'
};
exports.PropertyFieldTextTypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
};
exports.PropertyFieldData1TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
};
exports.PropertyFieldData2TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
};
exports.PropertyFieldData3TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
};
exports.PropertyFieldHcListerOptionEnum = {
    PropertyType: 'PROPERTY_TYPE'
};
exports.SubscriptionPriceDtoRenewalTypeEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Every3Months: 'EVERY_3_MONTHS',
    Every6Months: 'EVERY_6_MONTHS',
    Yearly: 'YEARLY'
};
exports.UserSubscriptionDtoRenewalTypeEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Every3Months: 'EVERY_3_MONTHS',
    Every6Months: 'EVERY_6_MONTHS',
    Yearly: 'YEARLY'
};
exports.UserSubscriptionDtoStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
};
/**
 * AlertsApi - axios parameter creator
 * @export
 */
const AlertsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert1: async (userId, alertId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlert1', 'userId', userId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAlert1', 'alertId', alertId);
            const localVarPath = `/users/{userId}/alerts/{alertId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to retrieve results for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertResult1: async (userId, alertId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getAlertResult1', 'userId', userId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)('getAlertResult1', 'alertId', alertId);
            const localVarPath = `/users/{userId}/alerts/{alertId}/result`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {number} userId ID of the user to retrieve alerts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser2: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getByUser2', 'userId', userId);
            const localVarPath = `/users/{userId}/alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {number} userId ID of the user who subscribed to newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterAlerts1: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('newsletterAlerts1', 'userId', userId);
            const localVarPath = `/users/{userId}/alerts/newsletter-alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {number} userId ID of the user who owns the newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterSubscribers1: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('newsletterSubscribers1', 'userId', userId);
            const localVarPath = `/users/{userId}/alerts/newsletter-subscribers`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {number} userId ID of the user to create the alert for
         * @param {Alert} alert Alert to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlert1: async (userId, alert, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('saveAlert1', 'userId', userId);
            // verify required parameter 'alert' is not null or undefined
            (0, common_1.assertParamExists)('saveAlert1', 'alert', alert);
            const localVarPath = `/users/{userId}/alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(alert, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {number} userId ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('sendAlert', 'userId', userId);
            const localVarPath = `/users/{userId}/alerts/send-alert`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AlertsApiAxiosParamCreator = AlertsApiAxiosParamCreator;
/**
 * AlertsApi - functional programming interface
 * @export
 */
const AlertsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AlertsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert1(userId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert1(userId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.deleteAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to retrieve results for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertResult1(userId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertResult1(userId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.getAlertResult1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {number} userId ID of the user to retrieve alerts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUser2(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUser2(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.getByUser2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {number} userId ID of the user who subscribed to newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsletterAlerts1(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsletterAlerts1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.newsletterAlerts1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {number} userId ID of the user who owns the newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsletterSubscribers1(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsletterSubscribers1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.newsletterSubscribers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {number} userId ID of the user to create the alert for
         * @param {Alert} alert Alert to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAlert1(userId, alert, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveAlert1(userId, alert, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.saveAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {number} userId ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendAlert(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendAlert(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AlertsApi.sendAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AlertsApiFp = AlertsApiFp;
/**
 * AlertsApi - factory interface
 * @export
 */
const AlertsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AlertsApiFp)(configuration);
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {AlertsApiDeleteAlert1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert1(requestParameters, options) {
            return localVarFp.deleteAlert1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {AlertsApiGetAlertResult1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertResult1(requestParameters, options) {
            return localVarFp.getAlertResult1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {AlertsApiGetByUser2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser2(requestParameters, options) {
            return localVarFp.getByUser2(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {AlertsApiNewsletterAlerts1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterAlerts1(requestParameters, options) {
            return localVarFp.newsletterAlerts1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {AlertsApiNewsletterSubscribers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterSubscribers1(requestParameters, options) {
            return localVarFp.newsletterSubscribers1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {AlertsApiSaveAlert1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlert1(requestParameters, options) {
            return localVarFp.saveAlert1(requestParameters.userId, requestParameters.alert, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {AlertsApiSendAlertRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert(requestParameters, options) {
            return localVarFp.sendAlert(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AlertsApiFactory = AlertsApiFactory;
/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
class AlertsApi extends base_1.BaseAPI {
    /**
     * Deletes a specific alert owned by the user
     * @summary Delete an alert
     * @param {AlertsApiDeleteAlert1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    deleteAlert1(requestParameters, options) {
        return (0, exports.AlertsApiFp)(this.configuration).deleteAlert1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the results for a specific alert
     * @summary Get alert results
     * @param {AlertsApiGetAlertResult1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    getAlertResult1(requestParameters, options) {
        return (0, exports.AlertsApiFp)(this.configuration).getAlertResult1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all alerts associated with the specified user ID
     * @summary Get all alerts for a user
     * @param {AlertsApiGetByUser2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    getByUser2(requestParameters, options) {
        return (0, exports.AlertsApiFp)(this.configuration).getByUser2(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all newsletters that the specified user has subscribed to
     * @summary Get newsletters subscribed to
     * @param {AlertsApiNewsletterAlerts1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    newsletterAlerts1(requestParameters, options) {
        return (0, exports.AlertsApiFp)(this.configuration).newsletterAlerts1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all subscribers to newsletters owned by the specified user
     * @summary Get newsletter subscribers
     * @param {AlertsApiNewsletterSubscribers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    newsletterSubscribers1(requestParameters, options) {
        return (0, exports.AlertsApiFp)(this.configuration).newsletterSubscribers1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new alert for the specified user
     * @summary Create a new alert
     * @param {AlertsApiSaveAlert1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    saveAlert1(requestParameters, options) {
        return (0, exports.AlertsApiFp)(this.configuration).saveAlert1(requestParameters.userId, requestParameters.alert, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Triggers the sending of customized property alerts to users
     * @summary Send customized property alerts
     * @param {AlertsApiSendAlertRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    sendAlert(requestParameters, options) {
        return (0, exports.AlertsApiFp)(this.configuration).sendAlert(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AlertsApi = AlertsApi;
/**
 * AllowancesApi - axios parameter creator
 * @export
 */
const AllowancesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
         * @summary Get chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatAllowance1: async (userPair, options = {}) => {
            // verify required parameter 'userPair' is not null or undefined
            (0, common_1.assertParamExists)('getChatAllowance1', 'userPair', userPair);
            const localVarPath = `/chat/allowance/{userPair}`
                .replace(`{${"userPair"}}`, encodeURIComponent(String(userPair)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the chat allowance settings between two users
         * @summary Update chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {ChatAllowance} chatAllowance Chat allowance information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatAllowance1: async (userPair, chatAllowance, options = {}) => {
            // verify required parameter 'userPair' is not null or undefined
            (0, common_1.assertParamExists)('updateChatAllowance1', 'userPair', userPair);
            // verify required parameter 'chatAllowance' is not null or undefined
            (0, common_1.assertParamExists)('updateChatAllowance1', 'chatAllowance', chatAllowance);
            const localVarPath = `/chat/allowance/{userPair}`
                .replace(`{${"userPair"}}`, encodeURIComponent(String(userPair)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(chatAllowance, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AllowancesApiAxiosParamCreator = AllowancesApiAxiosParamCreator;
/**
 * AllowancesApi - functional programming interface
 * @export
 */
const AllowancesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AllowancesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
         * @summary Get chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatAllowance1(userPair, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatAllowance1(userPair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AllowancesApi.getChatAllowance1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the chat allowance settings between two users
         * @summary Update chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {ChatAllowance} chatAllowance Chat allowance information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChatAllowance1(userPair, chatAllowance, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChatAllowance1(userPair, chatAllowance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AllowancesApi.updateChatAllowance1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AllowancesApiFp = AllowancesApiFp;
/**
 * AllowancesApi - factory interface
 * @export
 */
const AllowancesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AllowancesApiFp)(configuration);
    return {
        /**
         * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
         * @summary Get chat allowance for a user pair
         * @param {AllowancesApiGetChatAllowance1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatAllowance1(requestParameters, options) {
            return localVarFp.getChatAllowance1(requestParameters.userPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the chat allowance settings between two users
         * @summary Update chat allowance for a user pair
         * @param {AllowancesApiUpdateChatAllowance1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatAllowance1(requestParameters, options) {
            return localVarFp.updateChatAllowance1(requestParameters.userPair, requestParameters.chatAllowance, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AllowancesApiFactory = AllowancesApiFactory;
/**
 * AllowancesApi - object-oriented interface
 * @export
 * @class AllowancesApi
 * @extends {BaseAPI}
 */
class AllowancesApi extends base_1.BaseAPI {
    /**
     * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
     * @summary Get chat allowance for a user pair
     * @param {AllowancesApiGetChatAllowance1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    getChatAllowance1(requestParameters, options) {
        return (0, exports.AllowancesApiFp)(this.configuration).getChatAllowance1(requestParameters.userPair, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the chat allowance settings between two users
     * @summary Update chat allowance for a user pair
     * @param {AllowancesApiUpdateChatAllowance1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    updateChatAllowance1(requestParameters, options) {
        return (0, exports.AllowancesApiFp)(this.configuration).updateChatAllowance1(requestParameters.userPair, requestParameters.chatAllowance, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AllowancesApi = AllowancesApi;
/**
 * AttachmentsApi - axios parameter creator
 * @export
 */
const AttachmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post a attachment request
         * @param {Attachment} [attachment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment1: async (attachment, options = {}) => {
            const localVarPath = `/chat/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(attachment, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get details to download a file
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAttachment1: async (fileId, options = {}) => {
            // verify required parameter 'fileId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveAttachment1', 'fileId', fileId);
            const localVarPath = `/chat/attachments/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Notify a new file has been loaded in S3
         * @param {string} fileId
         * @param {NotifyUploadRequest} [notifyUploadRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment1: async (fileId, notifyUploadRequest, options = {}) => {
            // verify required parameter 'fileId' is not null or undefined
            (0, common_1.assertParamExists)('updateAttachment1', 'fileId', fileId);
            const localVarPath = `/chat/attachments/{fileId}/notify-upload`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(notifyUploadRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AttachmentsApiAxiosParamCreator = AttachmentsApiAxiosParamCreator;
/**
 * AttachmentsApi - functional programming interface
 * @export
 */
const AttachmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AttachmentsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Post a attachment request
         * @param {Attachment} [attachment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttachment1(attachment, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttachment1(attachment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AttachmentsApi.createAttachment1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get details to download a file
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAttachment1(fileId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAttachment1(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AttachmentsApi.retrieveAttachment1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Notify a new file has been loaded in S3
         * @param {string} fileId
         * @param {NotifyUploadRequest} [notifyUploadRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAttachment1(fileId, notifyUploadRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAttachment1(fileId, notifyUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['AttachmentsApi.updateAttachment1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.AttachmentsApiFp = AttachmentsApiFp;
/**
 * AttachmentsApi - factory interface
 * @export
 */
const AttachmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AttachmentsApiFp)(configuration);
    return {
        /**
         *
         * @summary Post a attachment request
         * @param {AttachmentsApiCreateAttachment1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment1(requestParameters = {}, options) {
            return localVarFp.createAttachment1(requestParameters.attachment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get details to download a file
         * @param {AttachmentsApiRetrieveAttachment1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAttachment1(requestParameters, options) {
            return localVarFp.retrieveAttachment1(requestParameters.fileId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Notify a new file has been loaded in S3
         * @param {AttachmentsApiUpdateAttachment1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment1(requestParameters, options) {
            return localVarFp.updateAttachment1(requestParameters.fileId, requestParameters.notifyUploadRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AttachmentsApiFactory = AttachmentsApiFactory;
/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
class AttachmentsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Post a attachment request
     * @param {AttachmentsApiCreateAttachment1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    createAttachment1(requestParameters = {}, options) {
        return (0, exports.AttachmentsApiFp)(this.configuration).createAttachment1(requestParameters.attachment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get details to download a file
     * @param {AttachmentsApiRetrieveAttachment1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    retrieveAttachment1(requestParameters, options) {
        return (0, exports.AttachmentsApiFp)(this.configuration).retrieveAttachment1(requestParameters.fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Notify a new file has been loaded in S3
     * @param {AttachmentsApiUpdateAttachment1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    updateAttachment1(requestParameters, options) {
        return (0, exports.AttachmentsApiFp)(this.configuration).updateAttachment1(requestParameters.fileId, requestParameters.notifyUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AttachmentsApi = AttachmentsApi;
/**
 * BrokeragesApi - axios parameter creator
 * @export
 */
const BrokeragesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve1: async (options = {}) => {
            const localVarPath = `/brokerages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.BrokeragesApiAxiosParamCreator = BrokeragesApiAxiosParamCreator;
/**
 * BrokeragesApi - functional programming interface
 * @export
 */
const BrokeragesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BrokeragesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['BrokeragesApi.retrieve1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.BrokeragesApiFp = BrokeragesApiFp;
/**
 * BrokeragesApi - factory interface
 * @export
 */
const BrokeragesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BrokeragesApiFp)(configuration);
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve1(options) {
            return localVarFp.retrieve1(options).then((request) => request(axios, basePath));
        },
    };
};
exports.BrokeragesApiFactory = BrokeragesApiFactory;
/**
 * BrokeragesApi - object-oriented interface
 * @export
 * @class BrokeragesApi
 * @extends {BaseAPI}
 */
class BrokeragesApi extends base_1.BaseAPI {
    /**
     * Returns a list of all available brokerages in the system
     * @summary Retrieve all brokerages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokeragesApi
     */
    retrieve1(options) {
        return (0, exports.BrokeragesApiFp)(this.configuration).retrieve1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BrokeragesApi = BrokeragesApi;
/**
 * ChatTicketsApi - axios parameter creator
 * @export
 */
const ChatTicketsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates and returns a chat ticket that can be used to establish a chat connection
         * @summary Retrieve a chat ticket for the authenticated user
         * @param {string} userAgent User agent string of the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserTicket1: async (userAgent, options = {}) => {
            // verify required parameter 'userAgent' is not null or undefined
            (0, common_1.assertParamExists)('retrieveUserTicket1', 'userAgent', userAgent);
            const localVarPath = `/chat/ticket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (userAgent != null) {
                localVarHeaderParameter['user-agent'] = String(userAgent);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ChatTicketsApiAxiosParamCreator = ChatTicketsApiAxiosParamCreator;
/**
 * ChatTicketsApi - functional programming interface
 * @export
 */
const ChatTicketsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ChatTicketsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Creates and returns a chat ticket that can be used to establish a chat connection
         * @summary Retrieve a chat ticket for the authenticated user
         * @param {string} userAgent User agent string of the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserTicket1(userAgent, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserTicket1(userAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ChatTicketsApi.retrieveUserTicket1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.ChatTicketsApiFp = ChatTicketsApiFp;
/**
 * ChatTicketsApi - factory interface
 * @export
 */
const ChatTicketsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ChatTicketsApiFp)(configuration);
    return {
        /**
         * Creates and returns a chat ticket that can be used to establish a chat connection
         * @summary Retrieve a chat ticket for the authenticated user
         * @param {ChatTicketsApiRetrieveUserTicket1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserTicket1(requestParameters, options) {
            return localVarFp.retrieveUserTicket1(requestParameters.userAgent, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ChatTicketsApiFactory = ChatTicketsApiFactory;
/**
 * ChatTicketsApi - object-oriented interface
 * @export
 * @class ChatTicketsApi
 * @extends {BaseAPI}
 */
class ChatTicketsApi extends base_1.BaseAPI {
    /**
     * Creates and returns a chat ticket that can be used to establish a chat connection
     * @summary Retrieve a chat ticket for the authenticated user
     * @param {ChatTicketsApiRetrieveUserTicket1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatTicketsApi
     */
    retrieveUserTicket1(requestParameters, options) {
        return (0, exports.ChatTicketsApiFp)(this.configuration).retrieveUserTicket1(requestParameters.userAgent, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ChatTicketsApi = ChatTicketsApi;
/**
 * CheckoutSessionsApi - axios parameter creator
 * @export
 */
const CheckoutSessionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CheckoutSessionDto} checkoutSessionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession2: async (checkoutSessionDto, options = {}) => {
            // verify required parameter 'checkoutSessionDto' is not null or undefined
            (0, common_1.assertParamExists)('createCheckoutSession2', 'checkoutSessionDto', checkoutSessionDto);
            const localVarPath = `/checkout-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(checkoutSessionDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CheckoutSessionsApiAxiosParamCreator = CheckoutSessionsApiAxiosParamCreator;
/**
 * CheckoutSessionsApi - functional programming interface
 * @export
 */
const CheckoutSessionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CheckoutSessionsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CheckoutSessionDto} checkoutSessionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSession2(checkoutSessionDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSession2(checkoutSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['CheckoutSessionsApi.createCheckoutSession2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.CheckoutSessionsApiFp = CheckoutSessionsApiFp;
/**
 * CheckoutSessionsApi - factory interface
 * @export
 */
const CheckoutSessionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CheckoutSessionsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CheckoutSessionsApiCreateCheckoutSession2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession2(requestParameters, options) {
            return localVarFp.createCheckoutSession2(requestParameters.checkoutSessionDto, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CheckoutSessionsApiFactory = CheckoutSessionsApiFactory;
/**
 * CheckoutSessionsApi - object-oriented interface
 * @export
 * @class CheckoutSessionsApi
 * @extends {BaseAPI}
 */
class CheckoutSessionsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create checkout-session
     * @param {CheckoutSessionsApiCreateCheckoutSession2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutSessionsApi
     */
    createCheckoutSession2(requestParameters, options) {
        return (0, exports.CheckoutSessionsApiFp)(this.configuration).createCheckoutSession2(requestParameters.checkoutSessionDto, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CheckoutSessionsApi = CheckoutSessionsApi;
/**
 * CountriesApi - axios parameter creator
 * @export
 */
const CountriesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries2: async (options = {}) => {
            const localVarPath = `/countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Method to find a country by the caller IP
         * @param {string} [xForwardedFor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByIp1: async (xForwardedFor, options = {}) => {
            const localVarPath = `/countries/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xForwardedFor != null) {
                localVarHeaderParameter['X-Forwarded-For'] = String(xForwardedFor);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CountriesApiAxiosParamCreator = CountriesApiAxiosParamCreator;
/**
 * CountriesApi - functional programming interface
 * @export
 */
const CountriesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CountriesApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCountries2(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCountries2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['CountriesApi.getAllCountries2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Method to find a country by the caller IP
         * @param {string} [xForwardedFor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByIp1(xForwardedFor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByIp1(xForwardedFor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['CountriesApi.getCountryByIp1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.CountriesApiFp = CountriesApiFp;
/**
 * CountriesApi - factory interface
 * @export
 */
const CountriesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CountriesApiFp)(configuration);
    return {
        /**
         *
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries2(options) {
            return localVarFp.getAllCountries2(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Method to find a country by the caller IP
         * @param {CountriesApiGetCountryByIp1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByIp1(requestParameters = {}, options) {
            return localVarFp.getCountryByIp1(requestParameters.xForwardedFor, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CountriesApiFactory = CountriesApiFactory;
/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
class CountriesApi extends base_1.BaseAPI {
    /**
     *
     * @summary Method to find all the countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    getAllCountries2(options) {
        return (0, exports.CountriesApiFp)(this.configuration).getAllCountries2(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Method to find a country by the caller IP
     * @param {CountriesApiGetCountryByIp1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    getCountryByIp1(requestParameters = {}, options) {
        return (0, exports.CountriesApiFp)(this.configuration).getCountryByIp1(requestParameters.xForwardedFor, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CountriesApi = CountriesApi;
/**
 * CurrencyManagementApi - axios parameter creator
 * @export
 */
const CurrencyManagementApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies1: async (options = {}) => {
            const localVarPath = `/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CurrencyManagementApiAxiosParamCreator = CurrencyManagementApiAxiosParamCreator;
/**
 * CurrencyManagementApi - functional programming interface
 * @export
 */
const CurrencyManagementApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CurrencyManagementApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencies1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencies1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['CurrencyManagementApi.getCurrencies1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.CurrencyManagementApiFp = CurrencyManagementApiFp;
/**
 * CurrencyManagementApi - factory interface
 * @export
 */
const CurrencyManagementApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CurrencyManagementApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies1(options) {
            return localVarFp.getCurrencies1(options).then((request) => request(axios, basePath));
        },
    };
};
exports.CurrencyManagementApiFactory = CurrencyManagementApiFactory;
/**
 * CurrencyManagementApi - object-oriented interface
 * @export
 * @class CurrencyManagementApi
 * @extends {BaseAPI}
 */
class CurrencyManagementApi extends base_1.BaseAPI {
    /**
     *
     * @summary Retrieves the list of all exchange available in application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyManagementApi
     */
    getCurrencies1(options) {
        return (0, exports.CurrencyManagementApiFp)(this.configuration).getCurrencies1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CurrencyManagementApi = CurrencyManagementApi;
/**
 * CustomerSessionsApi - axios parameter creator
 * @export
 */
const CustomerSessionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CustomerSessionDto} customerSessionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession: async (customerSessionDto, options = {}) => {
            // verify required parameter 'customerSessionDto' is not null or undefined
            (0, common_1.assertParamExists)('createCheckoutSession', 'customerSessionDto', customerSessionDto);
            const localVarPath = `/customer-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(customerSessionDto, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CustomerSessionsApiAxiosParamCreator = CustomerSessionsApiAxiosParamCreator;
/**
 * CustomerSessionsApi - functional programming interface
 * @export
 */
const CustomerSessionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CustomerSessionsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CustomerSessionDto} customerSessionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSession(customerSessionDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSession(customerSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['CustomerSessionsApi.createCheckoutSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.CustomerSessionsApiFp = CustomerSessionsApiFp;
/**
 * CustomerSessionsApi - factory interface
 * @export
 */
const CustomerSessionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CustomerSessionsApiFp)(configuration);
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CustomerSessionsApiCreateCheckoutSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession(requestParameters, options) {
            return localVarFp.createCheckoutSession(requestParameters.customerSessionDto, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CustomerSessionsApiFactory = CustomerSessionsApiFactory;
/**
 * CustomerSessionsApi - object-oriented interface
 * @export
 * @class CustomerSessionsApi
 * @extends {BaseAPI}
 */
class CustomerSessionsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create checkout-session
     * @param {CustomerSessionsApiCreateCheckoutSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerSessionsApi
     */
    createCheckoutSession(requestParameters, options) {
        return (0, exports.CustomerSessionsApiFp)(this.configuration).createCheckoutSession(requestParameters.customerSessionDto, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CustomerSessionsApi = CustomerSessionsApi;
/**
 * EndorsementsApi - axios parameter creator
 * @export
 */
const EndorsementsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {number} userId ID of the user to get endorsements for
         * @param {number} [endorser] Optional endorser ID to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEndorsementsByUser1: async (userId, endorser, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveEndorsementsByUser1', 'userId', userId);
            const localVarPath = `/users/{userId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (endorser !== undefined) {
                localVarQueryParameter['endorser'] = endorser;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EndorsementsApiAxiosParamCreator = EndorsementsApiAxiosParamCreator;
/**
 * EndorsementsApi - functional programming interface
 * @export
 */
const EndorsementsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.EndorsementsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {number} userId ID of the user to get endorsements for
         * @param {number} [endorser] Optional endorser ID to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveEndorsementsByUser1(userId, endorser, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveEndorsementsByUser1(userId, endorser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['EndorsementsApi.retrieveEndorsementsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.EndorsementsApiFp = EndorsementsApiFp;
/**
 * EndorsementsApi - factory interface
 * @export
 */
const EndorsementsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.EndorsementsApiFp)(configuration);
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {EndorsementsApiRetrieveEndorsementsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEndorsementsByUser1(requestParameters, options) {
            return localVarFp.retrieveEndorsementsByUser1(requestParameters.userId, requestParameters.endorser, options).then((request) => request(axios, basePath));
        },
    };
};
exports.EndorsementsApiFactory = EndorsementsApiFactory;
/**
 * EndorsementsApi - object-oriented interface
 * @export
 * @class EndorsementsApi
 * @extends {BaseAPI}
 */
class EndorsementsApi extends base_1.BaseAPI {
    /**
     * Gets all endorsements for a specified user. Can be filtered by endorser ID.
     * @summary Retrieve endorsements for a user
     * @param {EndorsementsApiRetrieveEndorsementsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndorsementsApi
     */
    retrieveEndorsementsByUser1(requestParameters, options) {
        return (0, exports.EndorsementsApiFp)(this.configuration).retrieveEndorsementsByUser1(requestParameters.userId, requestParameters.endorser, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.EndorsementsApi = EndorsementsApi;
/**
 * ExchangeRatesApi - axios parameter creator
 * @export
 */
const ExchangeRatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExchangeRates1: async (options = {}) => {
            const localVarPath = `/exchange-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ExchangeRatesApiAxiosParamCreator = ExchangeRatesApiAxiosParamCreator;
/**
 * ExchangeRatesApi - functional programming interface
 * @export
 */
const ExchangeRatesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ExchangeRatesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findExchangeRates1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findExchangeRates1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['ExchangeRatesApi.findExchangeRates1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.ExchangeRatesApiFp = ExchangeRatesApiFp;
/**
 * ExchangeRatesApi - factory interface
 * @export
 */
const ExchangeRatesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ExchangeRatesApiFp)(configuration);
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExchangeRates1(options) {
            return localVarFp.findExchangeRates1(options).then((request) => request(axios, basePath));
        },
    };
};
exports.ExchangeRatesApiFactory = ExchangeRatesApiFactory;
/**
 * ExchangeRatesApi - object-oriented interface
 * @export
 * @class ExchangeRatesApi
 * @extends {BaseAPI}
 */
class ExchangeRatesApi extends base_1.BaseAPI {
    /**
     * Returns a map of currency exchange rates between different currencies
     * @summary Method to find all the exchange rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeRatesApi
     */
    findExchangeRates1(options) {
        return (0, exports.ExchangeRatesApiFp)(this.configuration).findExchangeRates1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExchangeRatesApi = ExchangeRatesApi;
/**
 * FacebookPropertiesApi - axios parameter creator
 * @export
 */
const FacebookPropertiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {string} startDate Start date for property export (ISO format)
         * @param {string} endDate End date for property export (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties: async (startDate, endDate, options = {}) => {
            // verify required parameter 'startDate' is not null or undefined
            (0, common_1.assertParamExists)('uploadKyeroProperties', 'startDate', startDate);
            // verify required parameter 'endDate' is not null or undefined
            (0, common_1.assertParamExists)('uploadKyeroProperties', 'endDate', endDate);
            const localVarPath = `/facebook-properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (startDate !== undefined) {
                localVarQueryParameter['start-date'] = (startDate instanceof Date) ?
                    startDate.toISOString().substring(0, 10) :
                    startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end-date'] = (endDate instanceof Date) ?
                    endDate.toISOString().substring(0, 10) :
                    endDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FacebookPropertiesApiAxiosParamCreator = FacebookPropertiesApiAxiosParamCreator;
/**
 * FacebookPropertiesApi - functional programming interface
 * @export
 */
const FacebookPropertiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FacebookPropertiesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {string} startDate Start date for property export (ISO format)
         * @param {string} endDate End date for property export (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroProperties(startDate, endDate, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroProperties(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FacebookPropertiesApi.uploadKyeroProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.FacebookPropertiesApiFp = FacebookPropertiesApiFp;
/**
 * FacebookPropertiesApi - factory interface
 * @export
 */
const FacebookPropertiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FacebookPropertiesApiFp)(configuration);
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {FacebookPropertiesApiUploadKyeroPropertiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties(requestParameters, options) {
            return localVarFp.uploadKyeroProperties(requestParameters.startDate, requestParameters.endDate, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FacebookPropertiesApiFactory = FacebookPropertiesApiFactory;
/**
 * FacebookPropertiesApi - object-oriented interface
 * @export
 * @class FacebookPropertiesApi
 * @extends {BaseAPI}
 */
class FacebookPropertiesApi extends base_1.BaseAPI {
    /**
     * Exports property data to Facebook Marketplace format within the specified date range
     * @summary Export properties to Facebook Marketplace
     * @param {FacebookPropertiesApiUploadKyeroPropertiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacebookPropertiesApi
     */
    uploadKyeroProperties(requestParameters, options) {
        return (0, exports.FacebookPropertiesApiFp)(this.configuration).uploadKyeroProperties(requestParameters.startDate, requestParameters.endDate, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FacebookPropertiesApi = FacebookPropertiesApi;
/**
 * FavoritesApi - axios parameter creator
 * @export
 */
const FavoritesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {number} userId ID of the user
         * @param {boolean} [includeResource] Whether to include the associated resource details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser: async (userId, includeResource, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getByUser', 'userId', userId);
            const localVarPath = `/users/{userId}/favorites`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (includeResource !== undefined) {
                localVarQueryParameter['includeResource'] = includeResource;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {number} userId ID of the user
         * @param {Favorite} favorite Favorite to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserFavorite1: async (userId, favorite, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('postUserFavorite1', 'userId', userId);
            // verify required parameter 'favorite' is not null or undefined
            (0, common_1.assertParamExists)('postUserFavorite1', 'favorite', favorite);
            const localVarPath = `/users/{userId}/favorites`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(favorite, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {number} userId ID of the user
         * @param {number} favoriteId ID of the favorite to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFavorite1: async (userId, favoriteId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('removeUserFavorite1', 'userId', userId);
            // verify required parameter 'favoriteId' is not null or undefined
            (0, common_1.assertParamExists)('removeUserFavorite1', 'favoriteId', favoriteId);
            const localVarPath = `/users/{userId}/favorites/{favoriteId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"favoriteId"}}`, encodeURIComponent(String(favoriteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.FavoritesApiAxiosParamCreator = FavoritesApiAxiosParamCreator;
/**
 * FavoritesApi - functional programming interface
 * @export
 */
const FavoritesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FavoritesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {number} userId ID of the user
         * @param {boolean} [includeResource] Whether to include the associated resource details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUser(userId, includeResource, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUser(userId, includeResource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FavoritesApi.getByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {number} userId ID of the user
         * @param {Favorite} favorite Favorite to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserFavorite1(userId, favorite, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserFavorite1(userId, favorite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FavoritesApi.postUserFavorite1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {number} userId ID of the user
         * @param {number} favoriteId ID of the favorite to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFavorite1(userId, favoriteId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFavorite1(userId, favoriteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['FavoritesApi.removeUserFavorite1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.FavoritesApiFp = FavoritesApiFp;
/**
 * FavoritesApi - factory interface
 * @export
 */
const FavoritesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FavoritesApiFp)(configuration);
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {FavoritesApiGetByUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser(requestParameters, options) {
            return localVarFp.getByUser(requestParameters.userId, requestParameters.includeResource, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {FavoritesApiPostUserFavorite1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserFavorite1(requestParameters, options) {
            return localVarFp.postUserFavorite1(requestParameters.userId, requestParameters.favorite, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {FavoritesApiRemoveUserFavorite1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFavorite1(requestParameters, options) {
            return localVarFp.removeUserFavorite1(requestParameters.userId, requestParameters.favoriteId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.FavoritesApiFactory = FavoritesApiFactory;
/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
class FavoritesApi extends base_1.BaseAPI {
    /**
     * Retrieves all favorites for a specific user
     * @summary Get user favorites
     * @param {FavoritesApiGetByUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getByUser(requestParameters, options) {
        return (0, exports.FavoritesApiFp)(this.configuration).getByUser(requestParameters.userId, requestParameters.includeResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds a new favorite item for a specific user
     * @summary Add a favorite
     * @param {FavoritesApiPostUserFavorite1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    postUserFavorite1(requestParameters, options) {
        return (0, exports.FavoritesApiFp)(this.configuration).postUserFavorite1(requestParameters.userId, requestParameters.favorite, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes a specific favorite from a user\'s favorites list
     * @summary Remove a favorite
     * @param {FavoritesApiRemoveUserFavorite1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    removeUserFavorite1(requestParameters, options) {
        return (0, exports.FavoritesApiFp)(this.configuration).removeUserFavorite1(requestParameters.userId, requestParameters.favoriteId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.FavoritesApi = FavoritesApi;
/**
 * GeoLocationApi - axios parameter creator
 * @export
 */
const GeoLocationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {string} [latlng] Comma-separated latitude and longitude coordinates
         * @param {string} [address] Text representation of an address to geocode
         * @param {string} [countryCode] ISO country code to restrict the address search
         * @param {string} [autoCompleteText] Text to use for location auto-completion suggestions
         * @param {number} [radius] Search radius in meters for location suggestions (used with latlng and autoCompleteText)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeoLocationsByLatLng1: async (latlng, address, countryCode, autoCompleteText, radius, options = {}) => {
            const localVarPath = `/geo-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (latlng !== undefined) {
                localVarQueryParameter['latlng'] = latlng;
            }
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            if (autoCompleteText !== undefined) {
                localVarQueryParameter['autoCompleteText'] = autoCompleteText;
            }
            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.GeoLocationApiAxiosParamCreator = GeoLocationApiAxiosParamCreator;
/**
 * GeoLocationApi - functional programming interface
 * @export
 */
const GeoLocationApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.GeoLocationApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {string} [latlng] Comma-separated latitude and longitude coordinates
         * @param {string} [address] Text representation of an address to geocode
         * @param {string} [countryCode] ISO country code to restrict the address search
         * @param {string} [autoCompleteText] Text to use for location auto-completion suggestions
         * @param {number} [radius] Search radius in meters for location suggestions (used with latlng and autoCompleteText)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeoLocationsByLatLng1(latlng, address, countryCode, autoCompleteText, radius, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeoLocationsByLatLng1(latlng, address, countryCode, autoCompleteText, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GeoLocationApi.getGeoLocationsByLatLng1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.GeoLocationApiFp = GeoLocationApiFp;
/**
 * GeoLocationApi - factory interface
 * @export
 */
const GeoLocationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.GeoLocationApiFp)(configuration);
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {GeoLocationApiGetGeoLocationsByLatLng1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeoLocationsByLatLng1(requestParameters = {}, options) {
            return localVarFp.getGeoLocationsByLatLng1(requestParameters.latlng, requestParameters.address, requestParameters.countryCode, requestParameters.autoCompleteText, requestParameters.radius, options).then((request) => request(axios, basePath));
        },
    };
};
exports.GeoLocationApiFactory = GeoLocationApiFactory;
/**
 * GeoLocationApi - object-oriented interface
 * @export
 * @class GeoLocationApi
 * @extends {BaseAPI}
 */
class GeoLocationApi extends base_1.BaseAPI {
    /**
     * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
     * @summary Retrieves geolocation information
     * @param {GeoLocationApiGetGeoLocationsByLatLng1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoLocationApi
     */
    getGeoLocationsByLatLng1(requestParameters = {}, options) {
        return (0, exports.GeoLocationApiFp)(this.configuration).getGeoLocationsByLatLng1(requestParameters.latlng, requestParameters.address, requestParameters.countryCode, requestParameters.autoCompleteText, requestParameters.radius, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.GeoLocationApi = GeoLocationApi;
/**
 * GroupsApi - axios parameter creator
 * @export
 */
const GroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveGroup1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('archiveGroup1', 'id', id);
            const localVarPath = `/groups/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateGroup1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deactivateGroup1', 'id', id);
            const localVarPath = `/groups/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteGroup1', 'id', id);
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has archived
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findArchivedGroupsByUser1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/groups/archived`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup1: async (groupId, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('findGroup1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupProperties1: async (groupId, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('findGroupProperties1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/properties`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {PropertyFilterCriteria} [propertyFilterCriteria] filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupPropertiesSearch1: async (groupId, propertyFilterCriteria, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('findGroupPropertiesSearch1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/properties/search`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(propertyFilterCriteria, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return both owned Groups and Groups the user is a member of
         * @summary Return the groups list with specified user id
         * @param {number} [pageFrom] Start page number
         * @param {number} [pageTo] End page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupsByUser1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the groups list with specified user id that are inactive
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInactiveGroupsByUser1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/groups/inactive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has invitations of
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvitedGroupsByUser1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/groups/invited`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has requested
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRequestedGroupsByUser1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/groups/requested`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {string} groupId group id
         * @param {number} [pageFrom] Starting page index (zero-based)
         * @param {number} [pageTo] Ending page index (zero-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers1: async (groupId, pageFrom, pageTo, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('getGroupMembers1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/members`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Request Invitation to Group
         * @param {string} groupId group id
         * @param {Array<number>} [userIds] List of user IDs to invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite: async (groupId, userIds, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('groupInvite', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/invite`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Accept Group Invitation
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite2: async (groupId, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('groupInvite2', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/accept-invite`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Leave Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupLeave1: async (groupId, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('groupLeave1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/leave`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Request Admission to Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRequest1: async (groupId, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('groupRequest1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/request`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {Group} [group] group to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroup1: async (group, options = {}) => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(group, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to update status
         * @param {UpdateGroupMembershipStatus1StatusEnum} [status] New status for the members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMembershipStatus1: async (groupId, userIds, status, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('updateGroupMembershipStatus1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/member-status`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.GroupsApiAxiosParamCreator = GroupsApiAxiosParamCreator;
/**
 * GroupsApi - functional programming interface
 * @export
 */
const GroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.GroupsApiAxiosParamCreator)(configuration);
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveGroup1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveGroup1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.archiveGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateGroup1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateGroup1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.deactivateGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.deleteGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has archived
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findArchivedGroupsByUser1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findArchivedGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.findArchivedGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroup1(groupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroup1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.findGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupProperties1(groupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupProperties1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.findGroupProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {PropertyFilterCriteria} [propertyFilterCriteria] filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupPropertiesSearch1(groupId, propertyFilterCriteria, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupPropertiesSearch1(groupId, propertyFilterCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.findGroupPropertiesSearch1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will return both owned Groups and Groups the user is a member of
         * @summary Return the groups list with specified user id
         * @param {number} [pageFrom] Start page number
         * @param {number} [pageTo] End page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupsByUser1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.findGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the groups list with specified user id that are inactive
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInactiveGroupsByUser1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInactiveGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.findInactiveGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has invitations of
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInvitedGroupsByUser1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInvitedGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.findInvitedGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has requested
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findRequestedGroupsByUser1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findRequestedGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.findRequestedGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {string} groupId group id
         * @param {number} [pageFrom] Starting page index (zero-based)
         * @param {number} [pageTo] Ending page index (zero-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupMembers1(groupId, pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupMembers1(groupId, pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.getGroupMembers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Request Invitation to Group
         * @param {string} groupId group id
         * @param {Array<number>} [userIds] List of user IDs to invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupInvite(groupId, userIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupInvite(groupId, userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.groupInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Accept Group Invitation
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupInvite2(groupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupInvite2(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.groupInvite2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Leave Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupLeave1(groupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupLeave1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.groupLeave1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Request Admission to Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRequest1(groupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupRequest1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.groupRequest1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {Group} [group] group to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveGroup1(group, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveGroup1(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.saveGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to update status
         * @param {UpdateGroupMembershipStatus1StatusEnum} [status] New status for the members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupMembershipStatus1(groupId, userIds, status, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupMembershipStatus1(groupId, userIds, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['GroupsApi.updateGroupMembershipStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.GroupsApiFp = GroupsApiFp;
/**
 * GroupsApi - factory interface
 * @export
 */
const GroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.GroupsApiFp)(configuration);
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {GroupsApiArchiveGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveGroup1(requestParameters, options) {
            return localVarFp.archiveGroup1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {GroupsApiDeactivateGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateGroup1(requestParameters, options) {
            return localVarFp.deactivateGroup1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {GroupsApiDeleteGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup1(requestParameters, options) {
            return localVarFp.deleteGroup1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has archived
         * @param {GroupsApiFindArchivedGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findArchivedGroupsByUser1(requestParameters = {}, options) {
            return localVarFp.findArchivedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {GroupsApiFindGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup1(requestParameters, options) {
            return localVarFp.findGroup1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {GroupsApiFindGroupProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupProperties1(requestParameters, options) {
            return localVarFp.findGroupProperties1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {GroupsApiFindGroupPropertiesSearch1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupPropertiesSearch1(requestParameters, options) {
            return localVarFp.findGroupPropertiesSearch1(requestParameters.groupId, requestParameters.propertyFilterCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return both owned Groups and Groups the user is a member of
         * @summary Return the groups list with specified user id
         * @param {GroupsApiFindGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupsByUser1(requestParameters = {}, options) {
            return localVarFp.findGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the groups list with specified user id that are inactive
         * @param {GroupsApiFindInactiveGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInactiveGroupsByUser1(requestParameters = {}, options) {
            return localVarFp.findInactiveGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has invitations of
         * @param {GroupsApiFindInvitedGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvitedGroupsByUser1(requestParameters = {}, options) {
            return localVarFp.findInvitedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has requested
         * @param {GroupsApiFindRequestedGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRequestedGroupsByUser1(requestParameters = {}, options) {
            return localVarFp.findRequestedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {GroupsApiGetGroupMembers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers1(requestParameters, options) {
            return localVarFp.getGroupMembers1(requestParameters.groupId, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Request Invitation to Group
         * @param {GroupsApiGroupInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite(requestParameters, options) {
            return localVarFp.groupInvite(requestParameters.groupId, requestParameters.userIds, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Accept Group Invitation
         * @param {GroupsApiGroupInvite2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite2(requestParameters, options) {
            return localVarFp.groupInvite2(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Leave Group
         * @param {GroupsApiGroupLeave1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupLeave1(requestParameters, options) {
            return localVarFp.groupLeave1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Request Admission to Group
         * @param {GroupsApiGroupRequest1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRequest1(requestParameters, options) {
            return localVarFp.groupRequest1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {GroupsApiSaveGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroup1(requestParameters = {}, options) {
            return localVarFp.saveGroup1(requestParameters.group, options).then((request) => request(axios, basePath));
        },
        /**
         * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {GroupsApiUpdateGroupMembershipStatus1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMembershipStatus1(requestParameters, options) {
            return localVarFp.updateGroupMembershipStatus1(requestParameters.groupId, requestParameters.userIds, requestParameters.status, options).then((request) => request(axios, basePath));
        },
    };
};
exports.GroupsApiFactory = GroupsApiFactory;
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
class GroupsApi extends base_1.BaseAPI {
    /**
     * This process is reversible
     * @summary Archive the group with id supplied
     * @param {GroupsApiArchiveGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    archiveGroup1(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).archiveGroup1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This process is reversible
     * @summary Deactivate the group with id supplied
     * @param {GroupsApiDeactivateGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deactivateGroup1(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).deactivateGroup1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This process is not reversible
     * @summary Delete the group with id supplied
     * @param {GroupsApiDeleteGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroup1(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).deleteGroup1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the groups list with specified user id that user has archived
     * @param {GroupsApiFindArchivedGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findArchivedGroupsByUser1(requestParameters = {}, options) {
        return (0, exports.GroupsApiFp)(this.configuration).findArchivedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {GroupsApiFindGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findGroup1(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).findGroup1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {GroupsApiFindGroupProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findGroupProperties1(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).findGroupProperties1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {GroupsApiFindGroupPropertiesSearch1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findGroupPropertiesSearch1(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).findGroupPropertiesSearch1(requestParameters.groupId, requestParameters.propertyFilterCriteria, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This will return both owned Groups and Groups the user is a member of
     * @summary Return the groups list with specified user id
     * @param {GroupsApiFindGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findGroupsByUser1(requestParameters = {}, options) {
        return (0, exports.GroupsApiFp)(this.configuration).findGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the groups list with specified user id that are inactive
     * @param {GroupsApiFindInactiveGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findInactiveGroupsByUser1(requestParameters = {}, options) {
        return (0, exports.GroupsApiFp)(this.configuration).findInactiveGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the groups list with specified user id that user has invitations of
     * @param {GroupsApiFindInvitedGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findInvitedGroupsByUser1(requestParameters = {}, options) {
        return (0, exports.GroupsApiFp)(this.configuration).findInvitedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the groups list with specified user id that user has requested
     * @param {GroupsApiFindRequestedGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findRequestedGroupsByUser1(requestParameters = {}, options) {
        return (0, exports.GroupsApiFp)(this.configuration).findRequestedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * For Group Owners, this list will return removed, left, invited and requested members as well
     * @summary Show all members of Group
     * @param {GroupsApiGetGroupMembers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupMembers1(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).getGroupMembers1(requestParameters.groupId, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Request Invitation to Group
     * @param {GroupsApiGroupInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupInvite(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).groupInvite(requestParameters.groupId, requestParameters.userIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Accept Group Invitation
     * @param {GroupsApiGroupInvite2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupInvite2(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).groupInvite2(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Leave Group
     * @param {GroupsApiGroupLeave1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupLeave1(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).groupLeave1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Request Admission to Group
     * @param {GroupsApiGroupRequest1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupRequest1(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).groupRequest1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Consider that only user can saveNew its groups
     * @summary Create or update the group supplied
     * @param {GroupsApiSaveGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    saveGroup1(requestParameters = {}, options) {
        return (0, exports.GroupsApiFp)(this.configuration).saveGroup1(requestParameters.group, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
     * @summary Update the group member status from groupId supplied
     * @param {GroupsApiUpdateGroupMembershipStatus1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupMembershipStatus1(requestParameters, options) {
        return (0, exports.GroupsApiFp)(this.configuration).updateGroupMembershipStatus1(requestParameters.groupId, requestParameters.userIds, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.GroupsApi = GroupsApi;
/**
 * @export
 */
exports.UpdateGroupMembershipStatus1StatusEnum = {
    Accepted: 'ACCEPTED',
    Rejected: 'REJECTED',
    Removed: 'REMOVED'
};
/**
 * LanguagesApi - axios parameter creator
 * @export
 */
const LanguagesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {string} [xForwardedFor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages1: async (xForwardedFor, options = {}) => {
            const localVarPath = `/languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (xForwardedFor != null) {
                localVarHeaderParameter['X-Forwarded-For'] = String(xForwardedFor);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.LanguagesApiAxiosParamCreator = LanguagesApiAxiosParamCreator;
/**
 * LanguagesApi - functional programming interface
 * @export
 */
const LanguagesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LanguagesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {string} [xForwardedFor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllLanguages1(xForwardedFor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllLanguages1(xForwardedFor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['LanguagesApi.getAllLanguages1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.LanguagesApiFp = LanguagesApiFp;
/**
 * LanguagesApi - factory interface
 * @export
 */
const LanguagesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LanguagesApiFp)(configuration);
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {LanguagesApiGetAllLanguages1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages1(requestParameters = {}, options) {
            return localVarFp.getAllLanguages1(requestParameters.xForwardedFor, options).then((request) => request(axios, basePath));
        },
    };
};
exports.LanguagesApiFactory = LanguagesApiFactory;
/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
class LanguagesApi extends base_1.BaseAPI {
    /**
     * Returns a list of all supported languages in the system
     * @summary Get all available languages
     * @param {LanguagesApiGetAllLanguages1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    getAllLanguages1(requestParameters = {}, options) {
        return (0, exports.LanguagesApiFp)(this.configuration).getAllLanguages1(requestParameters.xForwardedFor, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LanguagesApi = LanguagesApi;
/**
 * LocalesApi - axios parameter creator
 * @export
 */
const LocalesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {string} pnemonic
         * @param {string} [securityKey]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (pnemonic, securityKey, options = {}) => {
            // verify required parameter 'pnemonic' is not null or undefined
            (0, common_1.assertParamExists)('delete1', 'pnemonic', pnemonic);
            const localVarPath = `/locales/{pnemonic}`
                .replace(`{${"pnemonic"}}`, encodeURIComponent(String(pnemonic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (securityKey != null) {
                localVarHeaderParameter['security-key'] = String(securityKey);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find3: async (options = {}) => {
            const localVarPath = `/locales`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {string} [lang]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages1: async (lang, options = {}) => {
            const localVarPath = `/locales/translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.LocalesApiAxiosParamCreator = LocalesApiAxiosParamCreator;
/**
 * LocalesApi - functional programming interface
 * @export
 */
const LocalesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.LocalesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {string} pnemonic
         * @param {string} [securityKey]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(pnemonic, securityKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(pnemonic, securityKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['LocalesApi.delete1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find3(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find3(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['LocalesApi.find3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {string} [lang]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLanguages1(lang, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLanguages1(lang, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['LocalesApi.getLanguages1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.LocalesApiFp = LocalesApiFp;
/**
 * LocalesApi - factory interface
 * @export
 */
const LocalesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.LocalesApiFp)(configuration);
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {LocalesApiDelete1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(requestParameters, options) {
            return localVarFp.delete1(requestParameters.pnemonic, requestParameters.securityKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find3(options) {
            return localVarFp.find3(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {LocalesApiGetLanguages1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages1(requestParameters = {}, options) {
            return localVarFp.getLanguages1(requestParameters.lang, options).then((request) => request(axios, basePath));
        },
    };
};
exports.LocalesApiFactory = LocalesApiFactory;
/**
 * LocalesApi - object-oriented interface
 * @export
 * @class LocalesApi
 * @extends {BaseAPI}
 */
class LocalesApi extends base_1.BaseAPI {
    /**
     * Removes a locale entry identified by its pnemonic code along with all its translations
     * @summary Delete a locale entry with all translations related
     * @param {LocalesApiDelete1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    delete1(requestParameters, options) {
        return (0, exports.LocalesApiFp)(this.configuration).delete1(requestParameters.pnemonic, requestParameters.securityKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the complete list of available locales in the system
     * @summary Returns all language list locale entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    find3(options) {
        return (0, exports.LocalesApiFp)(this.configuration).find3(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the locale translations in the specified language
     * @summary Returns locale language list
     * @param {LocalesApiGetLanguages1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    getLanguages1(requestParameters = {}, options) {
        return (0, exports.LocalesApiFp)(this.configuration).getLanguages1(requestParameters.lang, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.LocalesApi = LocalesApi;
/**
 * MessagesApi - axios parameter creator
 * @export
 */
const MessagesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
         * @summary Get user notifications by type
         * @param {string} token Authentication token
         * @param {GetByUserWithResult1TypeEnum} type Notification type
         * @param {AutopilotUser} autopilotUser User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserWithResult1: async (token, type, autopilotUser, options = {}) => {
            // verify required parameter 'token' is not null or undefined
            (0, common_1.assertParamExists)('getByUserWithResult1', 'token', token);
            // verify required parameter 'type' is not null or undefined
            (0, common_1.assertParamExists)('getByUserWithResult1', 'type', type);
            // verify required parameter 'autopilotUser' is not null or undefined
            (0, common_1.assertParamExists)('getByUserWithResult1', 'autopilotUser', autopilotUser);
            const localVarPath = `/notifications/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(autopilotUser, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a message by conversation
         * @param {number} [userAId] User A Id
         * @param {number} [userBId] User B Id
         * @param {number} [limit] limit results
         * @param {LocalDateTimeQueryString} [beforeDatetime] return results before date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation1: async (userAId, userBId, limit, beforeDatetime, options = {}) => {
            const localVarPath = `/chat/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (userAId !== undefined) {
                localVarQueryParameter['userAId'] = userAId;
            }
            if (userBId !== undefined) {
                localVarQueryParameter['userBId'] = userBId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (beforeDatetime !== undefined) {
                for (const [key, value] of Object.entries(beforeDatetime)) {
                    localVarQueryParameter[key] = value;
                }
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a user chat
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUser1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('retrieveChatUser1', 'id', id);
            const localVarPath = `/chat/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a user chat status
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUserStatus1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('retrieveChatUserStatus1', 'id', id);
            const localVarPath = `/chat/user/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post a message
         * @param {Message} [message] message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage1: async (message, options = {}) => {
            const localVarPath = `/chat/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(message, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.MessagesApiAxiosParamCreator = MessagesApiAxiosParamCreator;
/**
 * MessagesApi - functional programming interface
 * @export
 */
const MessagesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.MessagesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
         * @summary Get user notifications by type
         * @param {string} token Authentication token
         * @param {GetByUserWithResult1TypeEnum} type Notification type
         * @param {AutopilotUser} autopilotUser User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUserWithResult1(token, type, autopilotUser, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUserWithResult1(token, type, autopilotUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['MessagesApi.getByUserWithResult1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a message by conversation
         * @param {number} [userAId] User A Id
         * @param {number} [userBId] User B Id
         * @param {number} [limit] limit results
         * @param {LocalDateTimeQueryString} [beforeDatetime] return results before date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversation1(userAId, userBId, limit, beforeDatetime, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversation1(userAId, userBId, limit, beforeDatetime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['MessagesApi.getConversation1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Retrieve a user chat
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveChatUser1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveChatUser1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['MessagesApi.retrieveChatUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Retrieve a user chat status
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveChatUserStatus1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveChatUserStatus1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['MessagesApi.retrieveChatUserStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Post a message
         * @param {Message} [message] message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage1(message, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage1(message, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['MessagesApi.sendMessage1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.MessagesApiFp = MessagesApiFp;
/**
 * MessagesApi - factory interface
 * @export
 */
const MessagesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.MessagesApiFp)(configuration);
    return {
        /**
         * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
         * @summary Get user notifications by type
         * @param {MessagesApiGetByUserWithResult1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserWithResult1(requestParameters, options) {
            return localVarFp.getByUserWithResult1(requestParameters.token, requestParameters.type, requestParameters.autopilotUser, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a message by conversation
         * @param {MessagesApiGetConversation1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation1(requestParameters = {}, options) {
            return localVarFp.getConversation1(requestParameters.userAId, requestParameters.userBId, requestParameters.limit, requestParameters.beforeDatetime, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a user chat
         * @param {MessagesApiRetrieveChatUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUser1(requestParameters, options) {
            return localVarFp.retrieveChatUser1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a user chat status
         * @param {MessagesApiRetrieveChatUserStatus1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUserStatus1(requestParameters, options) {
            return localVarFp.retrieveChatUserStatus1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post a message
         * @param {MessagesApiSendMessage1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage1(requestParameters = {}, options) {
            return localVarFp.sendMessage1(requestParameters.message, options).then((request) => request(axios, basePath));
        },
    };
};
exports.MessagesApiFactory = MessagesApiFactory;
/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
class MessagesApi extends base_1.BaseAPI {
    /**
     * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
     * @summary Get user notifications by type
     * @param {MessagesApiGetByUserWithResult1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    getByUserWithResult1(requestParameters, options) {
        return (0, exports.MessagesApiFp)(this.configuration).getByUserWithResult1(requestParameters.token, requestParameters.type, requestParameters.autopilotUser, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a message by conversation
     * @param {MessagesApiGetConversation1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    getConversation1(requestParameters = {}, options) {
        return (0, exports.MessagesApiFp)(this.configuration).getConversation1(requestParameters.userAId, requestParameters.userBId, requestParameters.limit, requestParameters.beforeDatetime, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a user chat
     * @param {MessagesApiRetrieveChatUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    retrieveChatUser1(requestParameters, options) {
        return (0, exports.MessagesApiFp)(this.configuration).retrieveChatUser1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a user chat status
     * @param {MessagesApiRetrieveChatUserStatus1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    retrieveChatUserStatus1(requestParameters, options) {
        return (0, exports.MessagesApiFp)(this.configuration).retrieveChatUserStatus1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post a message
     * @param {MessagesApiSendMessage1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    sendMessage1(requestParameters = {}, options) {
        return (0, exports.MessagesApiFp)(this.configuration).sendMessage1(requestParameters.message, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.MessagesApi = MessagesApi;
/**
 * @export
 */
exports.GetByUserWithResult1TypeEnum = {
    ToBrokerAlertCreated: 'TO_BROKER__ALERT_CREATED',
    ToUserWeeklyProperties: 'TO_USER__WEEKLY_PROPERTIES',
    ToUserWeeklyPayedSubscribers: 'TO_USER__WEEKLY_PAYED_SUBSCRIBERS',
    ToUserCustomizedAlert: 'TO_USER__CUSTOMIZED_ALERT',
    ToUserWeeklyGroupProperties: 'TO_USER__WEEKLY_GROUP_PROPERTIES',
    ToUserNewsletterNewSubscriber: 'TO_USER__NEWSLETTER_NEW_SUBSCRIBER',
    ToUserNewsletterConfirmation: 'TO_USER__NEWSLETTER_CONFIRMATION',
    ToUserNewsletterListing: 'TO_USER__NEWSLETTER_LISTING'
};
/**
 * PasswordRecoveryApi - axios parameter creator
 * @export
 */
const PasswordRecoveryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {string} [origin]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail1: async (origin, options = {}) => {
            const localVarPath = `/password_recovery/send_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryRequest} [passwordRecoveryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword1: async (passwordRecoveryRequest, options = {}) => {
            const localVarPath = `/password_recovery/update_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(passwordRecoveryRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken1: async (options = {}) => {
            const localVarPath = `/password_recovery/validate_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PasswordRecoveryApiAxiosParamCreator = PasswordRecoveryApiAxiosParamCreator;
/**
 * PasswordRecoveryApi - functional programming interface
 * @export
 */
const PasswordRecoveryApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PasswordRecoveryApiAxiosParamCreator)(configuration);
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {string} [origin]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmail1(origin, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmail1(origin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PasswordRecoveryApi.sendEmail1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryRequest} [passwordRecoveryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePassword1(passwordRecoveryRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword1(passwordRecoveryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PasswordRecoveryApi.updatePassword1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateToken1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateToken1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PasswordRecoveryApi.validateToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PasswordRecoveryApiFp = PasswordRecoveryApiFp;
/**
 * PasswordRecoveryApi - factory interface
 * @export
 */
const PasswordRecoveryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PasswordRecoveryApiFp)(configuration);
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {PasswordRecoveryApiSendEmail1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail1(requestParameters = {}, options) {
            return localVarFp.sendEmail1(requestParameters.origin, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryApiUpdatePassword1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword1(requestParameters = {}, options) {
            return localVarFp.updatePassword1(requestParameters.passwordRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken1(options) {
            return localVarFp.validateToken1(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PasswordRecoveryApiFactory = PasswordRecoveryApiFactory;
/**
 * PasswordRecoveryApi - object-oriented interface
 * @export
 * @class PasswordRecoveryApi
 * @extends {BaseAPI}
 */
class PasswordRecoveryApi extends base_1.BaseAPI {
    /**
     * In this email it will be contained all process information to change password and recover access
     * @summary Send an email to user that has forgotted his/her password
     * @param {PasswordRecoveryApiSendEmail1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    sendEmail1(requestParameters = {}, options) {
        return (0, exports.PasswordRecoveryApiFp)(this.configuration).sendEmail1(requestParameters.origin, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update the password user, finishing the recovery password process
     * @param {PasswordRecoveryApiUpdatePassword1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    updatePassword1(requestParameters = {}, options) {
        return (0, exports.PasswordRecoveryApiFp)(this.configuration).updatePassword1(requestParameters.passwordRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Validate that password recovery token supplied was valid and current
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    validateToken1(options) {
        return (0, exports.PasswordRecoveryApiFp)(this.configuration).validateToken1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PasswordRecoveryApi = PasswordRecoveryApi;
/**
 * PhonePrefixesApi - axios parameter creator
 * @export
 */
const PhonePrefixesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2: async (options = {}) => {
            const localVarPath = `/country-phone-prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PhonePrefixesApiAxiosParamCreator = PhonePrefixesApiAxiosParamCreator;
/**
 * PhonePrefixesApi - functional programming interface
 * @export
 */
const PhonePrefixesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PhonePrefixesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get2(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PhonePrefixesApi.get2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PhonePrefixesApiFp = PhonePrefixesApiFp;
/**
 * PhonePrefixesApi - factory interface
 * @export
 */
const PhonePrefixesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PhonePrefixesApiFp)(configuration);
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2(options) {
            return localVarFp.get2(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PhonePrefixesApiFactory = PhonePrefixesApiFactory;
/**
 * PhonePrefixesApi - object-oriented interface
 * @export
 * @class PhonePrefixesApi
 * @extends {BaseAPI}
 */
class PhonePrefixesApi extends base_1.BaseAPI {
    /**
     * Retrieves a list of all available country phone prefixes with their details
     * @summary Returns all country-phone-prefixes list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhonePrefixesApi
     */
    get2(options) {
        return (0, exports.PhonePrefixesApiFp)(this.configuration).get2(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PhonePrefixesApi = PhonePrefixesApi;
/**
 * PropertiesApi - axios parameter creator
 * @export
 */
const PropertiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Publication state update
         * @param {string} propertyId Property ID
         * @param {string} body Publication state to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus2: async (propertyId, body, options = {}) => {
            // verify required parameter 'propertyId' is not null or undefined
            (0, common_1.assertParamExists)('changePublicationStatus2', 'propertyId', propertyId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('changePublicationStatus2', 'body', body);
            const localVarPath = `/properties/{propertyId}/publication-state`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {string} id Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteProperty1', 'id', id);
            const localVarPath = `/properties/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fetch random list of properties related to a given property
         * @param {string} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties: async (propertyId, options = {}) => {
            // verify required parameter 'propertyId' is not null or undefined
            (0, common_1.assertParamExists)('fetchRandomProperties', 'propertyId', propertyId);
            const localVarPath = `/properties/{propertyId}/related-properties`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties2: async (options = {}) => {
            const localVarPath = `/properties/fetch-random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Search properties with specified filters
         * @param {PropertyFilterCriteria} propertyFilterCriteria Property filter criteria
         * @param {boolean} [bypassCache] Bypass cache and fetch fresh data from database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperties1: async (propertyFilterCriteria, bypassCache, options = {}) => {
            // verify required parameter 'propertyFilterCriteria' is not null or undefined
            (0, common_1.assertParamExists)('findProperties1', 'propertyFilterCriteria', propertyFilterCriteria);
            const localVarPath = `/properties/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (bypassCache !== undefined) {
                localVarQueryParameter['bypassCache'] = bypassCache;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(propertyFilterCriteria, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {string} range location range
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPropertiesByLocationRange1: async (range, options = {}) => {
            // verify required parameter 'range' is not null or undefined
            (0, common_1.assertParamExists)('findPropertiesByLocationRange1', 'range', range);
            const localVarPath = `/properties/by_location_range/{range}`
                .replace(`{${"range"}}`, encodeURIComponent(String(range)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} propertyId Property ID
         * @param {string} [password] Password for protected properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperty1: async (propertyId, password, options = {}) => {
            // verify required parameter 'propertyId' is not null or undefined
            (0, common_1.assertParamExists)('findProperty1', 'propertyId', propertyId);
            const localVarPath = `/properties/{propertyId}`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} id property id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertyOldUrl1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('findPropertyOldUrl1', 'id', id);
            const localVarPath = `/properties/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftsProperties1: async (options = {}) => {
            const localVarPath = `/properties/drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {string} [email] Email to filter properties by user
         * @param {number} [minutes] Minutes to look back (default 60)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProperties1: async (email, minutes, options = {}) => {
            const localVarPath = `/properties/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (minutes !== undefined) {
                localVarQueryParameter['minutes'] = minutes;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuredProperties1: async (options = {}) => {
            const localVarPath = `/properties/password-protected`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {string} id Property ID to generate preview for
         * @param {string} [lang] Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
         * @param {string} [acceptLanguage] Browser\&#39;s accepted language header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty2: async (id, lang, acceptLanguage, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('previewProperty2', 'id', id);
            const localVarPath = `/properties/previews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {Property} property Property to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProperty1: async (property, options = {}) => {
            // verify required parameter 'property' is not null or undefined
            (0, common_1.assertParamExists)('saveProperty1', 'property', property);
            const localVarPath = `/properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(property, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {WeeklyAlertRange} [weeklyAlertRange]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert2: async (weeklyAlertRange, options = {}) => {
            const localVarPath = `/properties/weekly-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(weeklyAlertRange, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGroupAlert1: async (options = {}) => {
            const localVarPath = `/properties/weekly-group-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PropertiesApiAxiosParamCreator = PropertiesApiAxiosParamCreator;
/**
 * PropertiesApi - functional programming interface
 * @export
 */
const PropertiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PropertiesApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Publication state update
         * @param {string} propertyId Property ID
         * @param {string} body Publication state to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePublicationStatus2(propertyId, body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePublicationStatus2(propertyId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.changePublicationStatus2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {string} id Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProperty1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProperty1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.deleteProperty1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Fetch random list of properties related to a given property
         * @param {string} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomProperties(propertyId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomProperties(propertyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.fetchRandomProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomProperties2(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomProperties2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.fetchRandomProperties2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Search properties with specified filters
         * @param {PropertyFilterCriteria} propertyFilterCriteria Property filter criteria
         * @param {boolean} [bypassCache] Bypass cache and fetch fresh data from database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProperties1(propertyFilterCriteria, bypassCache, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProperties1(propertyFilterCriteria, bypassCache, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.findProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {string} range location range
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findPropertiesByLocationRange1(range, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertiesByLocationRange1(range, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.findPropertiesByLocationRange1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} propertyId Property ID
         * @param {string} [password] Password for protected properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProperty1(propertyId, password, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProperty1(propertyId, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.findProperty1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} id property id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPropertyOldUrl1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertyOldUrl1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.findPropertyOldUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDraftsProperties1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDraftsProperties1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.getDraftsProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {string} [email] Email to filter properties by user
         * @param {number} [minutes] Minutes to look back (default 60)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentProperties1(email, minutes, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentProperties1(email, minutes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.getRecentProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecuredProperties1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecuredProperties1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.getSecuredProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {string} id Property ID to generate preview for
         * @param {string} [lang] Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
         * @param {string} [acceptLanguage] Browser\&#39;s accepted language header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewProperty2(id, lang, acceptLanguage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewProperty2(id, lang, acceptLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.previewProperty2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {Property} property Property to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveProperty1(property, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveProperty1(property, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.saveProperty1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {WeeklyAlertRange} [weeklyAlertRange]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendAlert2(weeklyAlertRange, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendAlert2(weeklyAlertRange, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.sendAlert2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendGroupAlert1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendGroupAlert1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertiesApi.sendGroupAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PropertiesApiFp = PropertiesApiFp;
/**
 * PropertiesApi - factory interface
 * @export
 */
const PropertiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PropertiesApiFp)(configuration);
    return {
        /**
         *
         * @summary Publication state update
         * @param {PropertiesApiChangePublicationStatus2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus2(requestParameters, options) {
            return localVarFp.changePublicationStatus2(requestParameters.propertyId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {PropertiesApiDeleteProperty1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty1(requestParameters, options) {
            return localVarFp.deleteProperty1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fetch random list of properties related to a given property
         * @param {PropertiesApiFetchRandomPropertiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties(requestParameters, options) {
            return localVarFp.fetchRandomProperties(requestParameters.propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties2(options) {
            return localVarFp.fetchRandomProperties2(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search properties with specified filters
         * @param {PropertiesApiFindProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperties1(requestParameters, options) {
            return localVarFp.findProperties1(requestParameters.propertyFilterCriteria, requestParameters.bypassCache, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {PropertiesApiFindPropertiesByLocationRange1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPropertiesByLocationRange1(requestParameters, options) {
            return localVarFp.findPropertiesByLocationRange1(requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {PropertiesApiFindProperty1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperty1(requestParameters, options) {
            return localVarFp.findProperty1(requestParameters.propertyId, requestParameters.password, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {PropertiesApiFindPropertyOldUrl1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertyOldUrl1(requestParameters, options) {
            return localVarFp.findPropertyOldUrl1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftsProperties1(options) {
            return localVarFp.getDraftsProperties1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {PropertiesApiGetRecentProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProperties1(requestParameters = {}, options) {
            return localVarFp.getRecentProperties1(requestParameters.email, requestParameters.minutes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuredProperties1(options) {
            return localVarFp.getSecuredProperties1(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {PropertiesApiPreviewProperty2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty2(requestParameters, options) {
            return localVarFp.previewProperty2(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {PropertiesApiSaveProperty1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProperty1(requestParameters, options) {
            return localVarFp.saveProperty1(requestParameters.property, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PropertiesApiSendAlert2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert2(requestParameters = {}, options) {
            return localVarFp.sendAlert2(requestParameters.weeklyAlertRange, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGroupAlert1(options) {
            return localVarFp.sendGroupAlert1(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PropertiesApiFactory = PropertiesApiFactory;
/**
 * PropertiesApi - object-oriented interface
 * @export
 * @class PropertiesApi
 * @extends {BaseAPI}
 */
class PropertiesApi extends base_1.BaseAPI {
    /**
     *
     * @summary Publication state update
     * @param {PropertiesApiChangePublicationStatus2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    changePublicationStatus2(requestParameters, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).changePublicationStatus2(requestParameters.propertyId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This process is not reversible
     * @summary Delete the property with id supplied
     * @param {PropertiesApiDeleteProperty1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    deleteProperty1(requestParameters, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).deleteProperty1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fetch random list of properties related to a given property
     * @param {PropertiesApiFetchRandomPropertiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    fetchRandomProperties(requestParameters, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).fetchRandomProperties(requestParameters.propertyId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a randomized list of properties with the specified count limit
     * @summary Fetch random list of properties, with basic data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    fetchRandomProperties2(options) {
        return (0, exports.PropertiesApiFp)(this.configuration).fetchRandomProperties2(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search properties with specified filters
     * @param {PropertiesApiFindProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    findProperties1(requestParameters, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).findProperties1(requestParameters.propertyFilterCriteria, requestParameters.bypassCache, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the property list with specified user id
     * @param {PropertiesApiFindPropertiesByLocationRange1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    findPropertiesByLocationRange1(requestParameters, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).findPropertiesByLocationRange1(requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter the properties existing in system with specified id. Returns empty if none property match the id
     * @summary Return the property with specified id
     * @param {PropertiesApiFindProperty1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    findProperty1(requestParameters, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).findProperty1(requestParameters.propertyId, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter the properties existing in system with specified id. Returns empty if none property match the id
     * @summary Return the property with specified id
     * @param {PropertiesApiFindPropertyOldUrl1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    findPropertyOldUrl1(requestParameters, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).findPropertyOldUrl1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Password Protected Property for Signed in User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    getDraftsProperties1(options) {
        return (0, exports.PropertiesApiFp)(this.configuration).getDraftsProperties1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get recently created properties within specified minutes (default 60)
     * @param {PropertiesApiGetRecentProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    getRecentProperties1(requestParameters = {}, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).getRecentProperties1(requestParameters.email, requestParameters.minutes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Password Protected Property for Signed in User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    getSecuredProperties1(options) {
        return (0, exports.PropertiesApiFp)(this.configuration).getSecuredProperties1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns HTML preview for sharing a property on social media or messaging apps
     * @summary Get HTML preview for a property
     * @param {PropertiesApiPreviewProperty2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    previewProperty2(requestParameters, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).previewProperty2(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Consider that only user can saveNew its properties
     * @summary Create or update the property supplied
     * @param {PropertiesApiSaveProperty1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    saveProperty1(requestParameters, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).saveProperty1(requestParameters.property, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {PropertiesApiSendAlert2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    sendAlert2(requestParameters = {}, options) {
        return (0, exports.PropertiesApiFp)(this.configuration).sendAlert2(requestParameters.weeklyAlertRange, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    sendGroupAlert1(options) {
        return (0, exports.PropertiesApiFp)(this.configuration).sendGroupAlert1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PropertiesApi = PropertiesApi;
/**
 * PropertyBulkDownloadApi - axios parameter creator
 * @export
 */
const PropertyBulkDownloadApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerKyeroExport1: async (options = {}) => {
            const localVarPath = `/property-bulk-download/trigger-kyero-export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type (e.g., kyero, idealista)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xml1: async (userId, xmlFormat, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('xml1', 'userId', userId);
            // verify required parameter 'xmlFormat' is not null or undefined
            (0, common_1.assertParamExists)('xml1', 'xmlFormat', xmlFormat);
            const localVarPath = `/property-bulk-download/{userId}/{xmlFormat}.xml`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"xmlFormat"}}`, encodeURIComponent(String(xmlFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        xmlRedirect1: async (userId, xmlFormat, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('xmlRedirect1', 'userId', userId);
            // verify required parameter 'xmlFormat' is not null or undefined
            (0, common_1.assertParamExists)('xmlRedirect1', 'xmlFormat', xmlFormat);
            const localVarPath = `/property-bulk-download/{userId}/{xmlFormat}.xml.redirect`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"xmlFormat"}}`, encodeURIComponent(String(xmlFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PropertyBulkDownloadApiAxiosParamCreator = PropertyBulkDownloadApiAxiosParamCreator;
/**
 * PropertyBulkDownloadApi - functional programming interface
 * @export
 */
const PropertyBulkDownloadApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PropertyBulkDownloadApiAxiosParamCreator)(configuration);
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerKyeroExport1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerKyeroExport1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyBulkDownloadApi.triggerKyeroExport1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type (e.g., kyero, idealista)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async xml1(userId, xmlFormat, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.xml1(userId, xmlFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyBulkDownloadApi.xml1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async xmlRedirect1(userId, xmlFormat, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.xmlRedirect1(userId, xmlFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyBulkDownloadApi.xmlRedirect1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PropertyBulkDownloadApiFp = PropertyBulkDownloadApiFp;
/**
 * PropertyBulkDownloadApi - factory interface
 * @export
 */
const PropertyBulkDownloadApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PropertyBulkDownloadApiFp)(configuration);
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerKyeroExport1(options) {
            return localVarFp.triggerKyeroExport1(options).then((request) => request(axios, basePath));
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {PropertyBulkDownloadApiXml1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xml1(requestParameters, options) {
            return localVarFp.xml1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {PropertyBulkDownloadApiXmlRedirect1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        xmlRedirect1(requestParameters, options) {
            return localVarFp.xmlRedirect1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PropertyBulkDownloadApiFactory = PropertyBulkDownloadApiFactory;
/**
 * PropertyBulkDownloadApi - object-oriented interface
 * @export
 * @class PropertyBulkDownloadApi
 * @extends {BaseAPI}
 */
class PropertyBulkDownloadApi extends base_1.BaseAPI {
    /**
     * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
     * @summary Manually trigger Kyero exports to S3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    triggerKyeroExport1(options) {
        return (0, exports.PropertyBulkDownloadApiFp)(this.configuration).triggerKyeroExport1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates and returns property data in XML format for a specific user and format type.
     * @summary Get property XML for specific user
     * @param {PropertyBulkDownloadApiXml1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    xml1(requestParameters, options) {
        return (0, exports.PropertyBulkDownloadApiFp)(this.configuration).xml1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
     * @summary Redirect to XML file (Deprecated)
     * @param {PropertyBulkDownloadApiXmlRedirect1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    xmlRedirect1(requestParameters, options) {
        return (0, exports.PropertyBulkDownloadApiFp)(this.configuration).xmlRedirect1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PropertyBulkDownloadApi = PropertyBulkDownloadApi;
/**
 * PropertyBulkUploadsApi - axios parameter creator
 * @export
 */
const PropertyBulkUploadsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormats1: async (options = {}) => {
            const localVarPath = `/property-bulk-uploads/formats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {string} [body] Properties XML content in Kyero format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties2: async (body, options = {}) => {
            const localVarPath = `/property-bulk-uploads/in-body`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/xml';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroPropertiesFromUrl1: async (xmlUrl, options = {}) => {
            const localVarPath = `/property-bulk-uploads/in-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(xmlUrl, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {UploadProperties1FormatEnum} format Format identifier
         * @param {string} [body] Properties XML content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProperties1: async (format, body, options = {}) => {
            // verify required parameter 'format' is not null or undefined
            (0, common_1.assertParamExists)('uploadProperties1', 'format', format);
            const localVarPath = `/property-bulk-uploads/{format}/in-body`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/xml';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {UploadPropertiesFromUrl1FormatEnum} format Format identifier
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPropertiesFromUrl1: async (format, xmlUrl, options = {}) => {
            // verify required parameter 'format' is not null or undefined
            (0, common_1.assertParamExists)('uploadPropertiesFromUrl1', 'format', format);
            const localVarPath = `/property-bulk-uploads/{format}/in-url`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(xmlUrl, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PropertyBulkUploadsApiAxiosParamCreator = PropertyBulkUploadsApiAxiosParamCreator;
/**
 * PropertyBulkUploadsApi - functional programming interface
 * @export
 */
const PropertyBulkUploadsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PropertyBulkUploadsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormats1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormats1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyBulkUploadsApi.getFormats1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {string} [body] Properties XML content in Kyero format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroProperties2(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroProperties2(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyBulkUploadsApi.uploadKyeroProperties2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroPropertiesFromUrl1(xmlUrl, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroPropertiesFromUrl1(xmlUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyBulkUploadsApi.uploadKyeroPropertiesFromUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {UploadProperties1FormatEnum} format Format identifier
         * @param {string} [body] Properties XML content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProperties1(format, body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProperties1(format, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyBulkUploadsApi.uploadProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {UploadPropertiesFromUrl1FormatEnum} format Format identifier
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPropertiesFromUrl1(format, xmlUrl, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPropertiesFromUrl1(format, xmlUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyBulkUploadsApi.uploadPropertiesFromUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PropertyBulkUploadsApiFp = PropertyBulkUploadsApiFp;
/**
 * PropertyBulkUploadsApi - factory interface
 * @export
 */
const PropertyBulkUploadsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PropertyBulkUploadsApiFp)(configuration);
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormats1(options) {
            return localVarFp.getFormats1(options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {PropertyBulkUploadsApiUploadKyeroProperties2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties2(requestParameters = {}, options) {
            return localVarFp.uploadKyeroProperties2(requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroPropertiesFromUrl1(requestParameters = {}, options) {
            return localVarFp.uploadKyeroPropertiesFromUrl1(requestParameters.xmlUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {PropertyBulkUploadsApiUploadProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProperties1(requestParameters, options) {
            return localVarFp.uploadProperties1(requestParameters.format, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {PropertyBulkUploadsApiUploadPropertiesFromUrl1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPropertiesFromUrl1(requestParameters, options) {
            return localVarFp.uploadPropertiesFromUrl1(requestParameters.format, requestParameters.xmlUrl, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PropertyBulkUploadsApiFactory = PropertyBulkUploadsApiFactory;
/**
 * PropertyBulkUploadsApi - object-oriented interface
 * @export
 * @class PropertyBulkUploadsApi
 * @extends {BaseAPI}
 */
class PropertyBulkUploadsApi extends base_1.BaseAPI {
    /**
     * Get the list of supported file formats for bulk upload
     * @summary Get available formats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    getFormats1(options) {
        return (0, exports.PropertyBulkUploadsApiFp)(this.configuration).getFormats1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload properties using Kyero format with XML content in the request body
     * @summary Upload Kyero properties with XML in request body
     * @param {PropertyBulkUploadsApiUploadKyeroProperties2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    uploadKyeroProperties2(requestParameters = {}, options) {
        return (0, exports.PropertyBulkUploadsApiFp)(this.configuration).uploadKyeroProperties2(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload properties in Kyero format by providing a URL to an XML file
     * @summary Upload Kyero properties from URL
     * @param {PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    uploadKyeroPropertiesFromUrl1(requestParameters = {}, options) {
        return (0, exports.PropertyBulkUploadsApiFp)(this.configuration).uploadKyeroPropertiesFromUrl1(requestParameters.xmlUrl, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload properties with XML content in the request body using the specified format
     * @summary Upload properties in specified format with XML in request body
     * @param {PropertyBulkUploadsApiUploadProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    uploadProperties1(requestParameters, options) {
        return (0, exports.PropertyBulkUploadsApiFp)(this.configuration).uploadProperties1(requestParameters.format, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload properties in the specified format by providing a URL to an XML file
     * @summary Upload properties in specified format from URL
     * @param {PropertyBulkUploadsApiUploadPropertiesFromUrl1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    uploadPropertiesFromUrl1(requestParameters, options) {
        return (0, exports.PropertyBulkUploadsApiFp)(this.configuration).uploadPropertiesFromUrl1(requestParameters.format, requestParameters.xmlUrl, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PropertyBulkUploadsApi = PropertyBulkUploadsApi;
/**
 * @export
 */
exports.UploadProperties1FormatEnum = {
    Kyero: 'kyero',
    Wasico: 'wasico',
    Xml2u: 'xml2u',
    Hallocasa: 'hallocasa'
};
/**
 * @export
 */
exports.UploadPropertiesFromUrl1FormatEnum = {
    Kyero: 'kyero',
    Wasico: 'wasico',
    Xml2u: 'xml2u',
    Hallocasa: 'hallocasa'
};
/**
 * PropertyFieldApi - axios parameter creator
 * @export
 */
const PropertyFieldApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
         * @summary Retrieves property fields filtered by key
         * @param {PropertyKey} [propertyKey] key set of the property to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters2: async (propertyKey, options = {}) => {
            const localVarPath = `/property-fields/filter-by-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(propertyKey, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PropertyFieldApiAxiosParamCreator = PropertyFieldApiAxiosParamCreator;
/**
 * PropertyFieldApi - functional programming interface
 * @export
 */
const PropertyFieldApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PropertyFieldApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
         * @summary Retrieves property fields filtered by key
         * @param {PropertyKey} [propertyKey] key set of the property to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFilters2(propertyKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFilters2(propertyKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyFieldApi.getPropertyFilters2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PropertyFieldApiFp = PropertyFieldApiFp;
/**
 * PropertyFieldApi - factory interface
 * @export
 */
const PropertyFieldApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PropertyFieldApiFp)(configuration);
    return {
        /**
         * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
         * @summary Retrieves property fields filtered by key
         * @param {PropertyFieldApiGetPropertyFilters2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters2(requestParameters = {}, options) {
            return localVarFp.getPropertyFilters2(requestParameters.propertyKey, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PropertyFieldApiFactory = PropertyFieldApiFactory;
/**
 * PropertyFieldApi - object-oriented interface
 * @export
 * @class PropertyFieldApi
 * @extends {BaseAPI}
 */
class PropertyFieldApi extends base_1.BaseAPI {
    /**
     * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
     * @summary Retrieves property fields filtered by key
     * @param {PropertyFieldApiGetPropertyFilters2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFieldApi
     */
    getPropertyFilters2(requestParameters = {}, options) {
        return (0, exports.PropertyFieldApiFp)(this.configuration).getPropertyFilters2(requestParameters.propertyKey, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PropertyFieldApi = PropertyFieldApi;
/**
 * PropertyFiltersApi - axios parameter creator
 * @export
 */
const PropertyFiltersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {number} filterId ID of the filter to get options for
         * @param {Array<PropertyFilterSubmission>} propertyFilterSubmission List of property filter submissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFieldOptions1: async (filterId, propertyFilterSubmission, options = {}) => {
            // verify required parameter 'filterId' is not null or undefined
            (0, common_1.assertParamExists)('getPropertyFieldOptions1', 'filterId', filterId);
            // verify required parameter 'propertyFilterSubmission' is not null or undefined
            (0, common_1.assertParamExists)('getPropertyFieldOptions1', 'propertyFilterSubmission', propertyFilterSubmission);
            const localVarPath = `/property_filters/options/{filter_id}`
                .replace(`{${"filter_id"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(propertyFilterSubmission, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {Array<number>} [filterNatureId] Filter nature IDs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters: async (filterNatureId, options = {}) => {
            const localVarPath = `/property_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (filterNatureId) {
                localVarQueryParameter['filter_nature_id'] = filterNatureId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PropertyFiltersApiAxiosParamCreator = PropertyFiltersApiAxiosParamCreator;
/**
 * PropertyFiltersApi - functional programming interface
 * @export
 */
const PropertyFiltersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PropertyFiltersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {number} filterId ID of the filter to get options for
         * @param {Array<PropertyFilterSubmission>} propertyFilterSubmission List of property filter submissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFieldOptions1(filterId, propertyFilterSubmission, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFieldOptions1(filterId, propertyFilterSubmission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyFiltersApi.getPropertyFieldOptions1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {Array<number>} [filterNatureId] Filter nature IDs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFilters(filterNatureId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFilters(filterNatureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyFiltersApi.getPropertyFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PropertyFiltersApiFp = PropertyFiltersApiFp;
/**
 * PropertyFiltersApi - factory interface
 * @export
 */
const PropertyFiltersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PropertyFiltersApiFp)(configuration);
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {PropertyFiltersApiGetPropertyFieldOptions1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFieldOptions1(requestParameters, options) {
            return localVarFp.getPropertyFieldOptions1(requestParameters.filterId, requestParameters.propertyFilterSubmission, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {PropertyFiltersApiGetPropertyFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters(requestParameters = {}, options) {
            return localVarFp.getPropertyFilters(requestParameters.filterNatureId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PropertyFiltersApiFactory = PropertyFiltersApiFactory;
/**
 * PropertyFiltersApi - object-oriented interface
 * @export
 * @class PropertyFiltersApi
 * @extends {BaseAPI}
 */
class PropertyFiltersApi extends base_1.BaseAPI {
    /**
     * Retrieves options for a specific property filter based on submitted filters
     * @summary Get property field options
     * @param {PropertyFiltersApiGetPropertyFieldOptions1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFiltersApi
     */
    getPropertyFieldOptions1(requestParameters, options) {
        return (0, exports.PropertyFiltersApiFp)(this.configuration).getPropertyFieldOptions1(requestParameters.filterId, requestParameters.propertyFilterSubmission, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of property filters, optionally filtered by filter nature IDs
     * @summary Get property filters
     * @param {PropertyFiltersApiGetPropertyFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFiltersApi
     */
    getPropertyFilters(requestParameters = {}, options) {
        return (0, exports.PropertyFiltersApiFp)(this.configuration).getPropertyFilters(requestParameters.filterNatureId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PropertyFiltersApi = PropertyFiltersApi;
/**
 * PropertyLocationsApi - axios parameter creator
 * @export
 */
const PropertyLocationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries: async (options = {}) => {
            const localVarPath = `/property-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PropertyLocationsApiAxiosParamCreator = PropertyLocationsApiAxiosParamCreator;
/**
 * PropertyLocationsApi - functional programming interface
 * @export
 */
const PropertyLocationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PropertyLocationsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCountries(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCountries(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyLocationsApi.getAllCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PropertyLocationsApiFp = PropertyLocationsApiFp;
/**
 * PropertyLocationsApi - factory interface
 * @export
 */
const PropertyLocationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PropertyLocationsApiFp)(configuration);
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries(options) {
            return localVarFp.getAllCountries(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PropertyLocationsApiFactory = PropertyLocationsApiFactory;
/**
 * PropertyLocationsApi - object-oriented interface
 * @export
 * @class PropertyLocationsApi
 * @extends {BaseAPI}
 */
class PropertyLocationsApi extends base_1.BaseAPI {
    /**
     * Retrieves a list of all available property locations
     * @summary Method to find all the property locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyLocationsApi
     */
    getAllCountries(options) {
        return (0, exports.PropertyLocationsApiFp)(this.configuration).getAllCountries(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PropertyLocationsApi = PropertyLocationsApi;
/**
 * PropertyProposalsApi - axios parameter creator
 * @export
 */
const PropertyProposalsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyProposals1: async (options = {}) => {
            const localVarPath = `/property-proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PropertyProposalsApiAxiosParamCreator = PropertyProposalsApiAxiosParamCreator;
/**
 * PropertyProposalsApi - functional programming interface
 * @export
 */
const PropertyProposalsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PropertyProposalsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPropertyProposals1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPropertyProposals1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyProposalsApi.getAllPropertyProposals1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PropertyProposalsApiFp = PropertyProposalsApiFp;
/**
 * PropertyProposalsApi - factory interface
 * @export
 */
const PropertyProposalsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PropertyProposalsApiFp)(configuration);
    return {
        /**
         *
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyProposals1(options) {
            return localVarFp.getAllPropertyProposals1(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PropertyProposalsApiFactory = PropertyProposalsApiFactory;
/**
 * PropertyProposalsApi - object-oriented interface
 * @export
 * @class PropertyProposalsApi
 * @extends {BaseAPI}
 */
class PropertyProposalsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Method to find all the property proposals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyProposalsApi
     */
    getAllPropertyProposals1(options) {
        return (0, exports.PropertyProposalsApiFp)(this.configuration).getAllPropertyProposals1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PropertyProposalsApi = PropertyProposalsApi;
/**
 * PropertyTypesApi - axios parameter creator
 * @export
 */
const PropertyTypesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyTypes1: async (options = {}) => {
            const localVarPath = `/property-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.PropertyTypesApiAxiosParamCreator = PropertyTypesApiAxiosParamCreator;
/**
 * PropertyTypesApi - functional programming interface
 * @export
 */
const PropertyTypesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PropertyTypesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPropertyTypes1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPropertyTypes1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['PropertyTypesApi.getAllPropertyTypes1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.PropertyTypesApiFp = PropertyTypesApiFp;
/**
 * PropertyTypesApi - factory interface
 * @export
 */
const PropertyTypesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PropertyTypesApiFp)(configuration);
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyTypes1(options) {
            return localVarFp.getAllPropertyTypes1(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PropertyTypesApiFactory = PropertyTypesApiFactory;
/**
 * PropertyTypesApi - object-oriented interface
 * @export
 * @class PropertyTypesApi
 * @extends {BaseAPI}
 */
class PropertyTypesApi extends base_1.BaseAPI {
    /**
     * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
     * @summary Get all property types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypesApi
     */
    getAllPropertyTypes1(options) {
        return (0, exports.PropertyTypesApiFp)(this.configuration).getAllPropertyTypes1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PropertyTypesApi = PropertyTypesApi;
/**
 * SecurityApi - axios parameter creator
 * @export
 */
const SecurityApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize1: async (options = {}) => {
            const localVarPath = `/security/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {string} clientId Client application identifier
         * @param {string} code Authorization code received from /auth endpoint
         * @param {string} email User email address
         * @param {string} password User password
         * @param {string} [grantType] OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken1: async (clientId, code, email, password, grantType, clientSecret, options = {}) => {
            // verify required parameter 'clientId' is not null or undefined
            (0, common_1.assertParamExists)('requestToken1', 'clientId', clientId);
            // verify required parameter 'code' is not null or undefined
            (0, common_1.assertParamExists)('requestToken1', 'code', code);
            // verify required parameter 'email' is not null or undefined
            (0, common_1.assertParamExists)('requestToken1', 'email', email);
            // verify required parameter 'password' is not null or undefined
            (0, common_1.assertParamExists)('requestToken1', 'password', password);
            const localVarPath = `/security/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            if (clientId !== undefined) {
                localVarFormParams.set('client-id', clientId);
            }
            if (code !== undefined) {
                localVarFormParams.set('code', code);
            }
            if (email !== undefined) {
                localVarFormParams.set('email', email);
            }
            if (password !== undefined) {
                localVarFormParams.set('password', password);
            }
            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType);
            }
            if (clientSecret !== undefined) {
                localVarFormParams.set('client_secret', clientSecret);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SecurityApiAxiosParamCreator = SecurityApiAxiosParamCreator;
/**
 * SecurityApi - functional programming interface
 * @export
 */
const SecurityApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SecurityApiAxiosParamCreator)(configuration);
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SecurityApi.authorize1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {string} clientId Client application identifier
         * @param {string} code Authorization code received from /auth endpoint
         * @param {string} email User email address
         * @param {string} password User password
         * @param {string} [grantType] OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestToken1(clientId, code, email, password, grantType, clientSecret, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestToken1(clientId, code, email, password, grantType, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SecurityApi.requestToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.SecurityApiFp = SecurityApiFp;
/**
 * SecurityApi - factory interface
 * @export
 */
const SecurityApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SecurityApiFp)(configuration);
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize1(options) {
            return localVarFp.authorize1(options).then((request) => request(axios, basePath));
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {SecurityApiRequestToken1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken1(requestParameters, options) {
            return localVarFp.requestToken1(requestParameters.clientId, requestParameters.code, requestParameters.email, requestParameters.password, requestParameters.grantType, requestParameters.clientSecret, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SecurityApiFactory = SecurityApiFactory;
/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
class SecurityApi extends base_1.BaseAPI {
    /**
     * Generates an authorization code to be used with the token endpoint
     * @summary Authorize client application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    authorize1(options) {
        return (0, exports.SecurityApiFp)(this.configuration).authorize1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
     * @summary Exchange authorization code for access token
     * @param {SecurityApiRequestToken1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    requestToken1(requestParameters, options) {
        return (0, exports.SecurityApiFp)(this.configuration).requestToken1(requestParameters.clientId, requestParameters.code, requestParameters.email, requestParameters.password, requestParameters.grantType, requestParameters.clientSecret, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SecurityApi = SecurityApi;
/**
 * SkillsApi - axios parameter creator
 * @export
 */
const SkillsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills2: async (options = {}) => {
            const localVarPath = `/skills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SkillsApiAxiosParamCreator = SkillsApiAxiosParamCreator;
/**
 * SkillsApi - functional programming interface
 * @export
 */
const SkillsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SkillsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSkills2(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSkills2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SkillsApi.retrieveUserSkills2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.SkillsApiFp = SkillsApiFp;
/**
 * SkillsApi - factory interface
 * @export
 */
const SkillsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SkillsApiFp)(configuration);
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills2(options) {
            return localVarFp.retrieveUserSkills2(options).then((request) => request(axios, basePath));
        },
    };
};
exports.SkillsApiFactory = SkillsApiFactory;
/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
class SkillsApi extends base_1.BaseAPI {
    /**
     * Returns a list of all available user skills in the system
     * @summary Retrieve all user skills
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    retrieveUserSkills2(options) {
        return (0, exports.SkillsApiFp)(this.configuration).retrieveUserSkills2(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SkillsApi = SkillsApi;
/**
 * StripeWebhooksApi - axios parameter creator
 * @export
 */
const StripeWebhooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Notify user subscription change
         * @param {StripeEvent} [stripeEvent]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSubscriptionChange1: async (stripeEvent, options = {}) => {
            const localVarPath = `/stripe-webhooks/user-subscription-update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(stripeEvent, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.StripeWebhooksApiAxiosParamCreator = StripeWebhooksApiAxiosParamCreator;
/**
 * StripeWebhooksApi - functional programming interface
 * @export
 */
const StripeWebhooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.StripeWebhooksApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Notify user subscription change
         * @param {StripeEvent} [stripeEvent]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserSubscriptionChange1(stripeEvent, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserSubscriptionChange1(stripeEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['StripeWebhooksApi.postUserSubscriptionChange1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.StripeWebhooksApiFp = StripeWebhooksApiFp;
/**
 * StripeWebhooksApi - factory interface
 * @export
 */
const StripeWebhooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.StripeWebhooksApiFp)(configuration);
    return {
        /**
         *
         * @summary Notify user subscription change
         * @param {StripeWebhooksApiPostUserSubscriptionChange1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSubscriptionChange1(requestParameters = {}, options) {
            return localVarFp.postUserSubscriptionChange1(requestParameters.stripeEvent, options).then((request) => request(axios, basePath));
        },
    };
};
exports.StripeWebhooksApiFactory = StripeWebhooksApiFactory;
/**
 * StripeWebhooksApi - object-oriented interface
 * @export
 * @class StripeWebhooksApi
 * @extends {BaseAPI}
 */
class StripeWebhooksApi extends base_1.BaseAPI {
    /**
     *
     * @summary Notify user subscription change
     * @param {StripeWebhooksApiPostUserSubscriptionChange1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeWebhooksApi
     */
    postUserSubscriptionChange1(requestParameters = {}, options) {
        return (0, exports.StripeWebhooksApiFp)(this.configuration).postUserSubscriptionChange1(requestParameters.stripeEvent, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.StripeWebhooksApi = StripeWebhooksApi;
/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
const SubscriptionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('get', 'userId', userId);
            const localVarPath = `/users/{userId}/subscriptions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveFeatures1: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getActiveFeatures1', 'userId', userId);
            const localVarPath = `/users/{userId}/subscriptions/active/features`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the active and available subscription plans
         * @param {Array<string>} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll1: async (expand, options = {}) => {
            const localVarPath = `/subscription-plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.SubscriptionsApiAxiosParamCreator = SubscriptionsApiAxiosParamCreator;
/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
const SubscriptionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SubscriptionsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SubscriptionsApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveFeatures1(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveFeatures1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SubscriptionsApi.getActiveFeatures1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the active and available subscription plans
         * @param {Array<string>} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll1(expand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll1(expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['SubscriptionsApi.getAll1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.SubscriptionsApiFp = SubscriptionsApiFp;
/**
 * SubscriptionsApi - factory interface
 * @export
 */
const SubscriptionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SubscriptionsApiFp)(configuration);
    return {
        /**
         *
         * @param {SubscriptionsApiGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(requestParameters, options) {
            return localVarFp.get(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SubscriptionsApiGetActiveFeatures1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveFeatures1(requestParameters, options) {
            return localVarFp.getActiveFeatures1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the active and available subscription plans
         * @param {SubscriptionsApiGetAll1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll1(requestParameters = {}, options) {
            return localVarFp.getAll1(requestParameters.expand, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SubscriptionsApiFactory = SubscriptionsApiFactory;
/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
class SubscriptionsApi extends base_1.BaseAPI {
    /**
     *
     * @param {SubscriptionsApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    get(requestParameters, options) {
        return (0, exports.SubscriptionsApiFp)(this.configuration).get(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SubscriptionsApiGetActiveFeatures1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    getActiveFeatures1(requestParameters, options) {
        return (0, exports.SubscriptionsApiFp)(this.configuration).getActiveFeatures1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the active and available subscription plans
     * @param {SubscriptionsApiGetAll1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    getAll1(requestParameters = {}, options) {
        return (0, exports.SubscriptionsApiFp)(this.configuration).getAll1(requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SubscriptionsApi = SubscriptionsApi;
/**
 * TestimonialApi - axios parameter creator
 * @export
 */
const TestimonialApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Publication state update
         * @param {string} testimonialId Testimonial Id
         * @param {boolean} publicationState Publication State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus: async (testimonialId, publicationState, options = {}) => {
            // verify required parameter 'testimonialId' is not null or undefined
            (0, common_1.assertParamExists)('changePublicationStatus', 'testimonialId', testimonialId);
            // verify required parameter 'publicationState' is not null or undefined
            (0, common_1.assertParamExists)('changePublicationStatus', 'publicationState', publicationState);
            const localVarPath = `/testimonial/{testimonialId}/publication-state/{publicationState}`
                .replace(`{${"testimonialId"}}`, encodeURIComponent(String(testimonialId)))
                .replace(`{${"publicationState"}}`, encodeURIComponent(String(publicationState)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fetch User Posted list of testimonials
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPublishedTestimonials1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/testimonial/published`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fetch User Received list of testimonials
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchReceivedTestimonials1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/testimonial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {string} testimonialId testimonial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonial1: async (testimonialId, options = {}) => {
            // verify required parameter 'testimonialId' is not null or undefined
            (0, common_1.assertParamExists)('findTestimonial1', 'testimonialId', testimonialId);
            const localVarPath = `/testimonial/{testimonialId}`
                .replace(`{${"testimonialId"}}`, encodeURIComponent(String(testimonialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequests1: async (options = {}) => {
            const localVarPath = `/testimonial/requested`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequestsReceived1: async (options = {}) => {
            const localVarPath = `/testimonial/request-received`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {Testimonial} testimonial Testimonial to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTestimonial1: async (testimonial, options = {}) => {
            // verify required parameter 'testimonial' is not null or undefined
            (0, common_1.assertParamExists)('saveTestimonial1', 'testimonial', testimonial);
            const localVarPath = `/testimonial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(testimonial, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TestimonialApiAxiosParamCreator = TestimonialApiAxiosParamCreator;
/**
 * TestimonialApi - functional programming interface
 * @export
 */
const TestimonialApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TestimonialApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Publication state update
         * @param {string} testimonialId Testimonial Id
         * @param {boolean} publicationState Publication State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePublicationStatus(testimonialId, publicationState, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePublicationStatus(testimonialId, publicationState, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TestimonialApi.changePublicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Fetch User Posted list of testimonials
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchPublishedTestimonials1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchPublishedTestimonials1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TestimonialApi.fetchPublishedTestimonials1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Fetch User Received list of testimonials
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchReceivedTestimonials1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchReceivedTestimonials1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TestimonialApi.fetchReceivedTestimonials1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {string} testimonialId testimonial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonial1(testimonialId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonial1(testimonialId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TestimonialApi.findTestimonial1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialRequests1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialRequests1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TestimonialApi.findTestimonialRequests1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialRequestsReceived1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialRequestsReceived1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TestimonialApi.findTestimonialRequestsReceived1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {Testimonial} testimonial Testimonial to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTestimonial1(testimonial, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTestimonial1(testimonial, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TestimonialApi.saveTestimonial1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.TestimonialApiFp = TestimonialApiFp;
/**
 * TestimonialApi - factory interface
 * @export
 */
const TestimonialApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TestimonialApiFp)(configuration);
    return {
        /**
         *
         * @summary Publication state update
         * @param {TestimonialApiChangePublicationStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus(requestParameters, options) {
            return localVarFp.changePublicationStatus(requestParameters.testimonialId, requestParameters.publicationState, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fetch User Posted list of testimonials
         * @param {TestimonialApiFetchPublishedTestimonials1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPublishedTestimonials1(requestParameters = {}, options) {
            return localVarFp.fetchPublishedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fetch User Received list of testimonials
         * @param {TestimonialApiFetchReceivedTestimonials1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchReceivedTestimonials1(requestParameters = {}, options) {
            return localVarFp.fetchReceivedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {TestimonialApiFindTestimonial1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonial1(requestParameters, options) {
            return localVarFp.findTestimonial1(requestParameters.testimonialId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequests1(options) {
            return localVarFp.findTestimonialRequests1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequestsReceived1(options) {
            return localVarFp.findTestimonialRequestsReceived1(options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {TestimonialApiSaveTestimonial1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTestimonial1(requestParameters, options) {
            return localVarFp.saveTestimonial1(requestParameters.testimonial, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TestimonialApiFactory = TestimonialApiFactory;
/**
 * TestimonialApi - object-oriented interface
 * @export
 * @class TestimonialApi
 * @extends {BaseAPI}
 */
class TestimonialApi extends base_1.BaseAPI {
    /**
     *
     * @summary Publication state update
     * @param {TestimonialApiChangePublicationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    changePublicationStatus(requestParameters, options) {
        return (0, exports.TestimonialApiFp)(this.configuration).changePublicationStatus(requestParameters.testimonialId, requestParameters.publicationState, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fetch User Posted list of testimonials
     * @param {TestimonialApiFetchPublishedTestimonials1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    fetchPublishedTestimonials1(requestParameters = {}, options) {
        return (0, exports.TestimonialApiFp)(this.configuration).fetchPublishedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fetch User Received list of testimonials
     * @param {TestimonialApiFetchReceivedTestimonials1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    fetchReceivedTestimonials1(requestParameters = {}, options) {
        return (0, exports.TestimonialApiFp)(this.configuration).fetchReceivedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the testimonial with specified id, it needs to be published
     * @param {TestimonialApiFindTestimonial1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    findTestimonial1(requestParameters, options) {
        return (0, exports.TestimonialApiFp)(this.configuration).findTestimonial1(requestParameters.testimonialId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the testimonial Requests a user Created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    findTestimonialRequests1(options) {
        return (0, exports.TestimonialApiFp)(this.configuration).findTestimonialRequests1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the testimonial Requests a user Received
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    findTestimonialRequestsReceived1(options) {
        return (0, exports.TestimonialApiFp)(this.configuration).findTestimonialRequestsReceived1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Consider that only user can save new testimonials
     * @summary Create or update the Testimonial supplied
     * @param {TestimonialApiSaveTestimonial1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    saveTestimonial1(requestParameters, options) {
        return (0, exports.TestimonialApiFp)(this.configuration).saveTestimonial1(requestParameters.testimonial, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TestimonialApi = TestimonialApi;
/**
 * TextTranslationsApi - axios parameter creator
 * @export
 */
const TextTranslationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {string} [targetLang]
         * @param {string} [text]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateText1: async (targetLang, text, options = {}) => {
            const localVarPath = `/text-translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (targetLang !== undefined) {
                localVarQueryParameter['targetLang'] = targetLang;
            }
            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.TextTranslationsApiAxiosParamCreator = TextTranslationsApiAxiosParamCreator;
/**
 * TextTranslationsApi - functional programming interface
 * @export
 */
const TextTranslationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TextTranslationsApiAxiosParamCreator)(configuration);
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {string} [targetLang]
         * @param {string} [text]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translateText1(targetLang, text, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translateText1(targetLang, text, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['TextTranslationsApi.translateText1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.TextTranslationsApiFp = TextTranslationsApiFp;
/**
 * TextTranslationsApi - factory interface
 * @export
 */
const TextTranslationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TextTranslationsApiFp)(configuration);
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {TextTranslationsApiTranslateText1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateText1(requestParameters = {}, options) {
            return localVarFp.translateText1(requestParameters.targetLang, requestParameters.text, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TextTranslationsApiFactory = TextTranslationsApiFactory;
/**
 * TextTranslationsApi - object-oriented interface
 * @export
 * @class TextTranslationsApi
 * @extends {BaseAPI}
 */
class TextTranslationsApi extends base_1.BaseAPI {
    /**
     * Translate the provided text to the specified target language
     * @summary Get text translation to a target language
     * @param {TextTranslationsApiTranslateText1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTranslationsApi
     */
    translateText1(requestParameters = {}, options) {
        return (0, exports.TextTranslationsApiFp)(this.configuration).translateText1(requestParameters.targetLang, requestParameters.text, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TextTranslationsApi = TextTranslationsApi;
/**
 * UserConnectionsApi - axios parameter creator
 * @export
 */
const UserConnectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get a user connections
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections2: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('findUserConnections2', 'userId', userId);
            const localVarPath = `/chat/users/{userId}/connections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UserConnectionsApiAxiosParamCreator = UserConnectionsApiAxiosParamCreator;
/**
 * UserConnectionsApi - functional programming interface
 * @export
 */
const UserConnectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserConnectionsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get a user connections
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserConnections2(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserConnections2(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UserConnectionsApi.findUserConnections2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.UserConnectionsApiFp = UserConnectionsApiFp;
/**
 * UserConnectionsApi - factory interface
 * @export
 */
const UserConnectionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserConnectionsApiFp)(configuration);
    return {
        /**
         *
         * @summary Get a user connections
         * @param {UserConnectionsApiFindUserConnections2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections2(requestParameters, options) {
            return localVarFp.findUserConnections2(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserConnectionsApiFactory = UserConnectionsApiFactory;
/**
 * UserConnectionsApi - object-oriented interface
 * @export
 * @class UserConnectionsApi
 * @extends {BaseAPI}
 */
class UserConnectionsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get a user connections
     * @param {UserConnectionsApiFindUserConnections2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionsApi
     */
    findUserConnections2(requestParameters, options) {
        return (0, exports.UserConnectionsApiFp)(this.configuration).findUserConnections2(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserConnectionsApi = UserConnectionsApi;
/**
 * UserContractsApi - axios parameter creator
 * @export
 */
const UserContractsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get a user Contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserContracts1: async (options = {}) => {
            const localVarPath = `/contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Save a user Contract
         * @param {Contract} contract Contract to save
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save2: async (contract, options = {}) => {
            // verify required parameter 'contract' is not null or undefined
            (0, common_1.assertParamExists)('save2', 'contract', contract);
            const localVarPath = `/contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(contract, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UserContractsApiAxiosParamCreator = UserContractsApiAxiosParamCreator;
/**
 * UserContractsApi - functional programming interface
 * @export
 */
const UserContractsApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserContractsApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get a user Contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserContracts1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserContracts1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UserContractsApi.findUserContracts1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Save a user Contract
         * @param {Contract} contract Contract to save
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save2(contract, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save2(contract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UserContractsApi.save2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.UserContractsApiFp = UserContractsApiFp;
/**
 * UserContractsApi - factory interface
 * @export
 */
const UserContractsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserContractsApiFp)(configuration);
    return {
        /**
         *
         * @summary Get a user Contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserContracts1(options) {
            return localVarFp.findUserContracts1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Save a user Contract
         * @param {UserContractsApiSave2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save2(requestParameters, options) {
            return localVarFp.save2(requestParameters.contract, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserContractsApiFactory = UserContractsApiFactory;
/**
 * UserContractsApi - object-oriented interface
 * @export
 * @class UserContractsApi
 * @extends {BaseAPI}
 */
class UserContractsApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get a user Contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserContractsApi
     */
    findUserContracts1(options) {
        return (0, exports.UserContractsApiFp)(this.configuration).findUserContracts1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Save a user Contract
     * @param {UserContractsApiSave2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserContractsApi
     */
    save2(requestParameters, options) {
        return (0, exports.UserContractsApiFp)(this.configuration).save2(requestParameters.contract, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserContractsApi = UserContractsApi;
/**
 * UserSummaryApi - axios parameter creator
 * @export
 */
const UserSummaryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves summaries of all chat conversations for a user
         * @summary Get the user chat summaries
         * @param {number} userId User ID to fetch chat summaries for
         * @param {number} [limit] Limit the number of chat summaries returned
         * @param {LocalDateTimeQueryString} [beforeDatetime] Only return chat summaries before this datetime (UTC timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatSummaryByUser1: async (userId, limit, beforeDatetime, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('getChatSummaryByUser1', 'userId', userId);
            const localVarPath = `/chat/user_summary/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (beforeDatetime !== undefined) {
                for (const [key, value] of Object.entries(beforeDatetime)) {
                    localVarQueryParameter[key] = value;
                }
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UserSummaryApiAxiosParamCreator = UserSummaryApiAxiosParamCreator;
/**
 * UserSummaryApi - functional programming interface
 * @export
 */
const UserSummaryApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserSummaryApiAxiosParamCreator)(configuration);
    return {
        /**
         * Retrieves summaries of all chat conversations for a user
         * @summary Get the user chat summaries
         * @param {number} userId User ID to fetch chat summaries for
         * @param {number} [limit] Limit the number of chat summaries returned
         * @param {LocalDateTimeQueryString} [beforeDatetime] Only return chat summaries before this datetime (UTC timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatSummaryByUser1(userId, limit, beforeDatetime, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatSummaryByUser1(userId, limit, beforeDatetime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UserSummaryApi.getChatSummaryByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.UserSummaryApiFp = UserSummaryApiFp;
/**
 * UserSummaryApi - factory interface
 * @export
 */
const UserSummaryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserSummaryApiFp)(configuration);
    return {
        /**
         * Retrieves summaries of all chat conversations for a user
         * @summary Get the user chat summaries
         * @param {UserSummaryApiGetChatSummaryByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatSummaryByUser1(requestParameters, options) {
            return localVarFp.getChatSummaryByUser1(requestParameters.userId, requestParameters.limit, requestParameters.beforeDatetime, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserSummaryApiFactory = UserSummaryApiFactory;
/**
 * UserSummaryApi - object-oriented interface
 * @export
 * @class UserSummaryApi
 * @extends {BaseAPI}
 */
class UserSummaryApi extends base_1.BaseAPI {
    /**
     * Retrieves summaries of all chat conversations for a user
     * @summary Get the user chat summaries
     * @param {UserSummaryApiGetChatSummaryByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSummaryApi
     */
    getChatSummaryByUser1(requestParameters, options) {
        return (0, exports.UserSummaryApiFp)(this.configuration).getChatSummaryByUser1(requestParameters.userId, requestParameters.limit, requestParameters.beforeDatetime, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserSummaryApi = UserSummaryApi;
/**
 * UserTypesApi - axios parameter creator
 * @export
 */
const UserTypesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTypes1: async (options = {}) => {
            const localVarPath = `/user-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UserTypesApiAxiosParamCreator = UserTypesApiAxiosParamCreator;
/**
 * UserTypesApi - functional programming interface
 * @export
 */
const UserTypesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UserTypesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTypes1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTypes1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UserTypesApi.getUserTypes1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.UserTypesApiFp = UserTypesApiFp;
/**
 * UserTypesApi - factory interface
 * @export
 */
const UserTypesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UserTypesApiFp)(configuration);
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTypes1(options) {
            return localVarFp.getUserTypes1(options).then((request) => request(axios, basePath));
        },
    };
};
exports.UserTypesApiFactory = UserTypesApiFactory;
/**
 * UserTypesApi - object-oriented interface
 * @export
 * @class UserTypesApi
 * @extends {BaseAPI}
 */
class UserTypesApi extends base_1.BaseAPI {
    /**
     * Returns all available user types in the system
     * @summary Get user types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTypesApi
     */
    getUserTypes1(options) {
        return (0, exports.UserTypesApiFp)(this.configuration).getUserTypes1(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UserTypesApi = UserTypesApi;
/**
 * UsersApi - axios parameter creator
 * @export
 */
const UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser1: async (options = {}) => {
            const localVarPath = `/users/activate-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {number} userId ID of the user to add skills to
         * @param {Array<UserSkill>} userSkill List of skills to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserSkills1: async (userId, userSkill, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('addUserSkills1', 'userId', userId);
            // verify required parameter 'userSkill' is not null or undefined
            (0, common_1.assertParamExists)('addUserSkills1', 'userSkill', userSkill);
            const localVarPath = `/users/{userId}/skills`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(userSkill, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {number} userId
         * @param {PhoneCodeCheckResource} phoneCodeCheckResource Phone code verification details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPhoneVerificationCodeCommand1: async (userId, phoneCodeCheckResource, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('checkPhoneVerificationCodeCommand1', 'userId', userId);
            // verify required parameter 'phoneCodeCheckResource' is not null or undefined
            (0, common_1.assertParamExists)('checkPhoneVerificationCodeCommand1', 'phoneCodeCheckResource', phoneCodeCheckResource);
            const localVarPath = `/users/{userId}/phone-code-check`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(phoneCodeCheckResource, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {number} userId ID of the user whose skill is being endorsed
         * @param {number} skillId ID of the skill being endorsed
         * @param {SkillEndorsement} skillEndorsement Endorsement details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endorseUserSkill1: async (userId, skillId, skillEndorsement, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('endorseUserSkill1', 'userId', userId);
            // verify required parameter 'skillId' is not null or undefined
            (0, common_1.assertParamExists)('endorseUserSkill1', 'skillId', skillId);
            // verify required parameter 'skillEndorsement' is not null or undefined
            (0, common_1.assertParamExists)('endorseUserSkill1', 'skillEndorsement', skillEndorsement);
            const localVarPath = `/users/{userId}/skills/{skillId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"skillId"}}`, encodeURIComponent(String(skillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(skillEndorsement, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {UserListRequest} userListRequest User list request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomUsers1: async (userListRequest, options = {}) => {
            // verify required parameter 'userListRequest' is not null or undefined
            (0, common_1.assertParamExists)('fetchRandomUsers1', 'userListRequest', userListRequest);
            const localVarPath = `/users/fetch-random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(userListRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('find', 'userId', userId);
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {string} [profileName] User\&#39;s profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1: async (profileName, options = {}) => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (profileName !== undefined) {
                localVarQueryParameter['profileName'] = profileName;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {string} userIds Comma-separated list of user IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findList1: async (userIds, options = {}) => {
            // verify required parameter 'userIds' is not null or undefined
            (0, common_1.assertParamExists)('findList1', 'userIds', userIds);
            const localVarPath = `/users/list/{userIds}`
                .replace(`{${"userIds"}}`, encodeURIComponent(String(userIds)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {string} [propertyPublicationState]
         * @param {string} [xmlId]
         * @param {string} [aPIVersion]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertiesByUser1: async (id, pageFrom, pageTo, propertyPublicationState, xmlId, aPIVersion, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('findPropertiesByUser1', 'id', id);
            const localVarPath = `/users/{id}/properties`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            if (propertyPublicationState !== undefined) {
                localVarQueryParameter['propertyPublicationState'] = propertyPublicationState;
            }
            if (xmlId !== undefined) {
                localVarQueryParameter['xmlId'] = xmlId;
            }
            if (aPIVersion != null) {
                localVarHeaderParameter['API-Version'] = String(aPIVersion);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the testimonials list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialsByUser1: async (id, pageFrom, pageTo, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('findTestimonialsByUser1', 'id', id);
            const localVarPath = `/users/{id}/testimonials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('findUserConnections', 'userId', userId);
            const localVarPath = `/users/{userId}/connections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {string} subscriptionPlanName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedUsers1: async (subscriptionPlanName, options = {}) => {
            // verify required parameter 'subscriptionPlanName' is not null or undefined
            (0, common_1.assertParamExists)('getSubscribedUsers1', 'subscriptionPlanName', subscriptionPlanName);
            const localVarPath = `/users/subscribed-users/{subscriptionPlanName}`
                .replace(`{${"subscriptionPlanName"}}`, encodeURIComponent(String(subscriptionPlanName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {number} [id]
         * @param {string} [lang]
         * @param {string} [acceptLanguage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty: async (id, lang, acceptLanguage, options = {}) => {
            const localVarPath = `/users/previews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {SkilledUser} skilledUser User registration data
         * @param {string} [origin]
         * @param {boolean} [skipEmailValidation] Skip email validation step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register1: async (skilledUser, origin, skipEmailValidation, options = {}) => {
            // verify required parameter 'skilledUser' is not null or undefined
            (0, common_1.assertParamExists)('register1', 'skilledUser', skilledUser);
            const localVarPath = `/users/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (skipEmailValidation !== undefined) {
                localVarQueryParameter['skipEmailValidation'] = skipEmailValidation;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(skilledUser, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {string} [origin]
         * @param {string} [email]
         * @param {string} [password]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestActivationLink1: async (origin, email, password, options = {}) => {
            const localVarPath = `/users/activation_link_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            if (email !== undefined) {
                localVarFormParams.set('email', email);
            }
            if (password !== undefined) {
                localVarFormParams.set('password', password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Request testimonial from specified user id
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTestimonialFromUser1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('requestTestimonialFromUser1', 'id', id);
            const localVarPath = `/users/{id}/request-testimonial`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {number} userId ID of the user whose skill endorsements to retrieve
         * @param {number} skillId ID of the skill to retrieve endorsements for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSkillEndorsements1: async (userId, skillId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveSkillEndorsements1', 'userId', userId);
            // verify required parameter 'skillId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveSkillEndorsements1', 'skillId', skillId);
            const localVarPath = `/users/{userId}/skills/{skillId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"skillId"}}`, encodeURIComponent(String(skillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {number} userId ID of the user to retrieve skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('retrieveUserSkills', 'userId', userId);
            const localVarPath = `/users/{userId}/skills`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {SkilledUser} skilledUser User data to save
         * @param {string} [oAuthToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save: async (skilledUser, oAuthToken, options = {}) => {
            // verify required parameter 'skilledUser' is not null or undefined
            (0, common_1.assertParamExists)('save', 'skilledUser', skilledUser);
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            if (oAuthToken != null) {
                localVarHeaderParameter['O-Auth-Token'] = String(oAuthToken);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(skilledUser, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {LogEntry} [logEntry]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLog1: async (logEntry, options = {}) => {
            const localVarPath = `/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(logEntry, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for users within a specific group matching the specified filter criteria
         * @summary Search users within a specified group
         * @param {string} groupId Group ID
         * @param {UserFilterRequest} userFilterRequest User search filters within the group. Supports filtering by user attributes, location, skills, and social preferences. The resultRequest field controls pagination and sorting. Only one sort order can be specified at a time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroupUsers1: async (groupId, userFilterRequest, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('searchGroupUsers1', 'groupId', groupId);
            // verify required parameter 'userFilterRequest' is not null or undefined
            (0, common_1.assertParamExists)('searchGroupUsers1', 'userFilterRequest', userFilterRequest);
            const localVarPath = `/groups/{groupId}/users/search`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(userFilterRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for users matching the specified filter criteria
         * @summary Search users with specified filters
         * @param {UserFilterRequest} userFilterRequest User search filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers1: async (userFilterRequest, options = {}) => {
            // verify required parameter 'userFilterRequest' is not null or undefined
            (0, common_1.assertParamExists)('searchUsers1', 'userFilterRequest', userFilterRequest);
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(userFilterRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayedSusbscribersAlert1: async (options = {}) => {
            const localVarPath = `/users/weekly-payed-subscribers-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {number} userId
         * @param {PhoneCodeRequestResource} phoneCodeRequestResource Phone code request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPhoneVerificationCodeCommand1: async (userId, phoneCodeRequestResource, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            (0, common_1.assertParamExists)('sendPhoneVerificationCodeCommand1', 'userId', userId);
            // verify required parameter 'phoneCodeRequestResource' is not null or undefined
            (0, common_1.assertParamExists)('sendPhoneVerificationCodeCommand1', 'phoneCodeRequestResource', phoneCodeRequestResource);
            const localVarPath = `/users/{userId}/phone-code-request`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(phoneCodeRequestResource, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.UsersApiAxiosParamCreator = UsersApiAxiosParamCreator;
/**
 * UsersApi - functional programming interface
 * @export
 */
const UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UsersApiAxiosParamCreator)(configuration);
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUser1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUser1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.activateUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {number} userId ID of the user to add skills to
         * @param {Array<UserSkill>} userSkill List of skills to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserSkills1(userId, userSkill, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserSkills1(userId, userSkill, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.addUserSkills1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {number} userId
         * @param {PhoneCodeCheckResource} phoneCodeCheckResource Phone code verification details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPhoneVerificationCodeCommand1(userId, phoneCodeCheckResource, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPhoneVerificationCodeCommand1(userId, phoneCodeCheckResource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.checkPhoneVerificationCodeCommand1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {number} userId ID of the user whose skill is being endorsed
         * @param {number} skillId ID of the skill being endorsed
         * @param {SkillEndorsement} skillEndorsement Endorsement details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endorseUserSkill1(userId, skillId, skillEndorsement, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endorseUserSkill1(userId, skillId, skillEndorsement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.endorseUserSkill1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {UserListRequest} userListRequest User list request parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomUsers1(userListRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomUsers1(userListRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.fetchRandomUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {string} [profileName] User\&#39;s profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find1(profileName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find1(profileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.find1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {string} userIds Comma-separated list of user IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findList1(userIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findList1(userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.findList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {string} [propertyPublicationState]
         * @param {string} [xmlId]
         * @param {string} [aPIVersion]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPropertiesByUser1(id, pageFrom, pageTo, propertyPublicationState, xmlId, aPIVersion, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertiesByUser1(id, pageFrom, pageTo, propertyPublicationState, xmlId, aPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.findPropertiesByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the testimonials list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialsByUser1(id, pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialsByUser1(id, pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.findTestimonialsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserConnections(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserConnections(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.findUserConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {string} subscriptionPlanName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscribedUsers1(subscriptionPlanName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscribedUsers1(subscriptionPlanName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.getSubscribedUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {number} [id]
         * @param {string} [lang]
         * @param {string} [acceptLanguage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewProperty(id, lang, acceptLanguage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewProperty(id, lang, acceptLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.previewProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {SkilledUser} skilledUser User registration data
         * @param {string} [origin]
         * @param {boolean} [skipEmailValidation] Skip email validation step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register1(skilledUser, origin, skipEmailValidation, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register1(skilledUser, origin, skipEmailValidation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.register1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {string} [origin]
         * @param {string} [email]
         * @param {string} [password]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestActivationLink1(origin, email, password, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestActivationLink1(origin, email, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.requestActivationLink1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Request testimonial from specified user id
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTestimonialFromUser1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTestimonialFromUser1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.requestTestimonialFromUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {number} userId ID of the user whose skill endorsements to retrieve
         * @param {number} skillId ID of the skill to retrieve endorsements for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSkillEndorsements1(userId, skillId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSkillEndorsements1(userId, skillId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.retrieveSkillEndorsements1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {number} userId ID of the user to retrieve skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSkills(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSkills(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.retrieveUserSkills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {SkilledUser} skilledUser User data to save
         * @param {string} [oAuthToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save(skilledUser, oAuthToken, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save(skilledUser, oAuthToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.save']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {LogEntry} [logEntry]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveLog1(logEntry, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveLog1(logEntry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.saveLog1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Searches for users within a specific group matching the specified filter criteria
         * @summary Search users within a specified group
         * @param {string} groupId Group ID
         * @param {UserFilterRequest} userFilterRequest User search filters within the group. Supports filtering by user attributes, location, skills, and social preferences. The resultRequest field controls pagination and sorting. Only one sort order can be specified at a time.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGroupUsers1(groupId, userFilterRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGroupUsers1(groupId, userFilterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.searchGroupUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Searches for users matching the specified filter criteria
         * @summary Search users with specified filters
         * @param {UserFilterRequest} userFilterRequest User search filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers1(userFilterRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers1(userFilterRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.searchUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPayedSusbscribersAlert1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPayedSusbscribersAlert1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.sendPayedSusbscribersAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {number} userId
         * @param {PhoneCodeRequestResource} phoneCodeRequestResource Phone code request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPhoneVerificationCodeCommand1(userId, phoneCodeRequestResource, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPhoneVerificationCodeCommand1(userId, phoneCodeRequestResource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = base_1.operationServerMap['UsersApi.sendPhoneVerificationCodeCommand1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
exports.UsersApiFp = UsersApiFp;
/**
 * UsersApi - factory interface
 * @export
 */
const UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UsersApiFp)(configuration);
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser1(options) {
            return localVarFp.activateUser1(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {UsersApiAddUserSkills1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserSkills1(requestParameters, options) {
            return localVarFp.addUserSkills1(requestParameters.userId, requestParameters.userSkill, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {UsersApiCheckPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPhoneVerificationCodeCommand1(requestParameters, options) {
            return localVarFp.checkPhoneVerificationCodeCommand1(requestParameters.userId, requestParameters.phoneCodeCheckResource, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {UsersApiEndorseUserSkill1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endorseUserSkill1(requestParameters, options) {
            return localVarFp.endorseUserSkill1(requestParameters.userId, requestParameters.skillId, requestParameters.skillEndorsement, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {UsersApiFetchRandomUsers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomUsers1(requestParameters, options) {
            return localVarFp.fetchRandomUsers1(requestParameters.userListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {UsersApiFindRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(requestParameters, options) {
            return localVarFp.find(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {UsersApiFind1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1(requestParameters = {}, options) {
            return localVarFp.find1(requestParameters.profileName, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {UsersApiFindList1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findList1(requestParameters, options) {
            return localVarFp.findList1(requestParameters.userIds, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {UsersApiFindPropertiesByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertiesByUser1(requestParameters, options) {
            return localVarFp.findPropertiesByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, requestParameters.propertyPublicationState, requestParameters.xmlId, requestParameters.aPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the testimonials list with specified user id
         * @param {UsersApiFindTestimonialsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialsByUser1(requestParameters, options) {
            return localVarFp.findTestimonialsByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {UsersApiFindUserConnectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections(requestParameters, options) {
            return localVarFp.findUserConnections(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {UsersApiGetSubscribedUsers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedUsers1(requestParameters, options) {
            return localVarFp.getSubscribedUsers1(requestParameters.subscriptionPlanName, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {UsersApiPreviewPropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty(requestParameters = {}, options) {
            return localVarFp.previewProperty(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {UsersApiRegister1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register1(requestParameters, options) {
            return localVarFp.register1(requestParameters.skilledUser, requestParameters.origin, requestParameters.skipEmailValidation, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {UsersApiRequestActivationLink1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestActivationLink1(requestParameters = {}, options) {
            return localVarFp.requestActivationLink1(requestParameters.origin, requestParameters.email, requestParameters.password, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Request testimonial from specified user id
         * @param {UsersApiRequestTestimonialFromUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTestimonialFromUser1(requestParameters, options) {
            return localVarFp.requestTestimonialFromUser1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {UsersApiRetrieveSkillEndorsements1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSkillEndorsements1(requestParameters, options) {
            return localVarFp.retrieveSkillEndorsements1(requestParameters.userId, requestParameters.skillId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {UsersApiRetrieveUserSkillsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills(requestParameters, options) {
            return localVarFp.retrieveUserSkills(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {UsersApiSaveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save(requestParameters, options) {
            return localVarFp.save(requestParameters.skilledUser, requestParameters.oAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UsersApiSaveLog1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLog1(requestParameters = {}, options) {
            return localVarFp.saveLog1(requestParameters.logEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for users within a specific group matching the specified filter criteria
         * @summary Search users within a specified group
         * @param {UsersApiSearchGroupUsers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroupUsers1(requestParameters, options) {
            return localVarFp.searchGroupUsers1(requestParameters.groupId, requestParameters.userFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for users matching the specified filter criteria
         * @summary Search users with specified filters
         * @param {UsersApiSearchUsers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers1(requestParameters, options) {
            return localVarFp.searchUsers1(requestParameters.userFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayedSusbscribersAlert1(options) {
            return localVarFp.sendPayedSusbscribersAlert1(options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {UsersApiSendPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPhoneVerificationCodeCommand1(requestParameters, options) {
            return localVarFp.sendPhoneVerificationCodeCommand1(requestParameters.userId, requestParameters.phoneCodeRequestResource, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UsersApiFactory = UsersApiFactory;
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
class UsersApi extends base_1.BaseAPI {
    /**
     * Activates a user account using the activation key sent to their email
     * @summary Activate the account of specified user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    activateUser1(options) {
        return (0, exports.UsersApiFp)(this.configuration).activateUser1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is not supported. Use save user profile to update skills instead.
     * @summary Add user skills
     * @param {UsersApiAddUserSkills1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    addUserSkills1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).addUserSkills1(requestParameters.userId, requestParameters.userSkill, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Verifies the code that was sent to the user\'s phone
     * @summary Verify the phone code sent to user
     * @param {UsersApiCheckPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    checkPhoneVerificationCodeCommand1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).checkPhoneVerificationCodeCommand1(requestParameters.userId, requestParameters.phoneCodeCheckResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows a user to endorse another user\'s skill
     * @summary Endorse a user skill
     * @param {UsersApiEndorseUserSkill1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    endorseUserSkill1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).endorseUserSkill1(requestParameters.userId, requestParameters.skillId, requestParameters.skillEndorsement, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a random selection of users based on specified criteria
     * @summary Fetch random list of users, with basic data
     * @param {UsersApiFetchRandomUsers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    fetchRandomUsers1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).fetchRandomUsers1(requestParameters.userListRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets detailed user information by user ID
     * @summary Fetch user detail according to its id
     * @param {UsersApiFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    find(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).find(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets user information by their unique profile name
     * @summary Fetch user detail according to its profile name
     * @param {UsersApiFind1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    find1(requestParameters = {}, options) {
        return (0, exports.UsersApiFp)(this.configuration).find1(requestParameters.profileName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets detailed information for multiple users by their IDs
     * @summary Fetch multiple user detail according to its ids
     * @param {UsersApiFindList1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    findList1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).findList1(requestParameters.userIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the property list with specified user id
     * @param {UsersApiFindPropertiesByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    findPropertiesByUser1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).findPropertiesByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, requestParameters.propertyPublicationState, requestParameters.xmlId, requestParameters.aPIVersion, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the testimonials list with specified user id
     * @param {UsersApiFindTestimonialsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    findTestimonialsByUser1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).findTestimonialsByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the list of connections for a specific user
     * @summary Get a user connections
     * @param {UsersApiFindUserConnectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    findUserConnections(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).findUserConnections(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all users who have subscribed to the specified subscription plan
     * @summary Gets the users subscribed to a subscription plan name like Professional
     * @param {UsersApiGetSubscribedUsers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getSubscribedUsers1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).getSubscribedUsers1(requestParameters.subscriptionPlanName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates an HTML preview of a user profile for sharing purposes
     * @summary Get HTML preview of a user profile
     * @param {UsersApiPreviewPropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    previewProperty(requestParameters = {}, options) {
        return (0, exports.UsersApiFp)(this.configuration).previewProperty(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new user account in the system
     * @summary Register new user in the system
     * @param {UsersApiRegister1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    register1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).register1(requestParameters.skilledUser, requestParameters.origin, requestParameters.skipEmailValidation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends an activation link to the user\'s email for account verification
     * @summary Request activation link
     * @param {UsersApiRequestActivationLink1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    requestActivationLink1(requestParameters = {}, options) {
        return (0, exports.UsersApiFp)(this.configuration).requestActivationLink1(requestParameters.origin, requestParameters.email, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Request testimonial from specified user id
     * @param {UsersApiRequestTestimonialFromUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    requestTestimonialFromUser1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).requestTestimonialFromUser1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all endorsements for a specific user skill
     * @summary Retrieve skill endorsements
     * @param {UsersApiRetrieveSkillEndorsements1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    retrieveSkillEndorsements1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).retrieveSkillEndorsements1(requestParameters.userId, requestParameters.skillId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all skills associated with a user
     * @summary Retrieve user skills
     * @param {UsersApiRetrieveUserSkillsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    retrieveUserSkills(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).retrieveUserSkills(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates user profile information in the system
     * @summary Save the data of user in the system
     * @param {UsersApiSaveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    save(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).save(requestParameters.skilledUser, requestParameters.oAuthToken, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {UsersApiSaveLog1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    saveLog1(requestParameters = {}, options) {
        return (0, exports.UsersApiFp)(this.configuration).saveLog1(requestParameters.logEntry, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches for users within a specific group matching the specified filter criteria
     * @summary Search users within a specified group
     * @param {UsersApiSearchGroupUsers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    searchGroupUsers1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).searchGroupUsers1(requestParameters.groupId, requestParameters.userFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches for users matching the specified filter criteria
     * @summary Search users with specified filters
     * @param {UsersApiSearchUsers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    searchUsers1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).searchUsers1(requestParameters.userFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    sendPayedSusbscribersAlert1(options) {
        return (0, exports.UsersApiFp)(this.configuration).sendPayedSusbscribersAlert1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends a verification code to the user\'s phone number for verification purposes
     * @summary Send a code to the previously saved phone number of the user
     * @param {UsersApiSendPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    sendPhoneVerificationCodeCommand1(requestParameters, options) {
        return (0, exports.UsersApiFp)(this.configuration).sendPhoneVerificationCodeCommand1(requestParameters.userId, requestParameters.phoneCodeRequestResource, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsersApi = UsersApi;
