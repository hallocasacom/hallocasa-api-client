/* tslint:disable */
/* eslint-disable */
/**
 * Hallocasa API
 * Hallocasa API Documentation
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI, operationServerMap } from './base';
export const AlertUserAlertTypeEnum = {
    Property: 'PROPERTY'
};
export const ChatAllowanceChatAllowanceTypeEnum = {
    Rejected: 'REJECTED',
    Accepted: 'ACCEPTED',
    Pending: 'PENDING',
    Blocked: 'BLOCKED',
    Silenced: 'SILENCED'
};
export const CheckoutSessionDtoStatusEnum = {
    InProcess: 'IN_PROCESS',
    Success: 'SUCCESS',
    Canceled: 'CANCELED',
    Failed: 'FAILED'
};
export const ConversationSummaryChatAllowanceTypeEnum = {
    Rejected: 'REJECTED',
    Accepted: 'ACCEPTED',
    Pending: 'PENDING',
    Blocked: 'BLOCKED',
    Silenced: 'SILENCED'
};
export const DropdownOptionGroupTranslationManagementEnum = {
    Total: 'TOTAL',
    Partial: 'PARTIAL',
    None: 'NONE'
};
export const FavoriteResourceTypeEnum = {
    Property: 'PROPERTY'
};
export const FilterShowingStepSequenceBeforeEnum = {
    InitGroup: 'INIT_GROUP',
    EndGroup: 'END_GROUP',
    And: 'AND',
    Or: 'OR'
};
export const FilterShowingStepSequenceAfterEnum = {
    InitGroup: 'INIT_GROUP',
    EndGroup: 'END_GROUP',
    And: 'AND',
    Or: 'OR'
};
export const GroupGroupStatusEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Inactive: 'INACTIVE',
    Archived: 'ARCHIVED',
    Deleted: 'DELETED'
};
export const GroupMemberGroupMemberStatusEnum = {
    Invited: 'INVITED',
    Requested: 'REQUESTED',
    Accepted: 'ACCEPTED',
    Rejected: 'REJECTED',
    Removed: 'REMOVED',
    Left: 'LEFT'
};
export const HcFilterChoiceEnum = {
    Show: 'SHOW',
    Hide: 'HIDE'
};
export const HcFilterFilterWorkerOptionEnum = {
    PropertyLocationKey: 'PROPERTY_LOCATION_KEY',
    CountryKey: 'COUNTRY_KEY',
    PropertyProposalKey: 'PROPERTY_PROPOSAL_KEY',
    Range: 'RANGE',
    Dropdown: 'DROPDOWN',
    Boolean: 'BOOLEAN',
    CurrencyRange: 'CURRENCY_RANGE',
    Roi: 'ROI',
    FreeText: 'FREE_TEXT',
    Id: 'ID',
    PublicationState: 'PUBLICATION_STATE',
    PublicationDate: 'PUBLICATION_DATE',
    GeolocationArea: 'GEOLOCATION_AREA',
    Groups: 'GROUPS',
    UserId: 'USER_ID',
    XmlId: 'XML_ID'
};
export const HcFilterHcListerOptionEnum = {
    PropertyType: 'PROPERTY_TYPE'
};
export const HcFilterConditionMinOperandEnum = {
    Gt: 'GT',
    Get: 'GET',
    Eq: 'EQ',
    Lt: 'LT',
    Let: 'LET'
};
export const HcFilterConditionMaxOperandEnum = {
    Gt: 'GT',
    Get: 'GET',
    Eq: 'EQ',
    Lt: 'LT',
    Let: 'LET'
};
export const HcFilterEntryChoiceEnum = {
    Show: 'SHOW',
    Hide: 'HIDE'
};
export const HcFilterEntryFilterWorkerOptionEnum = {
    PropertyLocationKey: 'PROPERTY_LOCATION_KEY',
    CountryKey: 'COUNTRY_KEY',
    PropertyProposalKey: 'PROPERTY_PROPOSAL_KEY',
    Range: 'RANGE',
    Dropdown: 'DROPDOWN',
    Boolean: 'BOOLEAN',
    CurrencyRange: 'CURRENCY_RANGE',
    Roi: 'ROI',
    FreeText: 'FREE_TEXT',
    Id: 'ID',
    PublicationState: 'PUBLICATION_STATE',
    PublicationDate: 'PUBLICATION_DATE',
    GeolocationArea: 'GEOLOCATION_AREA',
    Groups: 'GROUPS',
    UserId: 'USER_ID',
    XmlId: 'XML_ID'
};
export const HcFilterTypeFilterTypeNatureEnum = {
    Dropdown: 'DROPDOWN',
    Yesno: 'YESNO',
    Range: 'RANGE',
    Text: 'TEXT',
    AreaRange: 'AREA_RANGE'
};
export const HcFilterTypeRangeFieldPresentationEnum = {
    Integer: 'INTEGER',
    Double: 'DOUBLE',
    Currency: 'CURRENCY',
    Date: 'DATE'
};
export const HcFilterTypeEntryFilterTypeNatureEnum = {
    Dropdown: 'DROPDOWN',
    Yesno: 'YESNO',
    Range: 'RANGE',
    Text: 'TEXT',
    AreaRange: 'AREA_RANGE'
};
export const HcFilterTypeEntryRangeFieldPresentationEnum = {
    Integer: 'INTEGER',
    Double: 'DOUBLE',
    Currency: 'CURRENCY',
    Date: 'DATE'
};
export const JsonObjectValueTypeEnum = {
    Array: 'ARRAY',
    Object: 'OBJECT',
    String: 'STRING',
    Number: 'NUMBER',
    True: 'TRUE',
    False: 'FALSE',
    Null: 'NULL'
};
export const JsonValueValueTypeEnum = {
    Array: 'ARRAY',
    Object: 'OBJECT',
    String: 'STRING',
    Number: 'NUMBER',
    True: 'TRUE',
    False: 'FALSE',
    Null: 'NULL'
};
export const NotificationTypeEnum = {
    ToBrokerAlertCreated: 'TO_BROKER__ALERT_CREATED',
    ToUserWeeklyProperties: 'TO_USER__WEEKLY_PROPERTIES',
    ToUserWeeklyPayedSubscribers: 'TO_USER__WEEKLY_PAYED_SUBSCRIBERS',
    ToUserCustomizedAlert: 'TO_USER__CUSTOMIZED_ALERT',
    ToUserWeeklyGroupProperties: 'TO_USER__WEEKLY_GROUP_PROPERTIES',
    ToUserNewsletterNewSubscriber: 'TO_USER__NEWSLETTER_NEW_SUBSCRIBER',
    ToUserNewsletterConfirmation: 'TO_USER__NEWSLETTER_CONFIRMATION',
    ToUserNewsletterListing: 'TO_USER__NEWSLETTER_LISTING'
};
export const NotificationBodyValueTypeEnum = {
    Array: 'ARRAY',
    Object: 'OBJECT',
    String: 'STRING',
    Number: 'NUMBER',
    True: 'TRUE',
    False: 'FALSE',
    Null: 'NULL'
};
export const PropertyPublicationStateEnum = {
    Available: 'AVAILABLE',
    Rented: 'RENTED',
    Sold: 'SOLD',
    Draft: 'DRAFT'
};
export const PropertyFieldTextTypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
};
export const PropertyFieldData1TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
};
export const PropertyFieldData2TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
};
export const PropertyFieldData3TypeEnum = {
    Same: 'SAME',
    Int: 'INT',
    Double: 'DOUBLE',
    Boolean: 'BOOLEAN',
    Text: 'TEXT',
    Date: 'DATE',
    Datetime: 'DATETIME',
    File: 'FILE',
    Bigint: 'BIGINT'
};
export const PropertyFieldHcListerOptionEnum = {
    PropertyType: 'PROPERTY_TYPE'
};
export const SubscriptionPriceDtoRenewalTypeEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Every3Months: 'EVERY_3_MONTHS',
    Every6Months: 'EVERY_6_MONTHS',
    Yearly: 'YEARLY'
};
export const UserSubscriptionDtoRenewalTypeEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Monthly: 'MONTHLY',
    Every3Months: 'EVERY_3_MONTHS',
    Every6Months: 'EVERY_6_MONTHS',
    Yearly: 'YEARLY'
};
export const UserSubscriptionDtoStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
};
/**
 * AlertsApi - axios parameter creator
 * @export
 */
export const AlertsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert1: async (userId, alertId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteAlert1', 'userId', userId);
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('deleteAlert1', 'alertId', alertId);
            const localVarPath = `/users/{userId}/alerts/{alertId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to retrieve results for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertResult1: async (userId, alertId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getAlertResult1', 'userId', userId);
            // verify required parameter 'alertId' is not null or undefined
            assertParamExists('getAlertResult1', 'alertId', alertId);
            const localVarPath = `/users/{userId}/alerts/{alertId}/result`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {number} userId ID of the user to retrieve alerts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser2: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getByUser2', 'userId', userId);
            const localVarPath = `/users/{userId}/alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {number} userId ID of the user who subscribed to newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterAlerts1: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('newsletterAlerts1', 'userId', userId);
            const localVarPath = `/users/{userId}/alerts/newsletter-alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {number} userId ID of the user who owns the newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterSubscribers1: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('newsletterSubscribers1', 'userId', userId);
            const localVarPath = `/users/{userId}/alerts/newsletter-subscribers`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {number} userId ID of the user to create the alert for
         * @param {Alert} alert Alert to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlert1: async (userId, alert, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('saveAlert1', 'userId', userId);
            // verify required parameter 'alert' is not null or undefined
            assertParamExists('saveAlert1', 'alert', alert);
            const localVarPath = `/users/{userId}/alerts`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(alert, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert: async (options = {}) => {
            const localVarPath = `/users/{userId}/alerts/send-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function (configuration) {
    const localVarAxiosParamCreator = AlertsApiAxiosParamCreator(configuration);
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert1(userId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert1(userId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.deleteAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {number} userId ID of the user who owns the alert
         * @param {number} alertId ID of the alert to retrieve results for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAlertResult1(userId, alertId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAlertResult1(userId, alertId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.getAlertResult1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {number} userId ID of the user to retrieve alerts for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUser2(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUser2(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.getByUser2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {number} userId ID of the user who subscribed to newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsletterAlerts1(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsletterAlerts1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.newsletterAlerts1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {number} userId ID of the user who owns the newsletters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsletterSubscribers1(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsletterSubscribers1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.newsletterSubscribers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {number} userId ID of the user to create the alert for
         * @param {Alert} alert Alert to be created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAlert1(userId, alert, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveAlert1(userId, alert, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.saveAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendAlert(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendAlert(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AlertsApi.sendAlert']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AlertsApiFp(configuration);
    return {
        /**
         * Deletes a specific alert owned by the user
         * @summary Delete an alert
         * @param {AlertsApiDeleteAlert1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert1(requestParameters, options) {
            return localVarFp.deleteAlert1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the results for a specific alert
         * @summary Get alert results
         * @param {AlertsApiGetAlertResult1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlertResult1(requestParameters, options) {
            return localVarFp.getAlertResult1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all alerts associated with the specified user ID
         * @summary Get all alerts for a user
         * @param {AlertsApiGetByUser2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser2(requestParameters, options) {
            return localVarFp.getByUser2(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all newsletters that the specified user has subscribed to
         * @summary Get newsletters subscribed to
         * @param {AlertsApiNewsletterAlerts1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterAlerts1(requestParameters, options) {
            return localVarFp.newsletterAlerts1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all subscribers to newsletters owned by the specified user
         * @summary Get newsletter subscribers
         * @param {AlertsApiNewsletterSubscribers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterSubscribers1(requestParameters, options) {
            return localVarFp.newsletterSubscribers1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new alert for the specified user
         * @summary Create a new alert
         * @param {AlertsApiSaveAlert1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAlert1(requestParameters, options) {
            return localVarFp.saveAlert1(requestParameters.userId, requestParameters.alert, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers the sending of customized property alerts to users
         * @summary Send customized property alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert(options) {
            return localVarFp.sendAlert(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * Deletes a specific alert owned by the user
     * @summary Delete an alert
     * @param {AlertsApiDeleteAlert1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    deleteAlert1(requestParameters, options) {
        return AlertsApiFp(this.configuration).deleteAlert1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the results for a specific alert
     * @summary Get alert results
     * @param {AlertsApiGetAlertResult1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    getAlertResult1(requestParameters, options) {
        return AlertsApiFp(this.configuration).getAlertResult1(requestParameters.userId, requestParameters.alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all alerts associated with the specified user ID
     * @summary Get all alerts for a user
     * @param {AlertsApiGetByUser2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    getByUser2(requestParameters, options) {
        return AlertsApiFp(this.configuration).getByUser2(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all newsletters that the specified user has subscribed to
     * @summary Get newsletters subscribed to
     * @param {AlertsApiNewsletterAlerts1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    newsletterAlerts1(requestParameters, options) {
        return AlertsApiFp(this.configuration).newsletterAlerts1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all subscribers to newsletters owned by the specified user
     * @summary Get newsletter subscribers
     * @param {AlertsApiNewsletterSubscribers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    newsletterSubscribers1(requestParameters, options) {
        return AlertsApiFp(this.configuration).newsletterSubscribers1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new alert for the specified user
     * @summary Create a new alert
     * @param {AlertsApiSaveAlert1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    saveAlert1(requestParameters, options) {
        return AlertsApiFp(this.configuration).saveAlert1(requestParameters.userId, requestParameters.alert, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Triggers the sending of customized property alerts to users
     * @summary Send customized property alerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    sendAlert(options) {
        return AlertsApiFp(this.configuration).sendAlert(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AllowancesApi - axios parameter creator
 * @export
 */
export const AllowancesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
         * @summary Get chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatAllowance1: async (userPair, options = {}) => {
            // verify required parameter 'userPair' is not null or undefined
            assertParamExists('getChatAllowance1', 'userPair', userPair);
            const localVarPath = `/chat/allowance/{userPair}`
                .replace(`{${"userPair"}}`, encodeURIComponent(String(userPair)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the chat allowance settings between two users
         * @summary Update chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {ChatAllowance} chatAllowance Chat allowance information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatAllowance1: async (userPair, chatAllowance, options = {}) => {
            // verify required parameter 'userPair' is not null or undefined
            assertParamExists('updateChatAllowance1', 'userPair', userPair);
            // verify required parameter 'chatAllowance' is not null or undefined
            assertParamExists('updateChatAllowance1', 'chatAllowance', chatAllowance);
            const localVarPath = `/chat/allowance/{userPair}`
                .replace(`{${"userPair"}}`, encodeURIComponent(String(userPair)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(chatAllowance, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AllowancesApi - functional programming interface
 * @export
 */
export const AllowancesApiFp = function (configuration) {
    const localVarAxiosParamCreator = AllowancesApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
         * @summary Get chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatAllowance1(userPair, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatAllowance1(userPair, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllowancesApi.getChatAllowance1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the chat allowance settings between two users
         * @summary Update chat allowance for a user pair
         * @param {string} userPair User pair in the form userFrom-userTo
         * @param {ChatAllowance} chatAllowance Chat allowance information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChatAllowance1(userPair, chatAllowance, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateChatAllowance1(userPair, chatAllowance, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllowancesApi.updateChatAllowance1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * AllowancesApi - factory interface
 * @export
 */
export const AllowancesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AllowancesApiFp(configuration);
    return {
        /**
         * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
         * @summary Get chat allowance for a user pair
         * @param {AllowancesApiGetChatAllowance1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatAllowance1(requestParameters, options) {
            return localVarFp.getChatAllowance1(requestParameters.userPair, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the chat allowance settings between two users
         * @summary Update chat allowance for a user pair
         * @param {AllowancesApiUpdateChatAllowance1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChatAllowance1(requestParameters, options) {
            return localVarFp.updateChatAllowance1(requestParameters.userPair, requestParameters.chatAllowance, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AllowancesApi - object-oriented interface
 * @export
 * @class AllowancesApi
 * @extends {BaseAPI}
 */
export class AllowancesApi extends BaseAPI {
    /**
     * Retrieves the chat allowance settings between two users. User must be one of the involved parties.
     * @summary Get chat allowance for a user pair
     * @param {AllowancesApiGetChatAllowance1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    getChatAllowance1(requestParameters, options) {
        return AllowancesApiFp(this.configuration).getChatAllowance1(requestParameters.userPair, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the chat allowance settings between two users
     * @summary Update chat allowance for a user pair
     * @param {AllowancesApiUpdateChatAllowance1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllowancesApi
     */
    updateChatAllowance1(requestParameters, options) {
        return AllowancesApiFp(this.configuration).updateChatAllowance1(requestParameters.userPair, requestParameters.chatAllowance, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * AttachmentsApi - axios parameter creator
 * @export
 */
export const AttachmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Post a attachment request
         * @param {Attachment} [attachment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment1: async (attachment, options = {}) => {
            const localVarPath = `/chat/attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(attachment, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get details to download a file
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAttachment1: async (fileId, options = {}) => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('retrieveAttachment1', 'fileId', fileId);
            const localVarPath = `/chat/attachments/{fileId}`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Notify a new file has been loaded in S3
         * @param {string} fileId
         * @param {NotifyUploadRequest} [notifyUploadRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment1: async (fileId, notifyUploadRequest, options = {}) => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('updateAttachment1', 'fileId', fileId);
            const localVarPath = `/chat/attachments/{fileId}/notify-upload`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(notifyUploadRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AttachmentsApi - functional programming interface
 * @export
 */
export const AttachmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = AttachmentsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Post a attachment request
         * @param {Attachment} [attachment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAttachment1(attachment, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAttachment1(attachment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentsApi.createAttachment1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get details to download a file
         * @param {string} fileId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAttachment1(fileId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAttachment1(fileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentsApi.retrieveAttachment1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Notify a new file has been loaded in S3
         * @param {string} fileId
         * @param {NotifyUploadRequest} [notifyUploadRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAttachment1(fileId, notifyUploadRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAttachment1(fileId, notifyUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AttachmentsApi.updateAttachment1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * AttachmentsApi - factory interface
 * @export
 */
export const AttachmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AttachmentsApiFp(configuration);
    return {
        /**
         *
         * @summary Post a attachment request
         * @param {AttachmentsApiCreateAttachment1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAttachment1(requestParameters = {}, options) {
            return localVarFp.createAttachment1(requestParameters.attachment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get details to download a file
         * @param {AttachmentsApiRetrieveAttachment1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAttachment1(requestParameters, options) {
            return localVarFp.retrieveAttachment1(requestParameters.fileId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Notify a new file has been loaded in S3
         * @param {AttachmentsApiUpdateAttachment1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachment1(requestParameters, options) {
            return localVarFp.updateAttachment1(requestParameters.fileId, requestParameters.notifyUploadRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AttachmentsApi - object-oriented interface
 * @export
 * @class AttachmentsApi
 * @extends {BaseAPI}
 */
export class AttachmentsApi extends BaseAPI {
    /**
     *
     * @summary Post a attachment request
     * @param {AttachmentsApiCreateAttachment1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    createAttachment1(requestParameters = {}, options) {
        return AttachmentsApiFp(this.configuration).createAttachment1(requestParameters.attachment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get details to download a file
     * @param {AttachmentsApiRetrieveAttachment1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    retrieveAttachment1(requestParameters, options) {
        return AttachmentsApiFp(this.configuration).retrieveAttachment1(requestParameters.fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Notify a new file has been loaded in S3
     * @param {AttachmentsApiUpdateAttachment1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AttachmentsApi
     */
    updateAttachment1(requestParameters, options) {
        return AttachmentsApiFp(this.configuration).updateAttachment1(requestParameters.fileId, requestParameters.notifyUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BrokeragesApi - axios parameter creator
 * @export
 */
export const BrokeragesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve1: async (options = {}) => {
            const localVarPath = `/brokerages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BrokeragesApi - functional programming interface
 * @export
 */
export const BrokeragesApiFp = function (configuration) {
    const localVarAxiosParamCreator = BrokeragesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieve1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieve1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BrokeragesApi.retrieve1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * BrokeragesApi - factory interface
 * @export
 */
export const BrokeragesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BrokeragesApiFp(configuration);
    return {
        /**
         * Returns a list of all available brokerages in the system
         * @summary Retrieve all brokerages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieve1(options) {
            return localVarFp.retrieve1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BrokeragesApi - object-oriented interface
 * @export
 * @class BrokeragesApi
 * @extends {BaseAPI}
 */
export class BrokeragesApi extends BaseAPI {
    /**
     * Returns a list of all available brokerages in the system
     * @summary Retrieve all brokerages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BrokeragesApi
     */
    retrieve1(options) {
        return BrokeragesApiFp(this.configuration).retrieve1(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ChatTicketsApi - axios parameter creator
 * @export
 */
export const ChatTicketsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates and returns a chat ticket that can be used to establish a chat connection
         * @summary Retrieve a chat ticket for the authenticated user
         * @param {string} userAgent User agent string of the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserTicket1: async (userAgent, options = {}) => {
            // verify required parameter 'userAgent' is not null or undefined
            assertParamExists('retrieveUserTicket1', 'userAgent', userAgent);
            const localVarPath = `/chat/ticket`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (userAgent != null) {
                localVarHeaderParameter['user-agent'] = String(userAgent);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChatTicketsApi - functional programming interface
 * @export
 */
export const ChatTicketsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ChatTicketsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates and returns a chat ticket that can be used to establish a chat connection
         * @summary Retrieve a chat ticket for the authenticated user
         * @param {string} userAgent User agent string of the client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserTicket1(userAgent, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserTicket1(userAgent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatTicketsApi.retrieveUserTicket1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * ChatTicketsApi - factory interface
 * @export
 */
export const ChatTicketsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ChatTicketsApiFp(configuration);
    return {
        /**
         * Creates and returns a chat ticket that can be used to establish a chat connection
         * @summary Retrieve a chat ticket for the authenticated user
         * @param {ChatTicketsApiRetrieveUserTicket1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserTicket1(requestParameters, options) {
            return localVarFp.retrieveUserTicket1(requestParameters.userAgent, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChatTicketsApi - object-oriented interface
 * @export
 * @class ChatTicketsApi
 * @extends {BaseAPI}
 */
export class ChatTicketsApi extends BaseAPI {
    /**
     * Creates and returns a chat ticket that can be used to establish a chat connection
     * @summary Retrieve a chat ticket for the authenticated user
     * @param {ChatTicketsApiRetrieveUserTicket1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatTicketsApi
     */
    retrieveUserTicket1(requestParameters, options) {
        return ChatTicketsApiFp(this.configuration).retrieveUserTicket1(requestParameters.userAgent, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CheckoutSessionsApi - axios parameter creator
 * @export
 */
export const CheckoutSessionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CheckoutSessionDto} checkoutSessionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession2: async (checkoutSessionDto, options = {}) => {
            // verify required parameter 'checkoutSessionDto' is not null or undefined
            assertParamExists('createCheckoutSession2', 'checkoutSessionDto', checkoutSessionDto);
            const localVarPath = `/checkout-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(checkoutSessionDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CheckoutSessionsApi - functional programming interface
 * @export
 */
export const CheckoutSessionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = CheckoutSessionsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CheckoutSessionDto} checkoutSessionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSession2(checkoutSessionDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSession2(checkoutSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CheckoutSessionsApi.createCheckoutSession2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * CheckoutSessionsApi - factory interface
 * @export
 */
export const CheckoutSessionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CheckoutSessionsApiFp(configuration);
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CheckoutSessionsApiCreateCheckoutSession2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession2(requestParameters, options) {
            return localVarFp.createCheckoutSession2(requestParameters.checkoutSessionDto, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CheckoutSessionsApi - object-oriented interface
 * @export
 * @class CheckoutSessionsApi
 * @extends {BaseAPI}
 */
export class CheckoutSessionsApi extends BaseAPI {
    /**
     *
     * @summary Create checkout-session
     * @param {CheckoutSessionsApiCreateCheckoutSession2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckoutSessionsApi
     */
    createCheckoutSession2(requestParameters, options) {
        return CheckoutSessionsApiFp(this.configuration).createCheckoutSession2(requestParameters.checkoutSessionDto, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries2: async (options = {}) => {
            const localVarPath = `/countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Method to find a country by the caller IP
         * @param {string} [xForwardedFor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByIp1: async (xForwardedFor, options = {}) => {
            const localVarPath = `/countries/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (xForwardedFor != null) {
                localVarHeaderParameter['X-Forwarded-For'] = String(xForwardedFor);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function (configuration) {
    const localVarAxiosParamCreator = CountriesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCountries2(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCountries2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getAllCountries2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Method to find a country by the caller IP
         * @param {string} [xForwardedFor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountryByIp1(xForwardedFor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountryByIp1(xForwardedFor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CountriesApi.getCountryByIp1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CountriesApiFp(configuration);
    return {
        /**
         *
         * @summary Method to find all the countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries2(options) {
            return localVarFp.getAllCountries2(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Method to find a country by the caller IP
         * @param {CountriesApiGetCountryByIp1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountryByIp1(requestParameters = {}, options) {
            return localVarFp.getCountryByIp1(requestParameters.xForwardedFor, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     *
     * @summary Method to find all the countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    getAllCountries2(options) {
        return CountriesApiFp(this.configuration).getAllCountries2(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Method to find a country by the caller IP
     * @param {CountriesApiGetCountryByIp1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    getCountryByIp1(requestParameters = {}, options) {
        return CountriesApiFp(this.configuration).getCountryByIp1(requestParameters.xForwardedFor, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CurrencyManagementApi - axios parameter creator
 * @export
 */
export const CurrencyManagementApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies1: async (options = {}) => {
            const localVarPath = `/currencies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CurrencyManagementApi - functional programming interface
 * @export
 */
export const CurrencyManagementApiFp = function (configuration) {
    const localVarAxiosParamCreator = CurrencyManagementApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencies1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrencies1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CurrencyManagementApi.getCurrencies1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * CurrencyManagementApi - factory interface
 * @export
 */
export const CurrencyManagementApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CurrencyManagementApiFp(configuration);
    return {
        /**
         *
         * @summary Retrieves the list of all exchange available in application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies1(options) {
            return localVarFp.getCurrencies1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CurrencyManagementApi - object-oriented interface
 * @export
 * @class CurrencyManagementApi
 * @extends {BaseAPI}
 */
export class CurrencyManagementApi extends BaseAPI {
    /**
     *
     * @summary Retrieves the list of all exchange available in application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyManagementApi
     */
    getCurrencies1(options) {
        return CurrencyManagementApiFp(this.configuration).getCurrencies1(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CustomerSessionsApi - axios parameter creator
 * @export
 */
export const CustomerSessionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CustomerSessionDto} customerSessionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession: async (customerSessionDto, options = {}) => {
            // verify required parameter 'customerSessionDto' is not null or undefined
            assertParamExists('createCheckoutSession', 'customerSessionDto', customerSessionDto);
            const localVarPath = `/customer-sessions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(customerSessionDto, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * CustomerSessionsApi - functional programming interface
 * @export
 */
export const CustomerSessionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = CustomerSessionsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CustomerSessionDto} customerSessionDto
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCheckoutSession(customerSessionDto, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCheckoutSession(customerSessionDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerSessionsApi.createCheckoutSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * CustomerSessionsApi - factory interface
 * @export
 */
export const CustomerSessionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CustomerSessionsApiFp(configuration);
    return {
        /**
         *
         * @summary Create checkout-session
         * @param {CustomerSessionsApiCreateCheckoutSessionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCheckoutSession(requestParameters, options) {
            return localVarFp.createCheckoutSession(requestParameters.customerSessionDto, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CustomerSessionsApi - object-oriented interface
 * @export
 * @class CustomerSessionsApi
 * @extends {BaseAPI}
 */
export class CustomerSessionsApi extends BaseAPI {
    /**
     *
     * @summary Create checkout-session
     * @param {CustomerSessionsApiCreateCheckoutSessionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerSessionsApi
     */
    createCheckoutSession(requestParameters, options) {
        return CustomerSessionsApiFp(this.configuration).createCheckoutSession(requestParameters.customerSessionDto, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * EndorsementsApi - axios parameter creator
 * @export
 */
export const EndorsementsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {number} userId ID of the user to get endorsements for
         * @param {number} [endorser] Optional endorser ID to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEndorsementsByUser1: async (userId, endorser, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveEndorsementsByUser1', 'userId', userId);
            const localVarPath = `/users/{userId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (endorser !== undefined) {
                localVarQueryParameter['endorser'] = endorser;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * EndorsementsApi - functional programming interface
 * @export
 */
export const EndorsementsApiFp = function (configuration) {
    const localVarAxiosParamCreator = EndorsementsApiAxiosParamCreator(configuration);
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {number} userId ID of the user to get endorsements for
         * @param {number} [endorser] Optional endorser ID to filter results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveEndorsementsByUser1(userId, endorser, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveEndorsementsByUser1(userId, endorser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EndorsementsApi.retrieveEndorsementsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * EndorsementsApi - factory interface
 * @export
 */
export const EndorsementsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = EndorsementsApiFp(configuration);
    return {
        /**
         * Gets all endorsements for a specified user. Can be filtered by endorser ID.
         * @summary Retrieve endorsements for a user
         * @param {EndorsementsApiRetrieveEndorsementsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEndorsementsByUser1(requestParameters, options) {
            return localVarFp.retrieveEndorsementsByUser1(requestParameters.userId, requestParameters.endorser, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * EndorsementsApi - object-oriented interface
 * @export
 * @class EndorsementsApi
 * @extends {BaseAPI}
 */
export class EndorsementsApi extends BaseAPI {
    /**
     * Gets all endorsements for a specified user. Can be filtered by endorser ID.
     * @summary Retrieve endorsements for a user
     * @param {EndorsementsApiRetrieveEndorsementsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndorsementsApi
     */
    retrieveEndorsementsByUser1(requestParameters, options) {
        return EndorsementsApiFp(this.configuration).retrieveEndorsementsByUser1(requestParameters.userId, requestParameters.endorser, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ExchangeRatesApi - axios parameter creator
 * @export
 */
export const ExchangeRatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExchangeRates1: async (options = {}) => {
            const localVarPath = `/exchange-rates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ExchangeRatesApi - functional programming interface
 * @export
 */
export const ExchangeRatesApiFp = function (configuration) {
    const localVarAxiosParamCreator = ExchangeRatesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findExchangeRates1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findExchangeRates1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeRatesApi.findExchangeRates1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * ExchangeRatesApi - factory interface
 * @export
 */
export const ExchangeRatesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ExchangeRatesApiFp(configuration);
    return {
        /**
         * Returns a map of currency exchange rates between different currencies
         * @summary Method to find all the exchange rates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findExchangeRates1(options) {
            return localVarFp.findExchangeRates1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ExchangeRatesApi - object-oriented interface
 * @export
 * @class ExchangeRatesApi
 * @extends {BaseAPI}
 */
export class ExchangeRatesApi extends BaseAPI {
    /**
     * Returns a map of currency exchange rates between different currencies
     * @summary Method to find all the exchange rates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeRatesApi
     */
    findExchangeRates1(options) {
        return ExchangeRatesApiFp(this.configuration).findExchangeRates1(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * FacebookPropertiesApi - axios parameter creator
 * @export
 */
export const FacebookPropertiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {string} startDate Start date for property export (ISO format)
         * @param {string} endDate End date for property export (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties: async (startDate, endDate, options = {}) => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('uploadKyeroProperties', 'startDate', startDate);
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('uploadKyeroProperties', 'endDate', endDate);
            const localVarPath = `/facebook-properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['start-date'] = (startDate instanceof Date) ?
                    startDate.toISOString().substring(0, 10) :
                    startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['end-date'] = (endDate instanceof Date) ?
                    endDate.toISOString().substring(0, 10) :
                    endDate;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FacebookPropertiesApi - functional programming interface
 * @export
 */
export const FacebookPropertiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = FacebookPropertiesApiAxiosParamCreator(configuration);
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {string} startDate Start date for property export (ISO format)
         * @param {string} endDate End date for property export (ISO format)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroProperties(startDate, endDate, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroProperties(startDate, endDate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FacebookPropertiesApi.uploadKyeroProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * FacebookPropertiesApi - factory interface
 * @export
 */
export const FacebookPropertiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = FacebookPropertiesApiFp(configuration);
    return {
        /**
         * Exports property data to Facebook Marketplace format within the specified date range
         * @summary Export properties to Facebook Marketplace
         * @param {FacebookPropertiesApiUploadKyeroPropertiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties(requestParameters, options) {
            return localVarFp.uploadKyeroProperties(requestParameters.startDate, requestParameters.endDate, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FacebookPropertiesApi - object-oriented interface
 * @export
 * @class FacebookPropertiesApi
 * @extends {BaseAPI}
 */
export class FacebookPropertiesApi extends BaseAPI {
    /**
     * Exports property data to Facebook Marketplace format within the specified date range
     * @summary Export properties to Facebook Marketplace
     * @param {FacebookPropertiesApiUploadKyeroPropertiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FacebookPropertiesApi
     */
    uploadKyeroProperties(requestParameters, options) {
        return FacebookPropertiesApiFp(this.configuration).uploadKyeroProperties(requestParameters.startDate, requestParameters.endDate, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * FavoritesApi - axios parameter creator
 * @export
 */
export const FavoritesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {number} userId ID of the user
         * @param {boolean} [includeResource] Whether to include the associated resource details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser: async (userId, includeResource, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getByUser', 'userId', userId);
            const localVarPath = `/users/{userId}/favorites`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (includeResource !== undefined) {
                localVarQueryParameter['includeResource'] = includeResource;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {number} userId ID of the user
         * @param {Favorite} favorite Favorite to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserFavorite1: async (userId, favorite, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('postUserFavorite1', 'userId', userId);
            // verify required parameter 'favorite' is not null or undefined
            assertParamExists('postUserFavorite1', 'favorite', favorite);
            const localVarPath = `/users/{userId}/favorites`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(favorite, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {number} userId ID of the user
         * @param {number} favoriteId ID of the favorite to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFavorite1: async (userId, favoriteId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('removeUserFavorite1', 'userId', userId);
            // verify required parameter 'favoriteId' is not null or undefined
            assertParamExists('removeUserFavorite1', 'favoriteId', favoriteId);
            const localVarPath = `/users/{userId}/favorites/{favoriteId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"favoriteId"}}`, encodeURIComponent(String(favoriteId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FavoritesApi - functional programming interface
 * @export
 */
export const FavoritesApiFp = function (configuration) {
    const localVarAxiosParamCreator = FavoritesApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {number} userId ID of the user
         * @param {boolean} [includeResource] Whether to include the associated resource details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUser(userId, includeResource, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUser(userId, includeResource, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoritesApi.getByUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {number} userId ID of the user
         * @param {Favorite} favorite Favorite to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserFavorite1(userId, favorite, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserFavorite1(userId, favorite, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoritesApi.postUserFavorite1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {number} userId ID of the user
         * @param {number} favoriteId ID of the favorite to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserFavorite1(userId, favoriteId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserFavorite1(userId, favoriteId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FavoritesApi.removeUserFavorite1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * FavoritesApi - factory interface
 * @export
 */
export const FavoritesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = FavoritesApiFp(configuration);
    return {
        /**
         * Retrieves all favorites for a specific user
         * @summary Get user favorites
         * @param {FavoritesApiGetByUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUser(requestParameters, options) {
            return localVarFp.getByUser(requestParameters.userId, requestParameters.includeResource, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a new favorite item for a specific user
         * @summary Add a favorite
         * @param {FavoritesApiPostUserFavorite1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserFavorite1(requestParameters, options) {
            return localVarFp.postUserFavorite1(requestParameters.userId, requestParameters.favorite, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a specific favorite from a user\'s favorites list
         * @summary Remove a favorite
         * @param {FavoritesApiRemoveUserFavorite1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserFavorite1(requestParameters, options) {
            return localVarFp.removeUserFavorite1(requestParameters.userId, requestParameters.favoriteId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FavoritesApi - object-oriented interface
 * @export
 * @class FavoritesApi
 * @extends {BaseAPI}
 */
export class FavoritesApi extends BaseAPI {
    /**
     * Retrieves all favorites for a specific user
     * @summary Get user favorites
     * @param {FavoritesApiGetByUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    getByUser(requestParameters, options) {
        return FavoritesApiFp(this.configuration).getByUser(requestParameters.userId, requestParameters.includeResource, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Adds a new favorite item for a specific user
     * @summary Add a favorite
     * @param {FavoritesApiPostUserFavorite1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    postUserFavorite1(requestParameters, options) {
        return FavoritesApiFp(this.configuration).postUserFavorite1(requestParameters.userId, requestParameters.favorite, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes a specific favorite from a user\'s favorites list
     * @summary Remove a favorite
     * @param {FavoritesApiRemoveUserFavorite1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FavoritesApi
     */
    removeUserFavorite1(requestParameters, options) {
        return FavoritesApiFp(this.configuration).removeUserFavorite1(requestParameters.userId, requestParameters.favoriteId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * GeoLocationApi - axios parameter creator
 * @export
 */
export const GeoLocationApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {string} [latlng] Comma-separated latitude and longitude coordinates
         * @param {string} [address] Text representation of an address to geocode
         * @param {string} [countryCode] ISO country code to restrict the address search
         * @param {string} [autoCompleteText] Text to use for location auto-completion suggestions
         * @param {number} [radius] Search radius in meters for location suggestions (used with latlng and autoCompleteText)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeoLocationsByLatLng1: async (latlng, address, countryCode, autoCompleteText, radius, options = {}) => {
            const localVarPath = `/geo-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (latlng !== undefined) {
                localVarQueryParameter['latlng'] = latlng;
            }
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (countryCode !== undefined) {
                localVarQueryParameter['countryCode'] = countryCode;
            }
            if (autoCompleteText !== undefined) {
                localVarQueryParameter['autoCompleteText'] = autoCompleteText;
            }
            if (radius !== undefined) {
                localVarQueryParameter['radius'] = radius;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * GeoLocationApi - functional programming interface
 * @export
 */
export const GeoLocationApiFp = function (configuration) {
    const localVarAxiosParamCreator = GeoLocationApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {string} [latlng] Comma-separated latitude and longitude coordinates
         * @param {string} [address] Text representation of an address to geocode
         * @param {string} [countryCode] ISO country code to restrict the address search
         * @param {string} [autoCompleteText] Text to use for location auto-completion suggestions
         * @param {number} [radius] Search radius in meters for location suggestions (used with latlng and autoCompleteText)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGeoLocationsByLatLng1(latlng, address, countryCode, autoCompleteText, radius, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGeoLocationsByLatLng1(latlng, address, countryCode, autoCompleteText, radius, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GeoLocationApi.getGeoLocationsByLatLng1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * GeoLocationApi - factory interface
 * @export
 */
export const GeoLocationApiFactory = function (configuration, basePath, axios) {
    const localVarFp = GeoLocationApiFp(configuration);
    return {
        /**
         * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
         * @summary Retrieves geolocation information
         * @param {GeoLocationApiGetGeoLocationsByLatLng1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGeoLocationsByLatLng1(requestParameters = {}, options) {
            return localVarFp.getGeoLocationsByLatLng1(requestParameters.latlng, requestParameters.address, requestParameters.countryCode, requestParameters.autoCompleteText, requestParameters.radius, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * GeoLocationApi - object-oriented interface
 * @export
 * @class GeoLocationApi
 * @extends {BaseAPI}
 */
export class GeoLocationApi extends BaseAPI {
    /**
     * Retrieves geolocation information based on various search criteria including coordinates, address text, or auto-complete suggestions
     * @summary Retrieves geolocation information
     * @param {GeoLocationApiGetGeoLocationsByLatLng1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeoLocationApi
     */
    getGeoLocationsByLatLng1(requestParameters = {}, options) {
        return GeoLocationApiFp(this.configuration).getGeoLocationsByLatLng1(requestParameters.latlng, requestParameters.address, requestParameters.countryCode, requestParameters.autoCompleteText, requestParameters.radius, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveGroup1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('archiveGroup1', 'id', id);
            const localVarPath = `/groups/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateGroup1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deactivateGroup1', 'id', id);
            const localVarPath = `/groups/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteGroup1', 'id', id);
            const localVarPath = `/groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has archived
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findArchivedGroupsByUser1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/groups/archived`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup1: async (groupId, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('findGroup1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupProperties1: async (groupId, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('findGroupProperties1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/properties`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {PropertyFilterCriteria} [propertyFilterCriteria] filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupPropertiesSearch1: async (groupId, propertyFilterCriteria, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('findGroupPropertiesSearch1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/properties/search`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(propertyFilterCriteria, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This will return both owned Groups and Groups the user is a member of
         * @summary Return the groups list with specified user id
         * @param {number} [pageFrom] Start page number
         * @param {number} [pageTo] End page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupsByUser1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the groups list with specified user id that are inactive
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInactiveGroupsByUser1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/groups/inactive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has invitations of
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvitedGroupsByUser1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/groups/invited`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has requested
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRequestedGroupsByUser1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/groups/requested`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {string} groupId group id
         * @param {number} [pageFrom] Starting page index (zero-based)
         * @param {number} [pageTo] Ending page index (zero-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers1: async (groupId, pageFrom, pageTo, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupMembers1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/members`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Request Invitation to Group
         * @param {string} groupId group id
         * @param {Array<number>} [userIds] List of user IDs to invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite: async (groupId, userIds, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupInvite', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/invite`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Accept Group Invitation
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite2: async (groupId, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupInvite2', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/accept-invite`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Leave Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupLeave1: async (groupId, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupLeave1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/leave`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Request Admission to Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRequest1: async (groupId, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupRequest1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/request`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {Group} [group] group to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroup1: async (group, options = {}) => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to update status
         * @param {UpdateGroupMembershipStatus1StatusEnum} [status] New status for the members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMembershipStatus1: async (groupId, userIds, status, options = {}) => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupMembershipStatus1', 'groupId', groupId);
            const localVarPath = `/groups/{groupId}/member-status`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (userIds) {
                localVarQueryParameter['userIds'] = userIds;
            }
            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function (configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration);
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveGroup1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveGroup1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.archiveGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateGroup1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateGroup1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deactivateGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {string} id groupId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroup1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroup1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has archived
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findArchivedGroupsByUser1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findArchivedGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findArchivedGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroup1(groupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroup1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupProperties1(groupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupProperties1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroupProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {string} groupId group id
         * @param {PropertyFilterCriteria} [propertyFilterCriteria] filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupPropertiesSearch1(groupId, propertyFilterCriteria, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupPropertiesSearch1(groupId, propertyFilterCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroupPropertiesSearch1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This will return both owned Groups and Groups the user is a member of
         * @summary Return the groups list with specified user id
         * @param {number} [pageFrom] Start page number
         * @param {number} [pageTo] End page number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findGroupsByUser1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the groups list with specified user id that are inactive
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInactiveGroupsByUser1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInactiveGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findInactiveGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has invitations of
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findInvitedGroupsByUser1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findInvitedGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findInvitedGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has requested
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findRequestedGroupsByUser1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findRequestedGroupsByUser1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.findRequestedGroupsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {string} groupId group id
         * @param {number} [pageFrom] Starting page index (zero-based)
         * @param {number} [pageTo] Ending page index (zero-based)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupMembers1(groupId, pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupMembers1(groupId, pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupMembers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Request Invitation to Group
         * @param {string} groupId group id
         * @param {Array<number>} [userIds] List of user IDs to invite
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupInvite(groupId, userIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupInvite(groupId, userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupInvite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Accept Group Invitation
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupInvite2(groupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupInvite2(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupInvite2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Leave Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupLeave1(groupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupLeave1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupLeave1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Request Admission to Group
         * @param {string} groupId group id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupRequest1(groupId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupRequest1(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.groupRequest1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {Group} [group] group to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveGroup1(group, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveGroup1(group, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.saveGroup1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {string} groupId groupId
         * @param {Array<number>} [userIds] List of user IDs to update status
         * @param {UpdateGroupMembershipStatus1StatusEnum} [status] New status for the members
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupMembershipStatus1(groupId, userIds, status, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupMembershipStatus1(groupId, userIds, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.updateGroupMembershipStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = GroupsApiFp(configuration);
    return {
        /**
         * This process is reversible
         * @summary Archive the group with id supplied
         * @param {GroupsApiArchiveGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveGroup1(requestParameters, options) {
            return localVarFp.archiveGroup1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is reversible
         * @summary Deactivate the group with id supplied
         * @param {GroupsApiDeactivateGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateGroup1(requestParameters, options) {
            return localVarFp.deactivateGroup1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is not reversible
         * @summary Delete the group with id supplied
         * @param {GroupsApiDeleteGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroup1(requestParameters, options) {
            return localVarFp.deleteGroup1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has archived
         * @param {GroupsApiFindArchivedGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findArchivedGroupsByUser1(requestParameters = {}, options) {
            return localVarFp.findArchivedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {GroupsApiFindGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroup1(requestParameters, options) {
            return localVarFp.findGroup1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {GroupsApiFindGroupProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupProperties1(requestParameters, options) {
            return localVarFp.findGroupProperties1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
         * @summary Return the group with specified id
         * @param {GroupsApiFindGroupPropertiesSearch1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupPropertiesSearch1(requestParameters, options) {
            return localVarFp.findGroupPropertiesSearch1(requestParameters.groupId, requestParameters.propertyFilterCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         * This will return both owned Groups and Groups the user is a member of
         * @summary Return the groups list with specified user id
         * @param {GroupsApiFindGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findGroupsByUser1(requestParameters = {}, options) {
            return localVarFp.findGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the groups list with specified user id that are inactive
         * @param {GroupsApiFindInactiveGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInactiveGroupsByUser1(requestParameters = {}, options) {
            return localVarFp.findInactiveGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has invitations of
         * @param {GroupsApiFindInvitedGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findInvitedGroupsByUser1(requestParameters = {}, options) {
            return localVarFp.findInvitedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the groups list with specified user id that user has requested
         * @param {GroupsApiFindRequestedGroupsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findRequestedGroupsByUser1(requestParameters = {}, options) {
            return localVarFp.findRequestedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * For Group Owners, this list will return removed, left, invited and requested members as well
         * @summary Show all members of Group
         * @param {GroupsApiGetGroupMembers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupMembers1(requestParameters, options) {
            return localVarFp.getGroupMembers1(requestParameters.groupId, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Request Invitation to Group
         * @param {GroupsApiGroupInviteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite(requestParameters, options) {
            return localVarFp.groupInvite(requestParameters.groupId, requestParameters.userIds, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Accept Group Invitation
         * @param {GroupsApiGroupInvite2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupInvite2(requestParameters, options) {
            return localVarFp.groupInvite2(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Leave Group
         * @param {GroupsApiGroupLeave1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupLeave1(requestParameters, options) {
            return localVarFp.groupLeave1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Request Admission to Group
         * @param {GroupsApiGroupRequest1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupRequest1(requestParameters, options) {
            return localVarFp.groupRequest1(requestParameters.groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can saveNew its groups
         * @summary Create or update the group supplied
         * @param {GroupsApiSaveGroup1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveGroup1(requestParameters = {}, options) {
            return localVarFp.saveGroup1(requestParameters.group, options).then((request) => request(axios, basePath));
        },
        /**
         * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
         * @summary Update the group member status from groupId supplied
         * @param {GroupsApiUpdateGroupMembershipStatus1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupMembershipStatus1(requestParameters, options) {
            return localVarFp.updateGroupMembershipStatus1(requestParameters.groupId, requestParameters.userIds, requestParameters.status, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * This process is reversible
     * @summary Archive the group with id supplied
     * @param {GroupsApiArchiveGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    archiveGroup1(requestParameters, options) {
        return GroupsApiFp(this.configuration).archiveGroup1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This process is reversible
     * @summary Deactivate the group with id supplied
     * @param {GroupsApiDeactivateGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deactivateGroup1(requestParameters, options) {
        return GroupsApiFp(this.configuration).deactivateGroup1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This process is not reversible
     * @summary Delete the group with id supplied
     * @param {GroupsApiDeleteGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    deleteGroup1(requestParameters, options) {
        return GroupsApiFp(this.configuration).deleteGroup1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the groups list with specified user id that user has archived
     * @param {GroupsApiFindArchivedGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findArchivedGroupsByUser1(requestParameters = {}, options) {
        return GroupsApiFp(this.configuration).findArchivedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {GroupsApiFindGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findGroup1(requestParameters, options) {
        return GroupsApiFp(this.configuration).findGroup1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {GroupsApiFindGroupProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findGroupProperties1(requestParameters, options) {
        return GroupsApiFp(this.configuration).findGroupProperties1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter the groups existing in system with specified id. Returns empty if none group match the id and user is not member/owner of it
     * @summary Return the group with specified id
     * @param {GroupsApiFindGroupPropertiesSearch1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findGroupPropertiesSearch1(requestParameters, options) {
        return GroupsApiFp(this.configuration).findGroupPropertiesSearch1(requestParameters.groupId, requestParameters.propertyFilterCriteria, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This will return both owned Groups and Groups the user is a member of
     * @summary Return the groups list with specified user id
     * @param {GroupsApiFindGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findGroupsByUser1(requestParameters = {}, options) {
        return GroupsApiFp(this.configuration).findGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the groups list with specified user id that are inactive
     * @param {GroupsApiFindInactiveGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findInactiveGroupsByUser1(requestParameters = {}, options) {
        return GroupsApiFp(this.configuration).findInactiveGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the groups list with specified user id that user has invitations of
     * @param {GroupsApiFindInvitedGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findInvitedGroupsByUser1(requestParameters = {}, options) {
        return GroupsApiFp(this.configuration).findInvitedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the groups list with specified user id that user has requested
     * @param {GroupsApiFindRequestedGroupsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    findRequestedGroupsByUser1(requestParameters = {}, options) {
        return GroupsApiFp(this.configuration).findRequestedGroupsByUser1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * For Group Owners, this list will return removed, left, invited and requested members as well
     * @summary Show all members of Group
     * @param {GroupsApiGetGroupMembers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    getGroupMembers1(requestParameters, options) {
        return GroupsApiFp(this.configuration).getGroupMembers1(requestParameters.groupId, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Request Invitation to Group
     * @param {GroupsApiGroupInviteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupInvite(requestParameters, options) {
        return GroupsApiFp(this.configuration).groupInvite(requestParameters.groupId, requestParameters.userIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Accept Group Invitation
     * @param {GroupsApiGroupInvite2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupInvite2(requestParameters, options) {
        return GroupsApiFp(this.configuration).groupInvite2(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Leave Group
     * @param {GroupsApiGroupLeave1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupLeave1(requestParameters, options) {
        return GroupsApiFp(this.configuration).groupLeave1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Request Admission to Group
     * @param {GroupsApiGroupRequest1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    groupRequest1(requestParameters, options) {
        return GroupsApiFp(this.configuration).groupRequest1(requestParameters.groupId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Consider that only user can saveNew its groups
     * @summary Create or update the group supplied
     * @param {GroupsApiSaveGroup1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    saveGroup1(requestParameters = {}, options) {
        return GroupsApiFp(this.configuration).saveGroup1(requestParameters.group, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Acceptable Status values are:  ACCEPTED, REJECTED, REMOVED
     * @summary Update the group member status from groupId supplied
     * @param {GroupsApiUpdateGroupMembershipStatus1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    updateGroupMembershipStatus1(requestParameters, options) {
        return GroupsApiFp(this.configuration).updateGroupMembershipStatus1(requestParameters.groupId, requestParameters.userIds, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * @export
 */
export const UpdateGroupMembershipStatus1StatusEnum = {
    Accepted: 'ACCEPTED',
    Rejected: 'REJECTED',
    Removed: 'REMOVED'
};
/**
 * LanguagesApi - axios parameter creator
 * @export
 */
export const LanguagesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {string} [xForwardedFor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages1: async (xForwardedFor, options = {}) => {
            const localVarPath = `/languages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (xForwardedFor != null) {
                localVarHeaderParameter['X-Forwarded-For'] = String(xForwardedFor);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LanguagesApi - functional programming interface
 * @export
 */
export const LanguagesApiFp = function (configuration) {
    const localVarAxiosParamCreator = LanguagesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {string} [xForwardedFor]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllLanguages1(xForwardedFor, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllLanguages1(xForwardedFor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LanguagesApi.getAllLanguages1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * LanguagesApi - factory interface
 * @export
 */
export const LanguagesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = LanguagesApiFp(configuration);
    return {
        /**
         * Returns a list of all supported languages in the system
         * @summary Get all available languages
         * @param {LanguagesApiGetAllLanguages1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages1(requestParameters = {}, options) {
            return localVarFp.getAllLanguages1(requestParameters.xForwardedFor, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * LanguagesApi - object-oriented interface
 * @export
 * @class LanguagesApi
 * @extends {BaseAPI}
 */
export class LanguagesApi extends BaseAPI {
    /**
     * Returns a list of all supported languages in the system
     * @summary Get all available languages
     * @param {LanguagesApiGetAllLanguages1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguagesApi
     */
    getAllLanguages1(requestParameters = {}, options) {
        return LanguagesApiFp(this.configuration).getAllLanguages1(requestParameters.xForwardedFor, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * LocalesApi - axios parameter creator
 * @export
 */
export const LocalesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {string} pnemonic
         * @param {string} [securityKey]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (pnemonic, securityKey, options = {}) => {
            // verify required parameter 'pnemonic' is not null or undefined
            assertParamExists('delete1', 'pnemonic', pnemonic);
            const localVarPath = `/locales/{pnemonic}`
                .replace(`{${"pnemonic"}}`, encodeURIComponent(String(pnemonic)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (securityKey != null) {
                localVarHeaderParameter['security-key'] = String(securityKey);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find3: async (options = {}) => {
            const localVarPath = `/locales`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {string} [lang]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages1: async (lang, options = {}) => {
            const localVarPath = `/locales/translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * LocalesApi - functional programming interface
 * @export
 */
export const LocalesApiFp = function (configuration) {
    const localVarAxiosParamCreator = LocalesApiAxiosParamCreator(configuration);
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {string} pnemonic
         * @param {string} [securityKey]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(pnemonic, securityKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(pnemonic, securityKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalesApi.delete1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find3(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find3(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalesApi.find3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {string} [lang]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLanguages1(lang, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLanguages1(lang, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LocalesApi.getLanguages1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * LocalesApi - factory interface
 * @export
 */
export const LocalesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = LocalesApiFp(configuration);
    return {
        /**
         * Removes a locale entry identified by its pnemonic code along with all its translations
         * @summary Delete a locale entry with all translations related
         * @param {LocalesApiDelete1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(requestParameters, options) {
            return localVarFp.delete1(requestParameters.pnemonic, requestParameters.securityKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the complete list of available locales in the system
         * @summary Returns all language list locale entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find3(options) {
            return localVarFp.find3(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the locale translations in the specified language
         * @summary Returns locale language list
         * @param {LocalesApiGetLanguages1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLanguages1(requestParameters = {}, options) {
            return localVarFp.getLanguages1(requestParameters.lang, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * LocalesApi - object-oriented interface
 * @export
 * @class LocalesApi
 * @extends {BaseAPI}
 */
export class LocalesApi extends BaseAPI {
    /**
     * Removes a locale entry identified by its pnemonic code along with all its translations
     * @summary Delete a locale entry with all translations related
     * @param {LocalesApiDelete1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    delete1(requestParameters, options) {
        return LocalesApiFp(this.configuration).delete1(requestParameters.pnemonic, requestParameters.securityKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the complete list of available locales in the system
     * @summary Returns all language list locale entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    find3(options) {
        return LocalesApiFp(this.configuration).find3(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the locale translations in the specified language
     * @summary Returns locale language list
     * @param {LocalesApiGetLanguages1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalesApi
     */
    getLanguages1(requestParameters = {}, options) {
        return LocalesApiFp(this.configuration).getLanguages1(requestParameters.lang, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * MessagesApi - axios parameter creator
 * @export
 */
export const MessagesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
         * @summary Get user notifications by type
         * @param {string} token Authentication token
         * @param {GetByUserWithResult1TypeEnum} type Notification type
         * @param {AutopilotUser} autopilotUser User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserWithResult1: async (token, type, autopilotUser, options = {}) => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getByUserWithResult1', 'token', token);
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getByUserWithResult1', 'type', type);
            // verify required parameter 'autopilotUser' is not null or undefined
            assertParamExists('getByUserWithResult1', 'autopilotUser', autopilotUser);
            const localVarPath = `/notifications/{type}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(autopilotUser, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get a message by conversation
         * @param {number} [userAId] User A Id
         * @param {number} [userBId] User B Id
         * @param {number} [limit] limit results
         * @param {LocalDateTimeQueryString} [beforeDatetime] return results before date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation1: async (userAId, userBId, limit, beforeDatetime, options = {}) => {
            const localVarPath = `/chat/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (userAId !== undefined) {
                localVarQueryParameter['userAId'] = userAId;
            }
            if (userBId !== undefined) {
                localVarQueryParameter['userBId'] = userBId;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (beforeDatetime !== undefined) {
                for (const [key, value] of Object.entries(beforeDatetime)) {
                    localVarQueryParameter[key] = value;
                }
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a user chat
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUser1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveChatUser1', 'id', id);
            const localVarPath = `/chat/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Retrieve a user chat status
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUserStatus1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveChatUserStatus1', 'id', id);
            const localVarPath = `/chat/user/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Post a message
         * @param {Message} [message] message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage1: async (message, options = {}) => {
            const localVarPath = `/chat/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(message, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MessagesApi - functional programming interface
 * @export
 */
export const MessagesApiFp = function (configuration) {
    const localVarAxiosParamCreator = MessagesApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
         * @summary Get user notifications by type
         * @param {string} token Authentication token
         * @param {GetByUserWithResult1TypeEnum} type Notification type
         * @param {AutopilotUser} autopilotUser User information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByUserWithResult1(token, type, autopilotUser, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByUserWithResult1(token, type, autopilotUser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.getByUserWithResult1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get a message by conversation
         * @param {number} [userAId] User A Id
         * @param {number} [userBId] User B Id
         * @param {number} [limit] limit results
         * @param {LocalDateTimeQueryString} [beforeDatetime] return results before date time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversation1(userAId, userBId, limit, beforeDatetime, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversation1(userAId, userBId, limit, beforeDatetime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.getConversation1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Retrieve a user chat
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveChatUser1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveChatUser1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.retrieveChatUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Retrieve a user chat status
         * @param {number} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveChatUserStatus1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveChatUserStatus1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.retrieveChatUserStatus1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Post a message
         * @param {Message} [message] message
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage1(message, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage1(message, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MessagesApi.sendMessage1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * MessagesApi - factory interface
 * @export
 */
export const MessagesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MessagesApiFp(configuration);
    return {
        /**
         * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
         * @summary Get user notifications by type
         * @param {MessagesApiGetByUserWithResult1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByUserWithResult1(requestParameters, options) {
            return localVarFp.getByUserWithResult1(requestParameters.token, requestParameters.type, requestParameters.autopilotUser, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a message by conversation
         * @param {MessagesApiGetConversation1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation1(requestParameters = {}, options) {
            return localVarFp.getConversation1(requestParameters.userAId, requestParameters.userBId, requestParameters.limit, requestParameters.beforeDatetime, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a user chat
         * @param {MessagesApiRetrieveChatUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUser1(requestParameters, options) {
            return localVarFp.retrieveChatUser1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a user chat status
         * @param {MessagesApiRetrieveChatUserStatus1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChatUserStatus1(requestParameters, options) {
            return localVarFp.retrieveChatUserStatus1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Post a message
         * @param {MessagesApiSendMessage1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage1(requestParameters = {}, options) {
            return localVarFp.sendMessage1(requestParameters.message, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MessagesApi - object-oriented interface
 * @export
 * @class MessagesApi
 * @extends {BaseAPI}
 */
export class MessagesApi extends BaseAPI {
    /**
     * Retrieves notifications for a specific user and notification type. Designed for autopilot integration.
     * @summary Get user notifications by type
     * @param {MessagesApiGetByUserWithResult1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    getByUserWithResult1(requestParameters, options) {
        return MessagesApiFp(this.configuration).getByUserWithResult1(requestParameters.token, requestParameters.type, requestParameters.autopilotUser, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a message by conversation
     * @param {MessagesApiGetConversation1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    getConversation1(requestParameters = {}, options) {
        return MessagesApiFp(this.configuration).getConversation1(requestParameters.userAId, requestParameters.userBId, requestParameters.limit, requestParameters.beforeDatetime, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a user chat
     * @param {MessagesApiRetrieveChatUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    retrieveChatUser1(requestParameters, options) {
        return MessagesApiFp(this.configuration).retrieveChatUser1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a user chat status
     * @param {MessagesApiRetrieveChatUserStatus1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    retrieveChatUserStatus1(requestParameters, options) {
        return MessagesApiFp(this.configuration).retrieveChatUserStatus1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Post a message
     * @param {MessagesApiSendMessage1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessagesApi
     */
    sendMessage1(requestParameters = {}, options) {
        return MessagesApiFp(this.configuration).sendMessage1(requestParameters.message, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * @export
 */
export const GetByUserWithResult1TypeEnum = {
    ToBrokerAlertCreated: 'TO_BROKER__ALERT_CREATED',
    ToUserWeeklyProperties: 'TO_USER__WEEKLY_PROPERTIES',
    ToUserWeeklyPayedSubscribers: 'TO_USER__WEEKLY_PAYED_SUBSCRIBERS',
    ToUserCustomizedAlert: 'TO_USER__CUSTOMIZED_ALERT',
    ToUserWeeklyGroupProperties: 'TO_USER__WEEKLY_GROUP_PROPERTIES',
    ToUserNewsletterNewSubscriber: 'TO_USER__NEWSLETTER_NEW_SUBSCRIBER',
    ToUserNewsletterConfirmation: 'TO_USER__NEWSLETTER_CONFIRMATION',
    ToUserNewsletterListing: 'TO_USER__NEWSLETTER_LISTING'
};
/**
 * PasswordRecoveryApi - axios parameter creator
 * @export
 */
export const PasswordRecoveryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {string} [origin]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail1: async (origin, options = {}) => {
            const localVarPath = `/password_recovery/send_email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryRequest} [passwordRecoveryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword1: async (passwordRecoveryRequest, options = {}) => {
            const localVarPath = `/password_recovery/update_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(passwordRecoveryRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken1: async (options = {}) => {
            const localVarPath = `/password_recovery/validate_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PasswordRecoveryApi - functional programming interface
 * @export
 */
export const PasswordRecoveryApiFp = function (configuration) {
    const localVarAxiosParamCreator = PasswordRecoveryApiAxiosParamCreator(configuration);
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {string} [origin]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendEmail1(origin, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendEmail1(origin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordRecoveryApi.sendEmail1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryRequest} [passwordRecoveryRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePassword1(passwordRecoveryRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePassword1(passwordRecoveryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordRecoveryApi.updatePassword1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateToken1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateToken1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PasswordRecoveryApi.validateToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * PasswordRecoveryApi - factory interface
 * @export
 */
export const PasswordRecoveryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PasswordRecoveryApiFp(configuration);
    return {
        /**
         * In this email it will be contained all process information to change password and recover access
         * @summary Send an email to user that has forgotted his/her password
         * @param {PasswordRecoveryApiSendEmail1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmail1(requestParameters = {}, options) {
            return localVarFp.sendEmail1(requestParameters.origin, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update the password user, finishing the recovery password process
         * @param {PasswordRecoveryApiUpdatePassword1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePassword1(requestParameters = {}, options) {
            return localVarFp.updatePassword1(requestParameters.passwordRecoveryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Validate that password recovery token supplied was valid and current
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateToken1(options) {
            return localVarFp.validateToken1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PasswordRecoveryApi - object-oriented interface
 * @export
 * @class PasswordRecoveryApi
 * @extends {BaseAPI}
 */
export class PasswordRecoveryApi extends BaseAPI {
    /**
     * In this email it will be contained all process information to change password and recover access
     * @summary Send an email to user that has forgotted his/her password
     * @param {PasswordRecoveryApiSendEmail1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    sendEmail1(requestParameters = {}, options) {
        return PasswordRecoveryApiFp(this.configuration).sendEmail1(requestParameters.origin, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update the password user, finishing the recovery password process
     * @param {PasswordRecoveryApiUpdatePassword1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    updatePassword1(requestParameters = {}, options) {
        return PasswordRecoveryApiFp(this.configuration).updatePassword1(requestParameters.passwordRecoveryRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Validate that password recovery token supplied was valid and current
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PasswordRecoveryApi
     */
    validateToken1(options) {
        return PasswordRecoveryApiFp(this.configuration).validateToken1(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PhonePrefixesApi - axios parameter creator
 * @export
 */
export const PhonePrefixesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2: async (options = {}) => {
            const localVarPath = `/country-phone-prefixes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PhonePrefixesApi - functional programming interface
 * @export
 */
export const PhonePrefixesApiFp = function (configuration) {
    const localVarAxiosParamCreator = PhonePrefixesApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get2(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PhonePrefixesApi.get2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * PhonePrefixesApi - factory interface
 * @export
 */
export const PhonePrefixesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PhonePrefixesApiFp(configuration);
    return {
        /**
         * Retrieves a list of all available country phone prefixes with their details
         * @summary Returns all country-phone-prefixes list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get2(options) {
            return localVarFp.get2(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PhonePrefixesApi - object-oriented interface
 * @export
 * @class PhonePrefixesApi
 * @extends {BaseAPI}
 */
export class PhonePrefixesApi extends BaseAPI {
    /**
     * Retrieves a list of all available country phone prefixes with their details
     * @summary Returns all country-phone-prefixes list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PhonePrefixesApi
     */
    get2(options) {
        return PhonePrefixesApiFp(this.configuration).get2(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PropertiesApi - axios parameter creator
 * @export
 */
export const PropertiesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Publication state update
         * @param {string} propertyId Property ID
         * @param {string} body Publication state to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus2: async (propertyId, body, options = {}) => {
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('changePublicationStatus2', 'propertyId', propertyId);
            // verify required parameter 'body' is not null or undefined
            assertParamExists('changePublicationStatus2', 'body', body);
            const localVarPath = `/properties/{propertyId}/publication-state`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {string} id Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteProperty1', 'id', id);
            const localVarPath = `/properties/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fetch random list of properties related to a given property
         * @param {string} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties: async (propertyId, options = {}) => {
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('fetchRandomProperties', 'propertyId', propertyId);
            const localVarPath = `/properties/{propertyId}/related-properties`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties2: async (options = {}) => {
            const localVarPath = `/properties/fetch-random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Search properties with specified filters
         * @param {PropertyFilterCriteria} propertyFilterCriteria Property filter criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperties1: async (propertyFilterCriteria, options = {}) => {
            // verify required parameter 'propertyFilterCriteria' is not null or undefined
            assertParamExists('findProperties1', 'propertyFilterCriteria', propertyFilterCriteria);
            const localVarPath = `/properties/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(propertyFilterCriteria, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {string} range location range
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPropertiesByLocationRange1: async (range, options = {}) => {
            // verify required parameter 'range' is not null or undefined
            assertParamExists('findPropertiesByLocationRange1', 'range', range);
            const localVarPath = `/properties/by_location_range/{range}`
                .replace(`{${"range"}}`, encodeURIComponent(String(range)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} propertyId Property ID
         * @param {string} [password] Password for protected properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperty1: async (propertyId, password, options = {}) => {
            // verify required parameter 'propertyId' is not null or undefined
            assertParamExists('findProperty1', 'propertyId', propertyId);
            const localVarPath = `/properties/{propertyId}`
                .replace(`{${"propertyId"}}`, encodeURIComponent(String(propertyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} id property id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertyOldUrl1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findPropertyOldUrl1', 'id', id);
            const localVarPath = `/properties/detail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftsProperties1: async (options = {}) => {
            const localVarPath = `/properties/drafts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {string} [email] Email to filter properties by user
         * @param {number} [minutes] Minutes to look back (default 60)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProperties1: async (email, minutes, options = {}) => {
            const localVarPath = `/properties/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }
            if (minutes !== undefined) {
                localVarQueryParameter['minutes'] = minutes;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuredProperties1: async (options = {}) => {
            const localVarPath = `/properties/password-protected`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {string} id Property ID to generate preview for
         * @param {string} [lang] Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
         * @param {string} [acceptLanguage] Browser\&#39;s accepted language header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty2: async (id, lang, acceptLanguage, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('previewProperty2', 'id', id);
            const localVarPath = `/properties/previews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {Property} property Property to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProperty1: async (property, options = {}) => {
            // verify required parameter 'property' is not null or undefined
            assertParamExists('saveProperty1', 'property', property);
            const localVarPath = `/properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {WeeklyAlertRange} [weeklyAlertRange]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert2: async (weeklyAlertRange, options = {}) => {
            const localVarPath = `/properties/weekly-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(weeklyAlertRange, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGroupAlert1: async (options = {}) => {
            const localVarPath = `/properties/weekly-group-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PropertiesApi - functional programming interface
 * @export
 */
export const PropertiesApiFp = function (configuration) {
    const localVarAxiosParamCreator = PropertiesApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Publication state update
         * @param {string} propertyId Property ID
         * @param {string} body Publication state to set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePublicationStatus2(propertyId, body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePublicationStatus2(propertyId, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.changePublicationStatus2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {string} id Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProperty1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProperty1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.deleteProperty1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Fetch random list of properties related to a given property
         * @param {string} propertyId Property ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomProperties(propertyId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomProperties(propertyId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.fetchRandomProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomProperties2(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomProperties2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.fetchRandomProperties2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Search properties with specified filters
         * @param {PropertyFilterCriteria} propertyFilterCriteria Property filter criteria
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProperties1(propertyFilterCriteria, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProperties1(propertyFilterCriteria, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {string} range location range
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findPropertiesByLocationRange1(range, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertiesByLocationRange1(range, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findPropertiesByLocationRange1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} propertyId Property ID
         * @param {string} [password] Password for protected properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProperty1(propertyId, password, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProperty1(propertyId, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findProperty1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {string} id property id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPropertyOldUrl1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertyOldUrl1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.findPropertyOldUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDraftsProperties1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDraftsProperties1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getDraftsProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {string} [email] Email to filter properties by user
         * @param {number} [minutes] Minutes to look back (default 60)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentProperties1(email, minutes, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentProperties1(email, minutes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getRecentProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecuredProperties1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecuredProperties1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.getSecuredProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {string} id Property ID to generate preview for
         * @param {string} [lang] Language code for the preview (e.g., \&#39;en\&#39;, \&#39;es\&#39;)
         * @param {string} [acceptLanguage] Browser\&#39;s accepted language header
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewProperty2(id, lang, acceptLanguage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewProperty2(id, lang, acceptLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.previewProperty2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {Property} property Property to persist
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveProperty1(property, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveProperty1(property, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.saveProperty1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {WeeklyAlertRange} [weeklyAlertRange]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendAlert2(weeklyAlertRange, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendAlert2(weeklyAlertRange, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.sendAlert2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendGroupAlert1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendGroupAlert1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertiesApi.sendGroupAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * PropertiesApi - factory interface
 * @export
 */
export const PropertiesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PropertiesApiFp(configuration);
    return {
        /**
         *
         * @summary Publication state update
         * @param {PropertiesApiChangePublicationStatus2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus2(requestParameters, options) {
            return localVarFp.changePublicationStatus2(requestParameters.propertyId, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * This process is not reversible
         * @summary Delete the property with id supplied
         * @param {PropertiesApiDeleteProperty1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProperty1(requestParameters, options) {
            return localVarFp.deleteProperty1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fetch random list of properties related to a given property
         * @param {PropertiesApiFetchRandomPropertiesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties(requestParameters, options) {
            return localVarFp.fetchRandomProperties(requestParameters.propertyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a randomized list of properties with the specified count limit
         * @summary Fetch random list of properties, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomProperties2(options) {
            return localVarFp.fetchRandomProperties2(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search properties with specified filters
         * @param {PropertiesApiFindProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperties1(requestParameters, options) {
            return localVarFp.findProperties1(requestParameters.propertyFilterCriteria, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {PropertiesApiFindPropertiesByLocationRange1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPropertiesByLocationRange1(requestParameters, options) {
            return localVarFp.findPropertiesByLocationRange1(requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {PropertiesApiFindProperty1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProperty1(requestParameters, options) {
            return localVarFp.findProperty1(requestParameters.propertyId, requestParameters.password, options).then((request) => request(axios, basePath));
        },
        /**
         * Filter the properties existing in system with specified id. Returns empty if none property match the id
         * @summary Return the property with specified id
         * @param {PropertiesApiFindPropertyOldUrl1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertyOldUrl1(requestParameters, options) {
            return localVarFp.findPropertyOldUrl1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDraftsProperties1(options) {
            return localVarFp.getDraftsProperties1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get recently created properties within specified minutes (default 60)
         * @param {PropertiesApiGetRecentProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentProperties1(requestParameters = {}, options) {
            return localVarFp.getRecentProperties1(requestParameters.email, requestParameters.minutes, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Password Protected Property for Signed in User
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecuredProperties1(options) {
            return localVarFp.getSecuredProperties1(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns HTML preview for sharing a property on social media or messaging apps
         * @summary Get HTML preview for a property
         * @param {PropertiesApiPreviewProperty2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty2(requestParameters, options) {
            return localVarFp.previewProperty2(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can saveNew its properties
         * @summary Create or update the property supplied
         * @param {PropertiesApiSaveProperty1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveProperty1(requestParameters, options) {
            return localVarFp.saveProperty1(requestParameters.property, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {PropertiesApiSendAlert2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendAlert2(requestParameters = {}, options) {
            return localVarFp.sendAlert2(requestParameters.weeklyAlertRange, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendGroupAlert1(options) {
            return localVarFp.sendGroupAlert1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PropertiesApi - object-oriented interface
 * @export
 * @class PropertiesApi
 * @extends {BaseAPI}
 */
export class PropertiesApi extends BaseAPI {
    /**
     *
     * @summary Publication state update
     * @param {PropertiesApiChangePublicationStatus2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    changePublicationStatus2(requestParameters, options) {
        return PropertiesApiFp(this.configuration).changePublicationStatus2(requestParameters.propertyId, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This process is not reversible
     * @summary Delete the property with id supplied
     * @param {PropertiesApiDeleteProperty1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    deleteProperty1(requestParameters, options) {
        return PropertiesApiFp(this.configuration).deleteProperty1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fetch random list of properties related to a given property
     * @param {PropertiesApiFetchRandomPropertiesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    fetchRandomProperties(requestParameters, options) {
        return PropertiesApiFp(this.configuration).fetchRandomProperties(requestParameters.propertyId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a randomized list of properties with the specified count limit
     * @summary Fetch random list of properties, with basic data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    fetchRandomProperties2(options) {
        return PropertiesApiFp(this.configuration).fetchRandomProperties2(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search properties with specified filters
     * @param {PropertiesApiFindProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    findProperties1(requestParameters, options) {
        return PropertiesApiFp(this.configuration).findProperties1(requestParameters.propertyFilterCriteria, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the property list with specified user id
     * @param {PropertiesApiFindPropertiesByLocationRange1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    findPropertiesByLocationRange1(requestParameters, options) {
        return PropertiesApiFp(this.configuration).findPropertiesByLocationRange1(requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter the properties existing in system with specified id. Returns empty if none property match the id
     * @summary Return the property with specified id
     * @param {PropertiesApiFindProperty1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    findProperty1(requestParameters, options) {
        return PropertiesApiFp(this.configuration).findProperty1(requestParameters.propertyId, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Filter the properties existing in system with specified id. Returns empty if none property match the id
     * @summary Return the property with specified id
     * @param {PropertiesApiFindPropertyOldUrl1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    findPropertyOldUrl1(requestParameters, options) {
        return PropertiesApiFp(this.configuration).findPropertyOldUrl1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Password Protected Property for Signed in User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    getDraftsProperties1(options) {
        return PropertiesApiFp(this.configuration).getDraftsProperties1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get recently created properties within specified minutes (default 60)
     * @param {PropertiesApiGetRecentProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    getRecentProperties1(requestParameters = {}, options) {
        return PropertiesApiFp(this.configuration).getRecentProperties1(requestParameters.email, requestParameters.minutes, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Password Protected Property for Signed in User
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    getSecuredProperties1(options) {
        return PropertiesApiFp(this.configuration).getSecuredProperties1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns HTML preview for sharing a property on social media or messaging apps
     * @summary Get HTML preview for a property
     * @param {PropertiesApiPreviewProperty2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    previewProperty2(requestParameters, options) {
        return PropertiesApiFp(this.configuration).previewProperty2(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Consider that only user can saveNew its properties
     * @summary Create or update the property supplied
     * @param {PropertiesApiSaveProperty1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    saveProperty1(requestParameters, options) {
        return PropertiesApiFp(this.configuration).saveProperty1(requestParameters.property, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {PropertiesApiSendAlert2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    sendAlert2(requestParameters = {}, options) {
        return PropertiesApiFp(this.configuration).sendAlert2(requestParameters.weeklyAlertRange, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertiesApi
     */
    sendGroupAlert1(options) {
        return PropertiesApiFp(this.configuration).sendGroupAlert1(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PropertyBulkDownloadApi - axios parameter creator
 * @export
 */
export const PropertyBulkDownloadApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerKyeroExport1: async (options = {}) => {
            const localVarPath = `/property-bulk-download/trigger-kyero-export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type (e.g., kyero, idealista)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xml1: async (userId, xmlFormat, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('xml1', 'userId', userId);
            // verify required parameter 'xmlFormat' is not null or undefined
            assertParamExists('xml1', 'xmlFormat', xmlFormat);
            const localVarPath = `/property-bulk-download/{userId}/{xmlFormat}.xml`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"xmlFormat"}}`, encodeURIComponent(String(xmlFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        xmlRedirect1: async (userId, xmlFormat, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('xmlRedirect1', 'userId', userId);
            // verify required parameter 'xmlFormat' is not null or undefined
            assertParamExists('xmlRedirect1', 'xmlFormat', xmlFormat);
            const localVarPath = `/property-bulk-download/{userId}/{xmlFormat}.xml.redirect`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"xmlFormat"}}`, encodeURIComponent(String(xmlFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PropertyBulkDownloadApi - functional programming interface
 * @export
 */
export const PropertyBulkDownloadApiFp = function (configuration) {
    const localVarAxiosParamCreator = PropertyBulkDownloadApiAxiosParamCreator(configuration);
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerKyeroExport1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerKyeroExport1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkDownloadApi.triggerKyeroExport1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type (e.g., kyero, idealista)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async xml1(userId, xmlFormat, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.xml1(userId, xmlFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkDownloadApi.xml1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {string} userId User ID for the property owner
         * @param {string} xmlFormat XML format type
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async xmlRedirect1(userId, xmlFormat, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.xmlRedirect1(userId, xmlFormat, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkDownloadApi.xmlRedirect1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * PropertyBulkDownloadApi - factory interface
 * @export
 */
export const PropertyBulkDownloadApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PropertyBulkDownloadApiFp(configuration);
    return {
        /**
         * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
         * @summary Manually trigger Kyero exports to S3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerKyeroExport1(options) {
            return localVarFp.triggerKyeroExport1(options).then((request) => request(axios, basePath));
        },
        /**
         * Generates and returns property data in XML format for a specific user and format type.
         * @summary Get property XML for specific user
         * @param {PropertyBulkDownloadApiXml1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        xml1(requestParameters, options) {
            return localVarFp.xml1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(axios, basePath));
        },
        /**
         * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
         * @summary Redirect to XML file (Deprecated)
         * @param {PropertyBulkDownloadApiXmlRedirect1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        xmlRedirect1(requestParameters, options) {
            return localVarFp.xmlRedirect1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PropertyBulkDownloadApi - object-oriented interface
 * @export
 * @class PropertyBulkDownloadApi
 * @extends {BaseAPI}
 */
export class PropertyBulkDownloadApi extends BaseAPI {
    /**
     * Initiates the process to export all property data in Kyero format to S3 storage. Requires admin privileges.
     * @summary Manually trigger Kyero exports to S3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    triggerKyeroExport1(options) {
        return PropertyBulkDownloadApiFp(this.configuration).triggerKyeroExport1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates and returns property data in XML format for a specific user and format type.
     * @summary Get property XML for specific user
     * @param {PropertyBulkDownloadApiXml1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    xml1(requestParameters, options) {
        return PropertyBulkDownloadApiFp(this.configuration).xml1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Redirects to the XML file stored in S3 for a specific user and format. This endpoint is deprecated.
     * @summary Redirect to XML file (Deprecated)
     * @param {PropertyBulkDownloadApiXmlRedirect1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PropertyBulkDownloadApi
     */
    xmlRedirect1(requestParameters, options) {
        return PropertyBulkDownloadApiFp(this.configuration).xmlRedirect1(requestParameters.userId, requestParameters.xmlFormat, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PropertyBulkUploadsApi - axios parameter creator
 * @export
 */
export const PropertyBulkUploadsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormats1: async (options = {}) => {
            const localVarPath = `/property-bulk-uploads/formats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {string} [body] Properties XML content in Kyero format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties2: async (body, options = {}) => {
            const localVarPath = `/property-bulk-uploads/in-body`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/xml';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroPropertiesFromUrl1: async (xmlUrl, options = {}) => {
            const localVarPath = `/property-bulk-uploads/in-url`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(xmlUrl, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {UploadProperties1FormatEnum} format Format identifier
         * @param {string} [body] Properties XML content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProperties1: async (format, body, options = {}) => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('uploadProperties1', 'format', format);
            const localVarPath = `/property-bulk-uploads/{format}/in-body`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/xml';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {UploadPropertiesFromUrl1FormatEnum} format Format identifier
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPropertiesFromUrl1: async (format, xmlUrl, options = {}) => {
            // verify required parameter 'format' is not null or undefined
            assertParamExists('uploadPropertiesFromUrl1', 'format', format);
            const localVarPath = `/property-bulk-uploads/{format}/in-url`
                .replace(`{${"format"}}`, encodeURIComponent(String(format)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(xmlUrl, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PropertyBulkUploadsApi - functional programming interface
 * @export
 */
export const PropertyBulkUploadsApiFp = function (configuration) {
    const localVarAxiosParamCreator = PropertyBulkUploadsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormats1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormats1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.getFormats1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {string} [body] Properties XML content in Kyero format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroProperties2(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroProperties2(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadKyeroProperties2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadKyeroPropertiesFromUrl1(xmlUrl, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadKyeroPropertiesFromUrl1(xmlUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadKyeroPropertiesFromUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {UploadProperties1FormatEnum} format Format identifier
         * @param {string} [body] Properties XML content
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadProperties1(format, body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadProperties1(format, body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadProperties1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {UploadPropertiesFromUrl1FormatEnum} format Format identifier
         * @param {XmlUrl} [xmlUrl] XML URL object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadPropertiesFromUrl1(format, xmlUrl, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPropertiesFromUrl1(format, xmlUrl, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyBulkUploadsApi.uploadPropertiesFromUrl1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * PropertyBulkUploadsApi - factory interface
 * @export
 */
export const PropertyBulkUploadsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PropertyBulkUploadsApiFp(configuration);
    return {
        /**
         * Get the list of supported file formats for bulk upload
         * @summary Get available formats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormats1(options) {
            return localVarFp.getFormats1(options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties using Kyero format with XML content in the request body
         * @summary Upload Kyero properties with XML in request body
         * @param {PropertyBulkUploadsApiUploadKyeroProperties2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroProperties2(requestParameters = {}, options) {
            return localVarFp.uploadKyeroProperties2(requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties in Kyero format by providing a URL to an XML file
         * @summary Upload Kyero properties from URL
         * @param {PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadKyeroPropertiesFromUrl1(requestParameters = {}, options) {
            return localVarFp.uploadKyeroPropertiesFromUrl1(requestParameters.xmlUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties with XML content in the request body using the specified format
         * @summary Upload properties in specified format with XML in request body
         * @param {PropertyBulkUploadsApiUploadProperties1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadProperties1(requestParameters, options) {
            return localVarFp.uploadProperties1(requestParameters.format, requestParameters.body, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload properties in the specified format by providing a URL to an XML file
         * @summary Upload properties in specified format from URL
         * @param {PropertyBulkUploadsApiUploadPropertiesFromUrl1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPropertiesFromUrl1(requestParameters, options) {
            return localVarFp.uploadPropertiesFromUrl1(requestParameters.format, requestParameters.xmlUrl, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PropertyBulkUploadsApi - object-oriented interface
 * @export
 * @class PropertyBulkUploadsApi
 * @extends {BaseAPI}
 */
export class PropertyBulkUploadsApi extends BaseAPI {
    /**
     * Get the list of supported file formats for bulk upload
     * @summary Get available formats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    getFormats1(options) {
        return PropertyBulkUploadsApiFp(this.configuration).getFormats1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload properties using Kyero format with XML content in the request body
     * @summary Upload Kyero properties with XML in request body
     * @param {PropertyBulkUploadsApiUploadKyeroProperties2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    uploadKyeroProperties2(requestParameters = {}, options) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadKyeroProperties2(requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload properties in Kyero format by providing a URL to an XML file
     * @summary Upload Kyero properties from URL
     * @param {PropertyBulkUploadsApiUploadKyeroPropertiesFromUrl1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    uploadKyeroPropertiesFromUrl1(requestParameters = {}, options) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadKyeroPropertiesFromUrl1(requestParameters.xmlUrl, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload properties with XML content in the request body using the specified format
     * @summary Upload properties in specified format with XML in request body
     * @param {PropertyBulkUploadsApiUploadProperties1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    uploadProperties1(requestParameters, options) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadProperties1(requestParameters.format, requestParameters.body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Upload properties in the specified format by providing a URL to an XML file
     * @summary Upload properties in specified format from URL
     * @param {PropertyBulkUploadsApiUploadPropertiesFromUrl1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyBulkUploadsApi
     */
    uploadPropertiesFromUrl1(requestParameters, options) {
        return PropertyBulkUploadsApiFp(this.configuration).uploadPropertiesFromUrl1(requestParameters.format, requestParameters.xmlUrl, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * @export
 */
export const UploadProperties1FormatEnum = {
    Kyero: 'kyero',
    Wasico: 'wasico',
    Xml2u: 'xml2u',
    Hallocasa: 'hallocasa'
};
/**
 * @export
 */
export const UploadPropertiesFromUrl1FormatEnum = {
    Kyero: 'kyero',
    Wasico: 'wasico',
    Xml2u: 'xml2u',
    Hallocasa: 'hallocasa'
};
/**
 * PropertyFieldApi - axios parameter creator
 * @export
 */
export const PropertyFieldApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
         * @summary Retrieves property fields filtered by key
         * @param {PropertyKey} [propertyKey] key set of the property to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters2: async (propertyKey, options = {}) => {
            const localVarPath = `/property-fields/filter-by-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(propertyKey, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PropertyFieldApi - functional programming interface
 * @export
 */
export const PropertyFieldApiFp = function (configuration) {
    const localVarAxiosParamCreator = PropertyFieldApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
         * @summary Retrieves property fields filtered by key
         * @param {PropertyKey} [propertyKey] key set of the property to filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFilters2(propertyKey, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFilters2(propertyKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyFieldApi.getPropertyFilters2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * PropertyFieldApi - factory interface
 * @export
 */
export const PropertyFieldApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PropertyFieldApiFp(configuration);
    return {
        /**
         * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
         * @summary Retrieves property fields filtered by key
         * @param {PropertyFieldApiGetPropertyFilters2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters2(requestParameters = {}, options) {
            return localVarFp.getPropertyFilters2(requestParameters.propertyKey, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PropertyFieldApi - object-oriented interface
 * @export
 * @class PropertyFieldApi
 * @extends {BaseAPI}
 */
export class PropertyFieldApi extends BaseAPI {
    /**
     * Retrieves the list of property fields that will be showed when selecting the type, proposal, location, and country specified. All the property keys are required, otherwise system generate a bad request, because without all the parameters, it is not posible filter the property fields
     * @summary Retrieves property fields filtered by key
     * @param {PropertyFieldApiGetPropertyFilters2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFieldApi
     */
    getPropertyFilters2(requestParameters = {}, options) {
        return PropertyFieldApiFp(this.configuration).getPropertyFilters2(requestParameters.propertyKey, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PropertyFiltersApi - axios parameter creator
 * @export
 */
export const PropertyFiltersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {number} filterId ID of the filter to get options for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFieldOptions1: async (filterId, options = {}) => {
            // verify required parameter 'filterId' is not null or undefined
            assertParamExists('getPropertyFieldOptions1', 'filterId', filterId);
            const localVarPath = `/property_filters/options/{filter_id}`
                .replace(`{${"filter_id"}}`, encodeURIComponent(String(filterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {Array<number>} [filterNatureId] Filter nature IDs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters: async (filterNatureId, options = {}) => {
            const localVarPath = `/property_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (filterNatureId) {
                localVarQueryParameter['filter_nature_id'] = filterNatureId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PropertyFiltersApi - functional programming interface
 * @export
 */
export const PropertyFiltersApiFp = function (configuration) {
    const localVarAxiosParamCreator = PropertyFiltersApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {number} filterId ID of the filter to get options for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFieldOptions1(filterId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFieldOptions1(filterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyFiltersApi.getPropertyFieldOptions1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {Array<number>} [filterNatureId] Filter nature IDs to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPropertyFilters(filterNatureId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPropertyFilters(filterNatureId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyFiltersApi.getPropertyFilters']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * PropertyFiltersApi - factory interface
 * @export
 */
export const PropertyFiltersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PropertyFiltersApiFp(configuration);
    return {
        /**
         * Retrieves options for a specific property filter based on submitted filters
         * @summary Get property field options
         * @param {PropertyFiltersApiGetPropertyFieldOptions1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFieldOptions1(requestParameters, options) {
            return localVarFp.getPropertyFieldOptions1(requestParameters.filterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of property filters, optionally filtered by filter nature IDs
         * @summary Get property filters
         * @param {PropertyFiltersApiGetPropertyFiltersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPropertyFilters(requestParameters = {}, options) {
            return localVarFp.getPropertyFilters(requestParameters.filterNatureId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PropertyFiltersApi - object-oriented interface
 * @export
 * @class PropertyFiltersApi
 * @extends {BaseAPI}
 */
export class PropertyFiltersApi extends BaseAPI {
    /**
     * Retrieves options for a specific property filter based on submitted filters
     * @summary Get property field options
     * @param {PropertyFiltersApiGetPropertyFieldOptions1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFiltersApi
     */
    getPropertyFieldOptions1(requestParameters, options) {
        return PropertyFiltersApiFp(this.configuration).getPropertyFieldOptions1(requestParameters.filterId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a list of property filters, optionally filtered by filter nature IDs
     * @summary Get property filters
     * @param {PropertyFiltersApiGetPropertyFiltersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyFiltersApi
     */
    getPropertyFilters(requestParameters = {}, options) {
        return PropertyFiltersApiFp(this.configuration).getPropertyFilters(requestParameters.filterNatureId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PropertyLocationsApi - axios parameter creator
 * @export
 */
export const PropertyLocationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries: async (options = {}) => {
            const localVarPath = `/property-locations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PropertyLocationsApi - functional programming interface
 * @export
 */
export const PropertyLocationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = PropertyLocationsApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllCountries(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllCountries(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyLocationsApi.getAllCountries']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * PropertyLocationsApi - factory interface
 * @export
 */
export const PropertyLocationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PropertyLocationsApiFp(configuration);
    return {
        /**
         * Retrieves a list of all available property locations
         * @summary Method to find all the property locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCountries(options) {
            return localVarFp.getAllCountries(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PropertyLocationsApi - object-oriented interface
 * @export
 * @class PropertyLocationsApi
 * @extends {BaseAPI}
 */
export class PropertyLocationsApi extends BaseAPI {
    /**
     * Retrieves a list of all available property locations
     * @summary Method to find all the property locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyLocationsApi
     */
    getAllCountries(options) {
        return PropertyLocationsApiFp(this.configuration).getAllCountries(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PropertyProposalsApi - axios parameter creator
 * @export
 */
export const PropertyProposalsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyProposals1: async (options = {}) => {
            const localVarPath = `/property-proposals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PropertyProposalsApi - functional programming interface
 * @export
 */
export const PropertyProposalsApiFp = function (configuration) {
    const localVarAxiosParamCreator = PropertyProposalsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPropertyProposals1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPropertyProposals1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyProposalsApi.getAllPropertyProposals1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * PropertyProposalsApi - factory interface
 * @export
 */
export const PropertyProposalsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PropertyProposalsApiFp(configuration);
    return {
        /**
         *
         * @summary Method to find all the property proposals
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyProposals1(options) {
            return localVarFp.getAllPropertyProposals1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PropertyProposalsApi - object-oriented interface
 * @export
 * @class PropertyProposalsApi
 * @extends {BaseAPI}
 */
export class PropertyProposalsApi extends BaseAPI {
    /**
     *
     * @summary Method to find all the property proposals
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyProposalsApi
     */
    getAllPropertyProposals1(options) {
        return PropertyProposalsApiFp(this.configuration).getAllPropertyProposals1(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PropertyTypesApi - axios parameter creator
 * @export
 */
export const PropertyTypesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyTypes1: async (options = {}) => {
            const localVarPath = `/property-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * PropertyTypesApi - functional programming interface
 * @export
 */
export const PropertyTypesApiFp = function (configuration) {
    const localVarAxiosParamCreator = PropertyTypesApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPropertyTypes1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPropertyTypes1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PropertyTypesApi.getAllPropertyTypes1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * PropertyTypesApi - factory interface
 * @export
 */
export const PropertyTypesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PropertyTypesApiFp(configuration);
    return {
        /**
         * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
         * @summary Get all property types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPropertyTypes1(options) {
            return localVarFp.getAllPropertyTypes1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PropertyTypesApi - object-oriented interface
 * @export
 * @class PropertyTypesApi
 * @extends {BaseAPI}
 */
export class PropertyTypesApi extends BaseAPI {
    /**
     * Retrieves a list of all property types available in the system, including their IDs, names, language keys, active status, and associated property type groups.
     * @summary Get all property types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyTypesApi
     */
    getAllPropertyTypes1(options) {
        return PropertyTypesApiFp(this.configuration).getAllPropertyTypes1(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SecurityApi - axios parameter creator
 * @export
 */
export const SecurityApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize1: async (options = {}) => {
            const localVarPath = `/security/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {string} clientId Client application identifier
         * @param {string} code Authorization code received from /auth endpoint
         * @param {string} email User email address
         * @param {string} password User password
         * @param {string} [grantType] OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken1: async (clientId, code, email, password, grantType, clientSecret, options = {}) => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('requestToken1', 'clientId', clientId);
            // verify required parameter 'code' is not null or undefined
            assertParamExists('requestToken1', 'code', code);
            // verify required parameter 'email' is not null or undefined
            assertParamExists('requestToken1', 'email', email);
            // verify required parameter 'password' is not null or undefined
            assertParamExists('requestToken1', 'password', password);
            const localVarPath = `/security/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (clientId !== undefined) {
                localVarFormParams.set('client-id', clientId);
            }
            if (code !== undefined) {
                localVarFormParams.set('code', code);
            }
            if (email !== undefined) {
                localVarFormParams.set('email', email);
            }
            if (password !== undefined) {
                localVarFormParams.set('password', password);
            }
            if (grantType !== undefined) {
                localVarFormParams.set('grant_type', grantType);
            }
            if (clientSecret !== undefined) {
                localVarFormParams.set('client_secret', clientSecret);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SecurityApi - functional programming interface
 * @export
 */
export const SecurityApiFp = function (configuration) {
    const localVarAxiosParamCreator = SecurityApiAxiosParamCreator(configuration);
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.authorize1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {string} clientId Client application identifier
         * @param {string} code Authorization code received from /auth endpoint
         * @param {string} email User email address
         * @param {string} password User password
         * @param {string} [grantType] OAuth grant type (usually \\\&#39;authorization_code\\\&#39;)
         * @param {string} [clientSecret] Client application secret
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestToken1(clientId, code, email, password, grantType, clientSecret, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestToken1(clientId, code, email, password, grantType, clientSecret, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SecurityApi.requestToken1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * SecurityApi - factory interface
 * @export
 */
export const SecurityApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SecurityApiFp(configuration);
    return {
        /**
         * Generates an authorization code to be used with the token endpoint
         * @summary Authorize client application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize1(options) {
            return localVarFp.authorize1(options).then((request) => request(axios, basePath));
        },
        /**
         * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
         * @summary Exchange authorization code for access token
         * @param {SecurityApiRequestToken1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestToken1(requestParameters, options) {
            return localVarFp.requestToken1(requestParameters.clientId, requestParameters.code, requestParameters.email, requestParameters.password, requestParameters.grantType, requestParameters.clientSecret, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
export class SecurityApi extends BaseAPI {
    /**
     * Generates an authorization code to be used with the token endpoint
     * @summary Authorize client application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    authorize1(options) {
        return SecurityApiFp(this.configuration).authorize1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Exchanges the provided authorization code, username, and password for a token through which private application resources can be accessed. Note that the token expires in 15 minutes. When this happens, you must invoke this service again with the previously described parameters.
     * @summary Exchange authorization code for access token
     * @param {SecurityApiRequestToken1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    requestToken1(requestParameters, options) {
        return SecurityApiFp(this.configuration).requestToken1(requestParameters.clientId, requestParameters.code, requestParameters.email, requestParameters.password, requestParameters.grantType, requestParameters.clientSecret, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SkillsApi - axios parameter creator
 * @export
 */
export const SkillsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills2: async (options = {}) => {
            const localVarPath = `/skills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SkillsApi - functional programming interface
 * @export
 */
export const SkillsApiFp = function (configuration) {
    const localVarAxiosParamCreator = SkillsApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSkills2(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSkills2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SkillsApi.retrieveUserSkills2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * SkillsApi - factory interface
 * @export
 */
export const SkillsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SkillsApiFp(configuration);
    return {
        /**
         * Returns a list of all available user skills in the system
         * @summary Retrieve all user skills
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills2(options) {
            return localVarFp.retrieveUserSkills2(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SkillsApi - object-oriented interface
 * @export
 * @class SkillsApi
 * @extends {BaseAPI}
 */
export class SkillsApi extends BaseAPI {
    /**
     * Returns a list of all available user skills in the system
     * @summary Retrieve all user skills
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SkillsApi
     */
    retrieveUserSkills2(options) {
        return SkillsApiFp(this.configuration).retrieveUserSkills2(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * StripeWebhooksApi - axios parameter creator
 * @export
 */
export const StripeWebhooksApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Notify user subscription change
         * @param {StripeEvent} [stripeEvent]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSubscriptionChange1: async (stripeEvent, options = {}) => {
            const localVarPath = `/stripe-webhooks/user-subscription-update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(stripeEvent, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * StripeWebhooksApi - functional programming interface
 * @export
 */
export const StripeWebhooksApiFp = function (configuration) {
    const localVarAxiosParamCreator = StripeWebhooksApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Notify user subscription change
         * @param {StripeEvent} [stripeEvent]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUserSubscriptionChange1(stripeEvent, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUserSubscriptionChange1(stripeEvent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StripeWebhooksApi.postUserSubscriptionChange1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * StripeWebhooksApi - factory interface
 * @export
 */
export const StripeWebhooksApiFactory = function (configuration, basePath, axios) {
    const localVarFp = StripeWebhooksApiFp(configuration);
    return {
        /**
         *
         * @summary Notify user subscription change
         * @param {StripeWebhooksApiPostUserSubscriptionChange1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUserSubscriptionChange1(requestParameters = {}, options) {
            return localVarFp.postUserSubscriptionChange1(requestParameters.stripeEvent, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * StripeWebhooksApi - object-oriented interface
 * @export
 * @class StripeWebhooksApi
 * @extends {BaseAPI}
 */
export class StripeWebhooksApi extends BaseAPI {
    /**
     *
     * @summary Notify user subscription change
     * @param {StripeWebhooksApiPostUserSubscriptionChange1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeWebhooksApi
     */
    postUserSubscriptionChange1(requestParameters = {}, options) {
        return StripeWebhooksApiFp(this.configuration).postUserSubscriptionChange1(requestParameters.stripeEvent, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('get', 'userId', userId);
            const localVarPath = `/users/{userId}/subscriptions`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveFeatures1: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getActiveFeatures1', 'userId', userId);
            const localVarPath = `/users/{userId}/subscriptions/active/features`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the active and available subscription plans
         * @param {Array<string>} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll1: async (expand, options = {}) => {
            const localVarPath = `/subscription-plans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (expand) {
                localVarQueryParameter['expand'] = expand;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActiveFeatures1(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getActiveFeatures1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.getActiveFeatures1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the active and available subscription plans
         * @param {Array<string>} [expand]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll1(expand, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll1(expand, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SubscriptionsApi.getAll1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SubscriptionsApiFp(configuration);
    return {
        /**
         *
         * @param {SubscriptionsApiGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(requestParameters, options) {
            return localVarFp.get(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SubscriptionsApiGetActiveFeatures1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActiveFeatures1(requestParameters, options) {
            return localVarFp.getActiveFeatures1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the active and available subscription plans
         * @param {SubscriptionsApiGetAll1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll1(requestParameters = {}, options) {
            return localVarFp.getAll1(requestParameters.expand, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     *
     * @param {SubscriptionsApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    get(requestParameters, options) {
        return SubscriptionsApiFp(this.configuration).get(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {SubscriptionsApiGetActiveFeatures1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    getActiveFeatures1(requestParameters, options) {
        return SubscriptionsApiFp(this.configuration).getActiveFeatures1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the active and available subscription plans
     * @param {SubscriptionsApiGetAll1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    getAll1(requestParameters = {}, options) {
        return SubscriptionsApiFp(this.configuration).getAll1(requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TestimonialApi - axios parameter creator
 * @export
 */
export const TestimonialApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Publication state update
         * @param {string} testimonialId Testimonial Id
         * @param {boolean} publicationState Publication State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus: async (testimonialId, publicationState, options = {}) => {
            // verify required parameter 'testimonialId' is not null or undefined
            assertParamExists('changePublicationStatus', 'testimonialId', testimonialId);
            // verify required parameter 'publicationState' is not null or undefined
            assertParamExists('changePublicationStatus', 'publicationState', publicationState);
            const localVarPath = `/testimonial/{testimonialId}/publication-state/{publicationState}`
                .replace(`{${"testimonialId"}}`, encodeURIComponent(String(testimonialId)))
                .replace(`{${"publicationState"}}`, encodeURIComponent(String(publicationState)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fetch User Posted list of testimonials
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPublishedTestimonials1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/testimonial/published`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Fetch User Received list of testimonials
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchReceivedTestimonials1: async (pageFrom, pageTo, options = {}) => {
            const localVarPath = `/testimonial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {string} testimonialId testimonial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonial1: async (testimonialId, options = {}) => {
            // verify required parameter 'testimonialId' is not null or undefined
            assertParamExists('findTestimonial1', 'testimonialId', testimonialId);
            const localVarPath = `/testimonial/{testimonialId}`
                .replace(`{${"testimonialId"}}`, encodeURIComponent(String(testimonialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequests1: async (options = {}) => {
            const localVarPath = `/testimonial/requested`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequestsReceived1: async (options = {}) => {
            const localVarPath = `/testimonial/request-received`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTestimonial1: async (options = {}) => {
            const localVarPath = `/testimonial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TestimonialApi - functional programming interface
 * @export
 */
export const TestimonialApiFp = function (configuration) {
    const localVarAxiosParamCreator = TestimonialApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Publication state update
         * @param {string} testimonialId Testimonial Id
         * @param {boolean} publicationState Publication State
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePublicationStatus(testimonialId, publicationState, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePublicationStatus(testimonialId, publicationState, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.changePublicationStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Fetch User Posted list of testimonials
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchPublishedTestimonials1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchPublishedTestimonials1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.fetchPublishedTestimonials1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Fetch User Received list of testimonials
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchReceivedTestimonials1(pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchReceivedTestimonials1(pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.fetchReceivedTestimonials1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {string} testimonialId testimonial id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonial1(testimonialId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonial1(testimonialId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.findTestimonial1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialRequests1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialRequests1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.findTestimonialRequests1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialRequestsReceived1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialRequestsReceived1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.findTestimonialRequestsReceived1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTestimonial1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTestimonial1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestimonialApi.saveTestimonial1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * TestimonialApi - factory interface
 * @export
 */
export const TestimonialApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TestimonialApiFp(configuration);
    return {
        /**
         *
         * @summary Publication state update
         * @param {TestimonialApiChangePublicationStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePublicationStatus(requestParameters, options) {
            return localVarFp.changePublicationStatus(requestParameters.testimonialId, requestParameters.publicationState, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fetch User Posted list of testimonials
         * @param {TestimonialApiFetchPublishedTestimonials1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPublishedTestimonials1(requestParameters = {}, options) {
            return localVarFp.fetchPublishedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Fetch User Received list of testimonials
         * @param {TestimonialApiFetchReceivedTestimonials1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchReceivedTestimonials1(requestParameters = {}, options) {
            return localVarFp.fetchReceivedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the testimonial with specified id, it needs to be published
         * @param {TestimonialApiFindTestimonial1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonial1(requestParameters, options) {
            return localVarFp.findTestimonial1(requestParameters.testimonialId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the testimonial Requests a user Created
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequests1(options) {
            return localVarFp.findTestimonialRequests1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the testimonial Requests a user Received
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialRequestsReceived1(options) {
            return localVarFp.findTestimonialRequestsReceived1(options).then((request) => request(axios, basePath));
        },
        /**
         * Consider that only user can save new testimonials
         * @summary Create or update the Testimonial supplied
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTestimonial1(options) {
            return localVarFp.saveTestimonial1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TestimonialApi - object-oriented interface
 * @export
 * @class TestimonialApi
 * @extends {BaseAPI}
 */
export class TestimonialApi extends BaseAPI {
    /**
     *
     * @summary Publication state update
     * @param {TestimonialApiChangePublicationStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    changePublicationStatus(requestParameters, options) {
        return TestimonialApiFp(this.configuration).changePublicationStatus(requestParameters.testimonialId, requestParameters.publicationState, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fetch User Posted list of testimonials
     * @param {TestimonialApiFetchPublishedTestimonials1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    fetchPublishedTestimonials1(requestParameters = {}, options) {
        return TestimonialApiFp(this.configuration).fetchPublishedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Fetch User Received list of testimonials
     * @param {TestimonialApiFetchReceivedTestimonials1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    fetchReceivedTestimonials1(requestParameters = {}, options) {
        return TestimonialApiFp(this.configuration).fetchReceivedTestimonials1(requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the testimonial with specified id, it needs to be published
     * @param {TestimonialApiFindTestimonial1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    findTestimonial1(requestParameters, options) {
        return TestimonialApiFp(this.configuration).findTestimonial1(requestParameters.testimonialId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the testimonial Requests a user Created
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    findTestimonialRequests1(options) {
        return TestimonialApiFp(this.configuration).findTestimonialRequests1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the testimonial Requests a user Received
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    findTestimonialRequestsReceived1(options) {
        return TestimonialApiFp(this.configuration).findTestimonialRequestsReceived1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Consider that only user can save new testimonials
     * @summary Create or update the Testimonial supplied
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestimonialApi
     */
    saveTestimonial1(options) {
        return TestimonialApiFp(this.configuration).saveTestimonial1(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TextTranslationsApi - axios parameter creator
 * @export
 */
export const TextTranslationsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {string} [targetLang]
         * @param {string} [text]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateText1: async (targetLang, text, options = {}) => {
            const localVarPath = `/text-translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (targetLang !== undefined) {
                localVarQueryParameter['targetLang'] = targetLang;
            }
            if (text !== undefined) {
                localVarQueryParameter['text'] = text;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TextTranslationsApi - functional programming interface
 * @export
 */
export const TextTranslationsApiFp = function (configuration) {
    const localVarAxiosParamCreator = TextTranslationsApiAxiosParamCreator(configuration);
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {string} [targetLang]
         * @param {string} [text]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translateText1(targetLang, text, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translateText1(targetLang, text, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TextTranslationsApi.translateText1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * TextTranslationsApi - factory interface
 * @export
 */
export const TextTranslationsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TextTranslationsApiFp(configuration);
    return {
        /**
         * Translate the provided text to the specified target language
         * @summary Get text translation to a target language
         * @param {TextTranslationsApiTranslateText1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translateText1(requestParameters = {}, options) {
            return localVarFp.translateText1(requestParameters.targetLang, requestParameters.text, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TextTranslationsApi - object-oriented interface
 * @export
 * @class TextTranslationsApi
 * @extends {BaseAPI}
 */
export class TextTranslationsApi extends BaseAPI {
    /**
     * Translate the provided text to the specified target language
     * @summary Get text translation to a target language
     * @param {TextTranslationsApiTranslateText1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTranslationsApi
     */
    translateText1(requestParameters = {}, options) {
        return TextTranslationsApiFp(this.configuration).translateText1(requestParameters.targetLang, requestParameters.text, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserConnectionsApi - axios parameter creator
 * @export
 */
export const UserConnectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get a user connections
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections2: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findUserConnections2', 'userId', userId);
            const localVarPath = `/chat/users/{userId}/connections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserConnectionsApi - functional programming interface
 * @export
 */
export const UserConnectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserConnectionsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get a user connections
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserConnections2(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserConnections2(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserConnectionsApi.findUserConnections2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * UserConnectionsApi - factory interface
 * @export
 */
export const UserConnectionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserConnectionsApiFp(configuration);
    return {
        /**
         *
         * @summary Get a user connections
         * @param {UserConnectionsApiFindUserConnections2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections2(requestParameters, options) {
            return localVarFp.findUserConnections2(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserConnectionsApi - object-oriented interface
 * @export
 * @class UserConnectionsApi
 * @extends {BaseAPI}
 */
export class UserConnectionsApi extends BaseAPI {
    /**
     *
     * @summary Get a user connections
     * @param {UserConnectionsApiFindUserConnections2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserConnectionsApi
     */
    findUserConnections2(requestParameters, options) {
        return UserConnectionsApiFp(this.configuration).findUserConnections2(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserContractsApi - axios parameter creator
 * @export
 */
export const UserContractsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get a user Contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserContracts1: async (options = {}) => {
            const localVarPath = `/contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Save a user Contract
         * @param {Contract} contract Contract to save
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save2: async (contract, options = {}) => {
            // verify required parameter 'contract' is not null or undefined
            assertParamExists('save2', 'contract', contract);
            const localVarPath = `/contract`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(contract, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserContractsApi - functional programming interface
 * @export
 */
export const UserContractsApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserContractsApiAxiosParamCreator(configuration);
    return {
        /**
         *
         * @summary Get a user Contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserContracts1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserContracts1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserContractsApi.findUserContracts1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Save a user Contract
         * @param {Contract} contract Contract to save
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save2(contract, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save2(contract, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserContractsApi.save2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * UserContractsApi - factory interface
 * @export
 */
export const UserContractsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserContractsApiFp(configuration);
    return {
        /**
         *
         * @summary Get a user Contracts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserContracts1(options) {
            return localVarFp.findUserContracts1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Save a user Contract
         * @param {UserContractsApiSave2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save2(requestParameters, options) {
            return localVarFp.save2(requestParameters.contract, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserContractsApi - object-oriented interface
 * @export
 * @class UserContractsApi
 * @extends {BaseAPI}
 */
export class UserContractsApi extends BaseAPI {
    /**
     *
     * @summary Get a user Contracts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserContractsApi
     */
    findUserContracts1(options) {
        return UserContractsApiFp(this.configuration).findUserContracts1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Save a user Contract
     * @param {UserContractsApiSave2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserContractsApi
     */
    save2(requestParameters, options) {
        return UserContractsApiFp(this.configuration).save2(requestParameters.contract, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserSummaryApi - axios parameter creator
 * @export
 */
export const UserSummaryApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieves summaries of all chat conversations for a user
         * @summary Get the user chat summaries
         * @param {number} userId User ID to fetch chat summaries for
         * @param {number} [limit] Limit the number of chat summaries returned
         * @param {LocalDateTimeQueryString} [beforeDatetime] Only return chat summaries before this datetime (UTC timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatSummaryByUser1: async (userId, limit, beforeDatetime, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getChatSummaryByUser1', 'userId', userId);
            const localVarPath = `/chat/user_summary/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (beforeDatetime !== undefined) {
                for (const [key, value] of Object.entries(beforeDatetime)) {
                    localVarQueryParameter[key] = value;
                }
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserSummaryApi - functional programming interface
 * @export
 */
export const UserSummaryApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserSummaryApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieves summaries of all chat conversations for a user
         * @summary Get the user chat summaries
         * @param {number} userId User ID to fetch chat summaries for
         * @param {number} [limit] Limit the number of chat summaries returned
         * @param {LocalDateTimeQueryString} [beforeDatetime] Only return chat summaries before this datetime (UTC timestamp)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChatSummaryByUser1(userId, limit, beforeDatetime, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChatSummaryByUser1(userId, limit, beforeDatetime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserSummaryApi.getChatSummaryByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * UserSummaryApi - factory interface
 * @export
 */
export const UserSummaryApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserSummaryApiFp(configuration);
    return {
        /**
         * Retrieves summaries of all chat conversations for a user
         * @summary Get the user chat summaries
         * @param {UserSummaryApiGetChatSummaryByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChatSummaryByUser1(requestParameters, options) {
            return localVarFp.getChatSummaryByUser1(requestParameters.userId, requestParameters.limit, requestParameters.beforeDatetime, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserSummaryApi - object-oriented interface
 * @export
 * @class UserSummaryApi
 * @extends {BaseAPI}
 */
export class UserSummaryApi extends BaseAPI {
    /**
     * Retrieves summaries of all chat conversations for a user
     * @summary Get the user chat summaries
     * @param {UserSummaryApiGetChatSummaryByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSummaryApi
     */
    getChatSummaryByUser1(requestParameters, options) {
        return UserSummaryApiFp(this.configuration).getChatSummaryByUser1(requestParameters.userId, requestParameters.limit, requestParameters.beforeDatetime, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserTypesApi - axios parameter creator
 * @export
 */
export const UserTypesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTypes1: async (options = {}) => {
            const localVarPath = `/user-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UserTypesApi - functional programming interface
 * @export
 */
export const UserTypesApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserTypesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTypes1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTypes1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserTypesApi.getUserTypes1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * UserTypesApi - factory interface
 * @export
 */
export const UserTypesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserTypesApiFp(configuration);
    return {
        /**
         * Returns all available user types in the system
         * @summary Get user types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTypes1(options) {
            return localVarFp.getUserTypes1(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserTypesApi - object-oriented interface
 * @export
 * @class UserTypesApi
 * @extends {BaseAPI}
 */
export class UserTypesApi extends BaseAPI {
    /**
     * Returns all available user types in the system
     * @summary Get user types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserTypesApi
     */
    getUserTypes1(options) {
        return UserTypesApiFp(this.configuration).getUserTypes1(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser1: async (options = {}) => {
            const localVarPath = `/users/activate-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {number} userId ID of the user to add skills to
         * @param {Array<UserSkill>} userSkill List of skills to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserSkills1: async (userId, userSkill, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addUserSkills1', 'userId', userId);
            // verify required parameter 'userSkill' is not null or undefined
            assertParamExists('addUserSkills1', 'userSkill', userSkill);
            const localVarPath = `/users/{userId}/skills`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(userSkill, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPhoneVerificationCodeCommand1: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('checkPhoneVerificationCodeCommand1', 'userId', userId);
            const localVarPath = `/users/{userId}/phone-code-check`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {number} userId ID of the user whose skill is being endorsed
         * @param {number} skillId ID of the skill being endorsed
         * @param {SkillEndorsement} skillEndorsement Endorsement details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endorseUserSkill1: async (userId, skillId, skillEndorsement, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('endorseUserSkill1', 'userId', userId);
            // verify required parameter 'skillId' is not null or undefined
            assertParamExists('endorseUserSkill1', 'skillId', skillId);
            // verify required parameter 'skillEndorsement' is not null or undefined
            assertParamExists('endorseUserSkill1', 'skillEndorsement', skillEndorsement);
            const localVarPath = `/users/{userId}/skills/{skillId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"skillId"}}`, encodeURIComponent(String(skillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(skillEndorsement, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomUsers1: async (options = {}) => {
            const localVarPath = `/users/fetch-random`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('find', 'userId', userId);
            const localVarPath = `/users/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {string} [profileName] User\&#39;s profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1: async (profileName, options = {}) => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (profileName !== undefined) {
                localVarQueryParameter['profileName'] = profileName;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {string} userIds Comma-separated list of user IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findList1: async (userIds, options = {}) => {
            // verify required parameter 'userIds' is not null or undefined
            assertParamExists('findList1', 'userIds', userIds);
            const localVarPath = `/users/list/{userIds}`
                .replace(`{${"userIds"}}`, encodeURIComponent(String(userIds)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {string} [propertyPublicationState]
         * @param {string} [xmlId]
         * @param {string} [aPIVersion]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertiesByUser1: async (id, pageFrom, pageTo, propertyPublicationState, xmlId, aPIVersion, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findPropertiesByUser1', 'id', id);
            const localVarPath = `/users/{id}/properties`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            if (propertyPublicationState !== undefined) {
                localVarQueryParameter['propertyPublicationState'] = propertyPublicationState;
            }
            if (xmlId !== undefined) {
                localVarQueryParameter['xmlId'] = xmlId;
            }
            if (aPIVersion != null) {
                localVarHeaderParameter['API-Version'] = String(aPIVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Return the testimonials list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialsByUser1: async (id, pageFrom, pageTo, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findTestimonialsByUser1', 'id', id);
            const localVarPath = `/users/{id}/testimonials`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (pageFrom !== undefined) {
                localVarQueryParameter['pageFrom'] = pageFrom;
            }
            if (pageTo !== undefined) {
                localVarQueryParameter['pageTo'] = pageTo;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('findUserConnections', 'userId', userId);
            const localVarPath = `/users/{userId}/connections`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {string} subscriptionPlanName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedUsers1: async (subscriptionPlanName, options = {}) => {
            // verify required parameter 'subscriptionPlanName' is not null or undefined
            assertParamExists('getSubscribedUsers1', 'subscriptionPlanName', subscriptionPlanName);
            const localVarPath = `/users/subscribed-users/{subscriptionPlanName}`
                .replace(`{${"subscriptionPlanName"}}`, encodeURIComponent(String(subscriptionPlanName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {number} [id]
         * @param {string} [lang]
         * @param {string} [acceptLanguage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty: async (id, lang, acceptLanguage, options = {}) => {
            const localVarPath = `/users/previews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }
            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {string} [origin]
         * @param {boolean} [skipEmailValidation] Skip email validation step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register1: async (origin, skipEmailValidation, options = {}) => {
            const localVarPath = `/users/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (skipEmailValidation !== undefined) {
                localVarQueryParameter['skipEmailValidation'] = skipEmailValidation;
            }
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {string} [origin]
         * @param {string} [email]
         * @param {string} [password]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestActivationLink1: async (origin, email, password, options = {}) => {
            const localVarPath = `/users/activation_link_request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (email !== undefined) {
                localVarFormParams.set('email', email);
            }
            if (password !== undefined) {
                localVarFormParams.set('password', password);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            if (origin != null) {
                localVarHeaderParameter['Origin'] = String(origin);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Request testimonial from specified user id
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTestimonialFromUser1: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('requestTestimonialFromUser1', 'id', id);
            const localVarPath = `/users/{id}/request-testimonial`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {number} userId ID of the user whose skill endorsements to retrieve
         * @param {number} skillId ID of the skill to retrieve endorsements for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSkillEndorsements1: async (userId, skillId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveSkillEndorsements1', 'userId', userId);
            // verify required parameter 'skillId' is not null or undefined
            assertParamExists('retrieveSkillEndorsements1', 'skillId', skillId);
            const localVarPath = `/users/{userId}/skills/{skillId}/endorsements`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"skillId"}}`, encodeURIComponent(String(skillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {number} userId ID of the user to retrieve skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('retrieveUserSkills', 'userId', userId);
            const localVarPath = `/users/{userId}/skills`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {string} [oAuthToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save: async (oAuthToken, options = {}) => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            if (oAuthToken != null) {
                localVarHeaderParameter['O-Auth-Token'] = String(oAuthToken);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {LogEntry} [logEntry]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLog1: async (logEntry, options = {}) => {
            const localVarPath = `/log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(logEntry, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Searches for users matching the specified filter criteria
         * @summary Search users with specified filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers1: async (options = {}) => {
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayedSusbscribersAlert1: async (options = {}) => {
            const localVarPath = `/users/weekly-payed-subscribers-alert`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPhoneVerificationCodeCommand1: async (userId, options = {}) => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('sendPhoneVerificationCodeCommand1', 'userId', userId);
            const localVarPath = `/users/{userId}/phone-code-request`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication oAuthCode required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Code", configuration);
            // authentication oAuthClientId required
            await setApiKeyToObject(localVarHeaderParameter, "O-Auth-Client-Id", configuration);
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async activateUser1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activateUser1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.activateUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {number} userId ID of the user to add skills to
         * @param {Array<UserSkill>} userSkill List of skills to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserSkills1(userId, userSkill, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserSkills1(userId, userSkill, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.addUserSkills1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkPhoneVerificationCodeCommand1(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkPhoneVerificationCodeCommand1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.checkPhoneVerificationCodeCommand1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {number} userId ID of the user whose skill is being endorsed
         * @param {number} skillId ID of the skill being endorsed
         * @param {SkillEndorsement} skillEndorsement Endorsement details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endorseUserSkill1(userId, skillId, skillEndorsement, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endorseUserSkill1(userId, skillId, skillEndorsement, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.endorseUserSkill1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRandomUsers1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRandomUsers1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.fetchRandomUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.find']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {string} [profileName] User\&#39;s profile name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async find1(profileName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.find1(profileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.find1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {string} userIds Comma-separated list of user IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findList1(userIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findList1(userIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findList1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {string} [propertyPublicationState]
         * @param {string} [xmlId]
         * @param {string} [aPIVersion]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPropertiesByUser1(id, pageFrom, pageTo, propertyPublicationState, xmlId, aPIVersion, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPropertiesByUser1(id, pageFrom, pageTo, propertyPublicationState, xmlId, aPIVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findPropertiesByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Return the testimonials list with specified user id
         * @param {string} id user id
         * @param {number} [pageFrom]
         * @param {number} [pageTo]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTestimonialsByUser1(id, pageFrom, pageTo, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTestimonialsByUser1(id, pageFrom, pageTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findTestimonialsByUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserConnections(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserConnections(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.findUserConnections']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {string} subscriptionPlanName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscribedUsers1(subscriptionPlanName, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscribedUsers1(subscriptionPlanName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getSubscribedUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {number} [id]
         * @param {string} [lang]
         * @param {string} [acceptLanguage]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async previewProperty(id, lang, acceptLanguage, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.previewProperty(id, lang, acceptLanguage, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.previewProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {string} [origin]
         * @param {boolean} [skipEmailValidation] Skip email validation step
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register1(origin, skipEmailValidation, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register1(origin, skipEmailValidation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.register1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {string} [origin]
         * @param {string} [email]
         * @param {string} [password]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestActivationLink1(origin, email, password, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestActivationLink1(origin, email, password, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.requestActivationLink1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @summary Request testimonial from specified user id
         * @param {string} id user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestTestimonialFromUser1(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestTestimonialFromUser1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.requestTestimonialFromUser1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {number} userId ID of the user whose skill endorsements to retrieve
         * @param {number} skillId ID of the skill to retrieve endorsements for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSkillEndorsements1(userId, skillId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSkillEndorsements1(userId, skillId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.retrieveSkillEndorsements1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {number} userId ID of the user to retrieve skills for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSkills(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSkills(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.retrieveUserSkills']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {string} [oAuthToken]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save(oAuthToken, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save(oAuthToken, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.save']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {LogEntry} [logEntry]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveLog1(logEntry, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveLog1(logEntry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.saveLog1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Searches for users matching the specified filter criteria
         * @summary Search users with specified filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUsers1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.searchUsers1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPayedSusbscribersAlert1(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPayedSusbscribersAlert1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.sendPayedSusbscribersAlert1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {number} userId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendPhoneVerificationCodeCommand1(userId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendPhoneVerificationCodeCommand1(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.sendPhoneVerificationCodeCommand1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    };
};
/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UsersApiFp(configuration);
    return {
        /**
         * Activates a user account using the activation key sent to their email
         * @summary Activate the account of specified user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser1(options) {
            return localVarFp.activateUser1(options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint is not supported. Use save user profile to update skills instead.
         * @summary Add user skills
         * @param {UsersApiAddUserSkills1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserSkills1(requestParameters, options) {
            return localVarFp.addUserSkills1(requestParameters.userId, requestParameters.userSkill, options).then((request) => request(axios, basePath));
        },
        /**
         * Verifies the code that was sent to the user\'s phone
         * @summary Verify the phone code sent to user
         * @param {UsersApiCheckPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkPhoneVerificationCodeCommand1(requestParameters, options) {
            return localVarFp.checkPhoneVerificationCodeCommand1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to endorse another user\'s skill
         * @summary Endorse a user skill
         * @param {UsersApiEndorseUserSkill1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endorseUserSkill1(requestParameters, options) {
            return localVarFp.endorseUserSkill1(requestParameters.userId, requestParameters.skillId, requestParameters.skillEndorsement, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a random selection of users based on specified criteria
         * @summary Fetch random list of users, with basic data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRandomUsers1(options) {
            return localVarFp.fetchRandomUsers1(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets detailed user information by user ID
         * @summary Fetch user detail according to its id
         * @param {UsersApiFindRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find(requestParameters, options) {
            return localVarFp.find(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets user information by their unique profile name
         * @summary Fetch user detail according to its profile name
         * @param {UsersApiFind1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        find1(requestParameters = {}, options) {
            return localVarFp.find1(requestParameters.profileName, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets detailed information for multiple users by their IDs
         * @summary Fetch multiple user detail according to its ids
         * @param {UsersApiFindList1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findList1(requestParameters, options) {
            return localVarFp.findList1(requestParameters.userIds, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the property list with specified user id
         * @param {UsersApiFindPropertiesByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPropertiesByUser1(requestParameters, options) {
            return localVarFp.findPropertiesByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, requestParameters.propertyPublicationState, requestParameters.xmlId, requestParameters.aPIVersion, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Return the testimonials list with specified user id
         * @param {UsersApiFindTestimonialsByUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTestimonialsByUser1(requestParameters, options) {
            return localVarFp.findTestimonialsByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of connections for a specific user
         * @summary Get a user connections
         * @param {UsersApiFindUserConnectionsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserConnections(requestParameters, options) {
            return localVarFp.findUserConnections(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all users who have subscribed to the specified subscription plan
         * @summary Gets the users subscribed to a subscription plan name like Professional
         * @param {UsersApiGetSubscribedUsers1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscribedUsers1(requestParameters, options) {
            return localVarFp.getSubscribedUsers1(requestParameters.subscriptionPlanName, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates an HTML preview of a user profile for sharing purposes
         * @summary Get HTML preview of a user profile
         * @param {UsersApiPreviewPropertyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        previewProperty(requestParameters = {}, options) {
            return localVarFp.previewProperty(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new user account in the system
         * @summary Register new user in the system
         * @param {UsersApiRegister1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register1(requestParameters = {}, options) {
            return localVarFp.register1(requestParameters.origin, requestParameters.skipEmailValidation, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an activation link to the user\'s email for account verification
         * @summary Request activation link
         * @param {UsersApiRequestActivationLink1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestActivationLink1(requestParameters = {}, options) {
            return localVarFp.requestActivationLink1(requestParameters.origin, requestParameters.email, requestParameters.password, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Request testimonial from specified user id
         * @param {UsersApiRequestTestimonialFromUser1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestTestimonialFromUser1(requestParameters, options) {
            return localVarFp.requestTestimonialFromUser1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all endorsements for a specific user skill
         * @summary Retrieve skill endorsements
         * @param {UsersApiRetrieveSkillEndorsements1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSkillEndorsements1(requestParameters, options) {
            return localVarFp.retrieveSkillEndorsements1(requestParameters.userId, requestParameters.skillId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all skills associated with a user
         * @summary Retrieve user skills
         * @param {UsersApiRetrieveUserSkillsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSkills(requestParameters, options) {
            return localVarFp.retrieveUserSkills(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates user profile information in the system
         * @summary Save the data of user in the system
         * @param {UsersApiSaveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save(requestParameters = {}, options) {
            return localVarFp.save(requestParameters.oAuthToken, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {UsersApiSaveLog1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveLog1(requestParameters = {}, options) {
            return localVarFp.saveLog1(requestParameters.logEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * Searches for users matching the specified filter criteria
         * @summary Search users with specified filters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers1(options) {
            return localVarFp.searchUsers1(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPayedSusbscribersAlert1(options) {
            return localVarFp.sendPayedSusbscribersAlert1(options).then((request) => request(axios, basePath));
        },
        /**
         * Sends a verification code to the user\'s phone number for verification purposes
         * @summary Send a code to the previously saved phone number of the user
         * @param {UsersApiSendPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendPhoneVerificationCodeCommand1(requestParameters, options) {
            return localVarFp.sendPhoneVerificationCodeCommand1(requestParameters.userId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Activates a user account using the activation key sent to their email
     * @summary Activate the account of specified user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    activateUser1(options) {
        return UsersApiFp(this.configuration).activateUser1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint is not supported. Use save user profile to update skills instead.
     * @summary Add user skills
     * @param {UsersApiAddUserSkills1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    addUserSkills1(requestParameters, options) {
        return UsersApiFp(this.configuration).addUserSkills1(requestParameters.userId, requestParameters.userSkill, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Verifies the code that was sent to the user\'s phone
     * @summary Verify the phone code sent to user
     * @param {UsersApiCheckPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    checkPhoneVerificationCodeCommand1(requestParameters, options) {
        return UsersApiFp(this.configuration).checkPhoneVerificationCodeCommand1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Allows a user to endorse another user\'s skill
     * @summary Endorse a user skill
     * @param {UsersApiEndorseUserSkill1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    endorseUserSkill1(requestParameters, options) {
        return UsersApiFp(this.configuration).endorseUserSkill1(requestParameters.userId, requestParameters.skillId, requestParameters.skillEndorsement, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves a random selection of users based on specified criteria
     * @summary Fetch random list of users, with basic data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    fetchRandomUsers1(options) {
        return UsersApiFp(this.configuration).fetchRandomUsers1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets detailed user information by user ID
     * @summary Fetch user detail according to its id
     * @param {UsersApiFindRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    find(requestParameters, options) {
        return UsersApiFp(this.configuration).find(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets user information by their unique profile name
     * @summary Fetch user detail according to its profile name
     * @param {UsersApiFind1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    find1(requestParameters = {}, options) {
        return UsersApiFp(this.configuration).find1(requestParameters.profileName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets detailed information for multiple users by their IDs
     * @summary Fetch multiple user detail according to its ids
     * @param {UsersApiFindList1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    findList1(requestParameters, options) {
        return UsersApiFp(this.configuration).findList1(requestParameters.userIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the property list with specified user id
     * @param {UsersApiFindPropertiesByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    findPropertiesByUser1(requestParameters, options) {
        return UsersApiFp(this.configuration).findPropertiesByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, requestParameters.propertyPublicationState, requestParameters.xmlId, requestParameters.aPIVersion, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Return the testimonials list with specified user id
     * @param {UsersApiFindTestimonialsByUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    findTestimonialsByUser1(requestParameters, options) {
        return UsersApiFp(this.configuration).findTestimonialsByUser1(requestParameters.id, requestParameters.pageFrom, requestParameters.pageTo, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves the list of connections for a specific user
     * @summary Get a user connections
     * @param {UsersApiFindUserConnectionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    findUserConnections(requestParameters, options) {
        return UsersApiFp(this.configuration).findUserConnections(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieves all users who have subscribed to the specified subscription plan
     * @summary Gets the users subscribed to a subscription plan name like Professional
     * @param {UsersApiGetSubscribedUsers1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    getSubscribedUsers1(requestParameters, options) {
        return UsersApiFp(this.configuration).getSubscribedUsers1(requestParameters.subscriptionPlanName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates an HTML preview of a user profile for sharing purposes
     * @summary Get HTML preview of a user profile
     * @param {UsersApiPreviewPropertyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    previewProperty(requestParameters = {}, options) {
        return UsersApiFp(this.configuration).previewProperty(requestParameters.id, requestParameters.lang, requestParameters.acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new user account in the system
     * @summary Register new user in the system
     * @param {UsersApiRegister1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    register1(requestParameters = {}, options) {
        return UsersApiFp(this.configuration).register1(requestParameters.origin, requestParameters.skipEmailValidation, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends an activation link to the user\'s email for account verification
     * @summary Request activation link
     * @param {UsersApiRequestActivationLink1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    requestActivationLink1(requestParameters = {}, options) {
        return UsersApiFp(this.configuration).requestActivationLink1(requestParameters.origin, requestParameters.email, requestParameters.password, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Request testimonial from specified user id
     * @param {UsersApiRequestTestimonialFromUser1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    requestTestimonialFromUser1(requestParameters, options) {
        return UsersApiFp(this.configuration).requestTestimonialFromUser1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all endorsements for a specific user skill
     * @summary Retrieve skill endorsements
     * @param {UsersApiRetrieveSkillEndorsements1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    retrieveSkillEndorsements1(requestParameters, options) {
        return UsersApiFp(this.configuration).retrieveSkillEndorsements1(requestParameters.userId, requestParameters.skillId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns all skills associated with a user
     * @summary Retrieve user skills
     * @param {UsersApiRetrieveUserSkillsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    retrieveUserSkills(requestParameters, options) {
        return UsersApiFp(this.configuration).retrieveUserSkills(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates user profile information in the system
     * @summary Save the data of user in the system
     * @param {UsersApiSaveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    save(requestParameters = {}, options) {
        return UsersApiFp(this.configuration).save(requestParameters.oAuthToken, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {UsersApiSaveLog1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    saveLog1(requestParameters = {}, options) {
        return UsersApiFp(this.configuration).saveLog1(requestParameters.logEntry, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Searches for users matching the specified filter criteria
     * @summary Search users with specified filters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    searchUsers1(options) {
        return UsersApiFp(this.configuration).searchUsers1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    sendPayedSusbscribersAlert1(options) {
        return UsersApiFp(this.configuration).sendPayedSusbscribersAlert1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends a verification code to the user\'s phone number for verification purposes
     * @summary Send a code to the previously saved phone number of the user
     * @param {UsersApiSendPhoneVerificationCodeCommand1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    sendPhoneVerificationCodeCommand1(requestParameters, options) {
        return UsersApiFp(this.configuration).sendPhoneVerificationCodeCommand1(requestParameters.userId, options).then((request) => request(this.axios, this.basePath));
    }
}
